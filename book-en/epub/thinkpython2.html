<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="generator" content="hevea 2.36">
<style type="text/css">
.c000{border-spacing:0;}
.c001{border-spacing:6px;border-collapse:separate;}
.c002{border:0;border-spacing:1;border-collapse:separate;}
.c003{border:none !important; margin:0px !important;}
.c004{font-family:monospace}
.c005{font-family:monospace;font-weight:bold}
.c006{font-family:sans-serif}
.c007{font-size:small}
.c008{font-size:x-large}
.c009{font-style:italic}
.c010{font-weight:bold}
.c011{text-align:center}
.c012{text-align:center;white-space:nowrap}
.c013{text-align:left;white-space:nowrap}
.c014{text-align:right;border:solid 1px;white-space:nowrap}
.c015{text-align:right;white-space:nowrap}
.c016{text-decoration:overline}
.c017{vertical-align:middle}
.c018{vertical-align:top;text-align:left;}
.floatrule{background-color: black; border: none; height: 1px; width: 80%}
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.footnotetext{margin:0ex; padding:0ex;}
div.footnotetext P{margin:0px; text-indent:1em;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{background-color: black; border: none; height: 1px; margin: 1em auto 1em 0px; width: 40%}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.center{text-align:center;margin-left:auto;margin-right:auto;}
div table{margin-left:inherit;margin-right:inherit;margin-bottom:2px;margin-top:2px}
td table{margin:auto;}
table{border-collapse:collapse;}
td{padding:0;}
.cellpadding0 tr td{padding:0;}
.cellpadding1 tr td{padding:1px;}
pre{text-align:left;margin-left:0ex;margin-right:auto;}
blockquote{margin-left:4ex;margin-right:4ex;text-align:left;}
td p{margin:0px;}
.quote{margin-left:3em;margin-right:3em;text-align:inherit;text-indent:0pt}
.quotation{margin-left:3em;margin-right:3em;text-align:inherit;text-indent:1.5em}
.horizontal-rule{border:none;background-color:black;}
.hrule{border:none;height:2px;width:100%;background-color:black;}
.display{border-collapse:separate;border-spacing:2px;line-height:1.1;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px; border:none;}
.dcenter{margin:0ex auto;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
a:link{color:black;}
p+p{margin-top:1em;margin-bottom:1em}
img{border:0px}
</style>
<title>Think Python
</title>
</head>
<body>
<!--HEVEA command line is: hevea -fix -O -e latexonly htmlonly thinkpython2 -->
<!--CUT STYLE book--><!--HTMLHEAD-->
<table>

<tr>

<td valign="top" width="100" bgcolor="#b6459a">
</td>

<td valign="top" width="600" style="padding: 20px 20px;">

<p>
<a href="http://amzn.to/1VUYQUU">Buy this book at Amazon.com</a>

<!--ENDHTML-->
<!--SETENV <arg PREVTXT><img src="back.png" ALT="Previous"></arg><arg UPTXT><img src="up.png" ALT="Up"></arg><arg NEXTTXT><img src="next.png" ALT="Next"></arg>-->
<!--CUT DEF chapter 1 --><p><span class="c008">Think Python: How to Think Like a Computer Scientist</span></p><p><span style="font-size:large">Allen B. Downey</span></p><p>2nd Edition, Version 2.4.0</p>
<!--TOC chapter id="sec1" Preface-->
<h1 class="chapter" id="sec1">Chapter&#XA0;0&#X2003;Preface</h1><!--SEC END --><!--TOC section id="sec2" The strange history of this book-->
<h2 class="section" id="sec2">The strange history of this book</h2><!--SEC END --><p>In January 1999 I was preparing to teach an introductory programming
class in Java. I had taught it three times and I was getting
frustrated. The failure rate in the class was too high and, even for
students who succeeded, the overall level of achievement was too low.</p><p>One of the problems I saw was the books.
They were too big, with too much unnecessary detail about Java, and
not enough high-level guidance about how to program. And they all
suffered from the trap door effect: they would start out easy,
proceed gradually, and then somewhere around Chapter 5 the bottom would
fall out. The students would get too much new material, too fast,
and I would spend the rest of the semester picking up the pieces.</p><p>Two weeks before the first day of classes, I decided to write my
own book. My goals were:</p><ul class="itemize"><li class="li-itemize">Keep it short. It is better for students to read 10 pages
than not read 50 pages.</li><li class="li-itemize">Be careful with vocabulary. I tried to minimize jargon
and define each term at first use.</li><li class="li-itemize">Build gradually. To avoid trap doors, I took the most difficult
topics and split them into a series of small steps.</li><li class="li-itemize">Focus on programming, not the programming language. I included
the minimum useful subset of Java and left out the rest.</li></ul><p>I needed a title, so on a whim I chose <em>How to Think Like
a Computer Scientist</em>.</p><p>My first version was rough, but it worked. Students did the reading,
and they understood enough that I could spend class time on the hard
topics, the interesting topics and (most important) letting the
students practice.</p><p>I released the book under the GNU Free Documentation License,
which allows users to copy, modify, and distribute the book.
<a id="hevea_default0"></a>
<a id="hevea_default1"></a></p><p>What happened next is the cool part. Jeff Elkner, a high school
teacher in Virginia, adopted my book and translated it into
Python. He sent me a copy of his translation, and I had the
unusual experience of learning Python by reading my own book.
As Green Tea Press, I published the first Python version in 2001.
<a id="hevea_default2"></a></p><p>In 2003 I started teaching at Olin College and I got to teach
Python for the first time. The contrast with Java was striking.
Students struggled less, learned more, worked on more interesting
projects, and generally had a lot more fun.
<a id="hevea_default3"></a></p><p>Since then I&#X2019;ve continued to develop the book,
correcting errors, improving some of the examples and
adding material, especially exercises.</p><p>The result is this book, now with the less grandiose title
<em>Think Python</em>. Some of the changes are:</p><ul class="itemize"><li class="li-itemize">I added a section about debugging at the end of each chapter.
These sections present general techniques for finding and avoiding
bugs, and warnings about Python pitfalls.</li><li class="li-itemize">I added more exercises, ranging from short tests of
understanding to a few substantial projects. Most exercises
include a link to my solution.</li><li class="li-itemize">I added a series of case studies&#X2014;longer examples with
exercises, solutions, and discussion.</li><li class="li-itemize">I expanded the discussion of program development plans
and basic design patterns.</li><li class="li-itemize">I added appendices about debugging and analysis of algorithms.</li></ul><p>The second edition of <em>Think Python</em> has these new features:</p><ul class="itemize"><li class="li-itemize">The book and all supporting code have been updated to Python 3.</li><li class="li-itemize">I added a few sections, and more details on the web, to help
beginners get started running Python in a browser, so you don&#X2019;t have
to deal with installing Python until you want to.</li><li class="li-itemize">For Chapter&#XA0;<a href="#turtle">4.1</a> I switched from my own turtle graphics
package, called Swampy, to a more standard Python module, <span class="c004">turtle</span>, which is easier to install and more powerful.</li><li class="li-itemize">I added a new chapter called &#X201C;The Goodies&#X201D;, which introduces
some additional Python features that are not strictly necessary, but
sometimes handy.</li></ul><p>I hope you enjoy working with this book, and that it helps
you learn to program and think like
a computer scientist, at least a little bit.</p><p>Allen B. Downey <br>

Olin College <br>
</p><!--TOC section id="sec3" Acknowledgments-->
<h2 class="section" id="sec3">Acknowledgments</h2><!--SEC END --><p>Many thanks to Jeff Elkner, who
translated my Java book into Python, which got this project
started and introduced me to what has turned out to be my
favorite language.
<a id="hevea_default4"></a></p><p>Thanks also to Chris Meyers, who contributed several sections
to <em>How to Think Like a Computer Scientist</em>.
<a id="hevea_default5"></a></p><p>Thanks to the Free Software Foundation for developing
the GNU Free Documentation License, which helped make
my collaboration with Jeff and Chris possible, and Creative
Commons for the license I am using now.
<a id="hevea_default6"></a>
<a id="hevea_default7"></a>
<a id="hevea_default8"></a></p><p>Thanks to the editors at Lulu who worked on
<em>How to Think Like a Computer Scientist</em>.</p><p>Thanks to the editors at O&#X2019;Reilly Media who worked on
<em>Think Python</em>.</p><p>Thanks to all the students who worked with earlier
versions of this book and all the contributors (listed
below) who sent in corrections and suggestions.</p><!--TOC section id="sec4" Contributor List-->
<h2 class="section" id="sec4">Contributor List</h2><!--SEC END --><p><a id="hevea_default9"></a>
More than 100 sharp-eyed and thoughtful readers have sent in
suggestions and corrections over the past few years. Their
contributions, and enthusiasm for this project, have been a
huge help.</p><p>If you have a suggestion or correction, please send email to
<span class="c004">feedback@thinkpython.com</span>. If I make a change based on your
feedback, I will add you to the contributor list
(unless you ask to be omitted).</p><p>If you include at least part of the sentence the
error appears in, that makes it easy for me to search. Page and
section numbers are fine, too, but not quite as easy to work with.
Thanks!</p><ul class="itemize"><li class="li-itemize"><span class="c007">Lloyd Hugh Allen sent in a correction to Section 8.4.</span></li><li class="li-itemize"><span class="c007">Yvon Boulianne sent in a correction of a semantic error in
Chapter 5.</span></li><li class="li-itemize"><span class="c007">Fred Bremmer submitted a correction in Section 2.1.</span></li><li class="li-itemize"><span class="c007">Jonah Cohen wrote the Perl scripts to convert the
LaTeX source for this book into beautiful HTML.</span></li><li class="li-itemize"><span class="c007">Michael Conlon sent in a grammar correction in Chapter 2
and an improvement in style in Chapter 1, and he initiated discussion
on the technical aspects of interpreters.</span></li><li class="li-itemize"><span class="c007">Beno&#XEE;t Girard sent in a
correction to a humorous mistake in Section 5.6.</span></li><li class="li-itemize"><span class="c007">Courtney Gleason and Katherine Smith wrote <span class="c004">horsebet.py</span>,
which was used as a case study in an earlier version of the book. Their
program can now be found on the website.</span></li><li class="li-itemize"><span class="c007">Lee Harr submitted more corrections than we have room to list
here, and indeed he should be listed as one of the principal editors
of the text.</span></li><li class="li-itemize"><span class="c007">James Kaylin is a student using the text. He has submitted
numerous corrections.</span></li><li class="li-itemize"><span class="c007">David Kershaw fixed the broken <span class="c004">catTwice</span> function in Section
3.10.</span></li><li class="li-itemize"><span class="c007">Eddie Lam has sent in numerous corrections to Chapters
1, 2, and 3.
He also fixed the Makefile so that it creates an index the first time it is
run and helped us set up a versioning scheme.</span></li><li class="li-itemize"><span class="c007">Man-Yong Lee sent in a correction to the example code in
Section 2.4.</span></li><li class="li-itemize"><span class="c007">David Mayo pointed out that the word &#X201C;unconsciously"
in Chapter 1 needed
to be changed to &#X201C;subconsciously".</span></li><li class="li-itemize"><span class="c007">Chris McAloon sent in several corrections to Sections 3.9 and
3.10.</span></li><li class="li-itemize"><span class="c007">Matthew J. Moelter has been a long-time contributor who sent
in numerous corrections and suggestions to the book.</span></li><li class="li-itemize"><span class="c007">Simon Dicon Montford reported a missing function definition and
several typos in Chapter 3. He also found errors in the <span class="c004">increment</span>
function in Chapter 13.</span></li><li class="li-itemize"><span class="c007">John Ouzts corrected the definition of &#X201C;return value"
in Chapter 3.</span></li><li class="li-itemize"><span class="c007">Kevin Parks sent in valuable comments and suggestions as to how
to improve the distribution of the book.</span></li><li class="li-itemize"><span class="c007">David Pool sent in a typo in the glossary of Chapter 1, as well
as kind words of encouragement.</span></li><li class="li-itemize"><span class="c007">Michael Schmitt sent in a correction to the chapter on files
and exceptions.</span></li><li class="li-itemize"><span class="c007">Robin Shaw pointed out an error in Section 13.1, where the
printTime function was used in an example without being defined.</span></li><li class="li-itemize"><span class="c007">Paul Sleigh found an error in Chapter 7 and a bug in Jonah Cohen&#X2019;s
Perl script that generates HTML from LaTeX.</span></li><li class="li-itemize"><span class="c007">Craig T. Snydal is testing the text in a course at Drew
University. He has contributed several valuable suggestions and corrections.</span></li><li class="li-itemize"><span class="c007">Ian Thomas and his students are using the text in a programming
course. They are the first ones to test the chapters in the latter half
of the book, and they have made numerous corrections and suggestions.</span></li><li class="li-itemize"><span class="c007">Keith Verheyden sent in a correction in Chapter 3.</span></li><li class="li-itemize"><span class="c007">Peter Winstanley let us know about a longstanding error in
our Latin in Chapter 3.</span></li><li class="li-itemize"><span class="c007">Chris Wrobel made corrections to the code in the chapter on
file I/O and exceptions.</span></li><li class="li-itemize"><span class="c007">Moshe Zadka has made invaluable contributions to this project.
In addition to writing the first draft of the chapter on Dictionaries, he
provided continual guidance in the early stages of the book.</span></li><li class="li-itemize"><span class="c007">Christoph Zwerschke sent several corrections and
pedagogic suggestions, and explained the difference between <em>gleich</em>
and <em>selbe</em>.</span></li><li class="li-itemize"><span class="c007">James Mayer sent us a whole slew of spelling and
typographical errors, including two in the contributor list.</span></li><li class="li-itemize"><span class="c007">Hayden McAfee caught a potentially confusing inconsistency
between two examples.</span></li><li class="li-itemize"><span class="c007">Angel Arnal is part of an international team of translators
working on the Spanish version of the text. He has also found several
errors in the English version.</span></li><li class="li-itemize"><span class="c007">Tauhidul Hoque and Lex Berezhny created the illustrations
in Chapter 1 and improved many of the other illustrations.</span></li><li class="li-itemize"><span class="c007">Dr. Michele Alzetta caught an error in Chapter 8 and sent
some interesting pedagogic comments and suggestions about Fibonacci
and Old Maid.</span></li><li class="li-itemize"><span class="c007">Andy Mitchell caught a typo in Chapter 1 and a broken example
in Chapter 2.</span></li><li class="li-itemize"><span class="c007">Kalin Harvey suggested a clarification in Chapter 7 and
caught some typos.</span></li><li class="li-itemize"><span class="c007">Christopher P. Smith caught several typos and helped us
update the book for Python 2.2.</span></li><li class="li-itemize"><span class="c007">David Hutchins caught a typo in the Foreword.</span></li><li class="li-itemize"><span class="c007">Gregor Lingl is teaching Python at a high school in Vienna,
Austria. He is working on a German translation of the book,
and he caught a couple of bad errors in Chapter 5.</span></li><li class="li-itemize"><span class="c007">Julie Peters caught a typo in the Preface.</span></li><li class="li-itemize"><span class="c007">Florin Oprina sent in an improvement in <span class="c004">makeTime</span>,
a correction in <span class="c004">printTime</span>, and a nice typo.</span></li><li class="li-itemize"><span class="c007">D.&#XA0;J.&#XA0;Webre suggested a clarification in Chapter 3.</span></li><li class="li-itemize"><span class="c007">Ken found a fistful of errors in Chapters 8, 9 and 11.</span></li><li class="li-itemize"><span class="c007">Ivo Wever caught a typo in Chapter 5 and suggested a clarification
in Chapter 3.</span></li><li class="li-itemize"><span class="c007">Curtis Yanko suggested a clarification in Chapter 2.</span></li><li class="li-itemize"><span class="c007">Ben Logan sent in a number of typos and problems with translating
the book into HTML.</span></li><li class="li-itemize"><span class="c007">Jason Armstrong saw the missing word in Chapter 2.</span></li><li class="li-itemize"><span class="c007">Louis Cordier noticed a spot in Chapter 16 where the code
didn&#X2019;t match the text.</span></li><li class="li-itemize"><span class="c007">Brian Cain suggested several clarifications in Chapters 2 and 3.</span></li><li class="li-itemize"><span class="c007">Rob Black sent in a passel of corrections, including some
changes for Python 2.2.</span></li><li class="li-itemize"><span class="c007">Jean-Philippe Rey at &#XC9;cole Centrale
Paris sent a number of patches, including some updates for Python 2.2
and other thoughtful improvements.</span></li><li class="li-itemize"><span class="c007">Jason Mader at George Washington University made a number
of useful suggestions and corrections.</span></li><li class="li-itemize"><span class="c007">Jan Gundtofte-Bruun reminded us that &#X201C;a error&#X201D; is an error.</span></li><li class="li-itemize"><span class="c007">Abel David and Alexis Dinno reminded us that the plural of
&#X201C;matrix&#X201D; is &#X201C;matrices&#X201D;, not &#X201C;matrixes&#X201D;. This error was in the
book for years, but two readers with the same initials reported it on
the same day. Weird.</span></li><li class="li-itemize"><span class="c007">Charles Thayer encouraged us to get rid of the semi-colons
we had put at the ends of some statements and to clean up our
use of &#X201C;argument&#X201D; and &#X201C;parameter&#X201D;.</span></li><li class="li-itemize"><span class="c007">Roger Sperberg pointed out a twisted piece of logic in Chapter 3.</span></li><li class="li-itemize"><span class="c007">Sam Bull pointed out a confusing paragraph in Chapter 2.</span></li><li class="li-itemize"><span class="c007">Andrew Cheung pointed out two instances of &#X201C;use before def&#X201D;.</span></li><li class="li-itemize"><span class="c007">C. Corey Capel spotted the missing word in the Third Theorem
of Debugging and a typo in Chapter 4.</span></li><li class="li-itemize"><span class="c007">Alessandra helped clear up some Turtle confusion.</span></li><li class="li-itemize"><span class="c007">Wim Champagne found a brain-o in a dictionary example.</span></li><li class="li-itemize"><span class="c007">Douglas Wright pointed out a problem with floor division in
<span class="c004">arc</span>.</span></li><li class="li-itemize"><span class="c007">Jared Spindor found some jetsam at the end of a sentence.</span></li><li class="li-itemize"><span class="c007">Lin Peiheng sent a number of very helpful suggestions.</span></li><li class="li-itemize"><span class="c007">Ray Hagtvedt sent in two errors and a not-quite-error.</span></li><li class="li-itemize"><span class="c007">Torsten H&#XFC;bsch pointed out an inconsistency in Swampy.</span></li><li class="li-itemize"><span class="c007">Inga Petuhhov corrected an example in Chapter 14.</span></li><li class="li-itemize"><span class="c007">Arne Babenhauserheide sent several helpful corrections.</span></li><li class="li-itemize"><span class="c007">Mark E. Casida is is good at spotting repeated words.</span></li><li class="li-itemize"><span class="c007">Scott Tyler filled in a that was missing. And then sent in
a heap of corrections.</span></li><li class="li-itemize"><span class="c007">Gordon Shephard sent in several corrections, all in separate
emails.</span></li><li class="li-itemize"><span class="c007">Andrew Turner <span class="c004">spot</span>ted an error in Chapter 8.</span></li><li class="li-itemize"><span class="c007">Adam Hobart fixed a problem with floor division in <span class="c004">arc</span>.</span></li><li class="li-itemize"><span class="c007">Daryl Hammond and Sarah Zimmerman pointed out that I served
up <span class="c004">math.pi</span> too early. And Zim spotted a typo.</span></li><li class="li-itemize"><span class="c007">George Sass found a bug in a Debugging section.</span></li><li class="li-itemize"><span class="c007">Brian Bingham suggested Exercise&#XA0;</span><a href="#exrotatepairs"><span class="c007">5</span></a><span class="c007">.</span></li><li class="li-itemize"><span class="c007">Leah Engelbert-Fenton pointed out that I used <span class="c004">tuple</span>
as a variable name, contrary to my own advice. And then found
a bunch of typos and a &#X201C;use before def&#X201D;.</span></li><li class="li-itemize"><span class="c007">Joe Funke spotted a typo.</span></li><li class="li-itemize"><span class="c007">Chao-chao Chen found an inconsistency in the Fibonacci example.</span></li><li class="li-itemize"><span class="c007">Jeff Paine knows the difference between space and spam.</span></li><li class="li-itemize"><span class="c007">Lubos Pintes sent in a typo.</span></li><li class="li-itemize"><span class="c007">Gregg Lind and Abigail Heithoff suggested Exercise&#XA0;</span><a href="#checksum"><span class="c007">3</span></a><span class="c007">.</span></li><li class="li-itemize"><span class="c007">Max Hailperin has sent in a number of corrections and
suggestions. Max is one of the authors of the extraordinary <em>Concrete Abstractions</em>, which you might want to read when you are
done with this book.</span></li><li class="li-itemize"><span class="c007">Chotipat Pornavalai found an error in an error message.</span></li><li class="li-itemize"><span class="c007">Stanislaw Antol sent a list of very helpful suggestions.</span></li><li class="li-itemize"><span class="c007">Eric Pashman sent a number of corrections for Chapters 4&#X2013;11.</span></li><li class="li-itemize"><span class="c007">Miguel Azevedo found some typos.</span></li><li class="li-itemize"><span class="c007">Jianhua Liu sent in a long list of corrections.</span></li><li class="li-itemize"><span class="c007">Nick King found a missing word.</span></li><li class="li-itemize"><span class="c007">Martin Zuther sent a long list of suggestions.</span></li><li class="li-itemize"><span class="c007">Adam Zimmerman found an inconsistency in my instance
of an &#X201C;instance&#X201D; and several other errors.</span></li><li class="li-itemize"><span class="c007">Ratnakar Tiwari suggested a footnote explaining degenerate
triangles.</span></li><li class="li-itemize"><span class="c007">Anurag Goel suggested another solution for </span><code class="verb"><span class="c007">is_abecedarian</span></code><span class="c007">
and sent some additional corrections. And he knows how to
spell Jane Austen.</span></li><li class="li-itemize"><span class="c007">Kelli Kratzer spotted one of the typos.</span></li><li class="li-itemize"><span class="c007">Mark Griffiths pointed out a confusing example in Chapter 3.</span></li><li class="li-itemize"><span class="c007">Roydan Ongie found an error in my Newton&#X2019;s method.</span></li><li class="li-itemize"><span class="c007">Patryk Wolowiec helped me with a problem in the HTML version.</span></li><li class="li-itemize"><span class="c007">Mark Chonofsky told me about a new keyword in Python 3.</span></li><li class="li-itemize"><span class="c007">Russell Coleman helped me with my geometry.</span></li><li class="li-itemize"><span class="c007">Nam Nguyen found a typo and pointed out that I used the Decorator
pattern but didn&#X2019;t mention it by name.</span></li><li class="li-itemize"><span class="c007">St&#XE9;phane Morin sent in several corrections and suggestions.</span></li><li class="li-itemize"><span class="c007">Paul Stoop corrected a typo in </span><code class="verb"><span class="c007">uses_only</span></code><span class="c007">.</span></li><li class="li-itemize"><span class="c007">Eric Bronner pointed out a confusion in the discussion of the
order of operations.</span></li><li class="li-itemize"><span class="c007">Alexandros Gezerlis set a new standard for the number and
quality of suggestions he submitted. We are deeply grateful!</span></li><li class="li-itemize"><span class="c007">Gray Thomas knows his right from his left.</span></li><li class="li-itemize"><span class="c007">Giovanni Escobar Sosa sent a long list of corrections and
suggestions.</span></li><li class="li-itemize"><span class="c007">Daniel Neilson corrected an error about the order of operations.</span></li><li class="li-itemize"><span class="c007">Will McGinnis pointed out that <span class="c004">polyline</span> was defined
differently in two places.</span></li><li class="li-itemize"><span class="c007">Frank Hecker pointed out an exercise that was under-specified, and
some broken links.</span></li><li class="li-itemize"><span class="c007">Animesh B helped me clean up a confusing example.</span></li><li class="li-itemize"><span class="c007">Martin Caspersen found two round-off errors.</span></li><li class="li-itemize"><span class="c007">Gregor Ulm sent several corrections and suggestions.</span></li><li class="li-itemize"><span class="c007">Dimitrios Tsirigkas suggested I clarify an exercise.</span></li><li class="li-itemize"><span class="c007">Carlos Tafur sent a page of corrections and suggestions.</span></li><li class="li-itemize"><span class="c007">Martin Nordsletten found a bug in an exercise solution.</span></li><li class="li-itemize"><span class="c007">Sven Hoexter pointed out that a variable named <span class="c004">input</span>
shadows a build-in function.</span></li><li class="li-itemize"><span class="c007">Stephen Gregory pointed out the problem with <span class="c004">cmp</span>
in Python 3.</span></li><li class="li-itemize"><span class="c007">Ishwar Bhat corrected my statement of Fermat&#X2019;s last theorem.</span></li><li class="li-itemize"><span class="c007">Andrea Zanella translated the book into Italian, and sent a
number of corrections along the way.</span></li><li class="li-itemize"><span class="c007">Many, many thanks to Melissa Lewis and Luciano Ramalho for
excellent comments and suggestions on the second edition.</span></li><li class="li-itemize"><span class="c007">Thanks to Harry Percival from PythonAnywhere for his help
getting people started running Python in a browser.</span></li><li class="li-itemize"><span class="c007">Xavier Van Aubel made several useful corrections in the second
edition.</span></li><li class="li-itemize"><span class="c007">William Murray corrected my definition of floor division.</span></li><li class="li-itemize"><span class="c007">Per Starb&#XE4;ck brought me up to date on universal newlines in Python 3.</span></li><li class="li-itemize"><span class="c007">Laurent Rosenfeld and Mihaela Rotaru translated this book into French. Along the way, they sent many corrections and suggestions.</span><p><span class="c007">In addition, people who spotted typos or made corrections include
Czeslaw Czapla, Dale Wilson, Francesco Carlo Cimini,
Richard Fursa, Brian McGhie, Lokesh Kumar Makani, Matthew Shultz, Viet
Le, Victor Simeone, Lars O.D. Christensen, Swarup Sahoo, Alix Etienne,
Kuang He, Wei Huang, Karen Barber, and Eric Ransom.</span></p></li></ul>
<!--TOC chapter id="sec5" The way of the program-->
<h1 class="chapter" id="sec5">Chapter&#XA0;1&#X2003;The way of the program</h1><!--SEC END --><p>The goal of this book is to teach you to think like a computer
scientist. This way of thinking combines some of the best features of
mathematics, engineering, and natural science. Like mathematicians,
computer scientists use formal languages to denote ideas (specifically
computations). Like engineers, they design things, assembling
components into systems and evaluating tradeoffs among alternatives.
Like scientists, they observe the behavior of complex systems, form
hypotheses, and test predictions. <a id="hevea_default10"></a></p><p>The single most important skill for a computer scientist is <span class="c010">problem solving</span>. Problem solving means the ability to formulate
problems, think creatively about solutions, and express a solution
clearly and accurately. As it turns out, the process of learning to
program is an excellent opportunity to practice problem-solving
skills. That&#X2019;s why this chapter is called, &#X201C;The way of the
program&#X201D;.</p><p>On one level, you will be learning to program, a useful skill by
itself. On another level, you will use programming as a means to an
end. As we go along, that end will become clearer.</p>
<!--TOC section id="sec6" What is a program?-->
<h2 class="section" id="sec6">1.1&#X2003;What is a program?</h2><!--SEC END --><p>A <span class="c010">program</span> is a sequence of instructions that specifies how to
perform a computation. The computation might be something
mathematical, such as solving a system of equations or finding the
roots of a polynomial, but it can also be a symbolic computation, such
as searching and replacing text in a document or something
graphical, like processing an image or playing a video.
<a id="hevea_default11"></a></p><p>The details look different in different languages, but a few basic
instructions appear in just about every language:</p><dl class="description"><dt class="dt-description"><span class="c010">input:</span></dt><dd class="dd-description"> Get data from the keyboard, a file, the network, or some
other device.</dd><dt class="dt-description"><span class="c010">output:</span></dt><dd class="dd-description"> Display data on the screen, save it in a
file, send it over the network, etc.</dd><dt class="dt-description"><span class="c010">math:</span></dt><dd class="dd-description"> Perform basic mathematical operations like addition and
multiplication.</dd><dt class="dt-description"><span class="c010">conditional execution:</span></dt><dd class="dd-description"> Check for certain conditions and
run the appropriate code.</dd><dt class="dt-description"><span class="c010">repetition:</span></dt><dd class="dd-description"> Perform some action repeatedly, usually with
some variation.</dd></dl><p>Believe it or not, that&#X2019;s pretty much all there is to it. Every
program you&#X2019;ve ever used, no matter how complicated, is made up of
instructions that look pretty much like these. So you can think of
programming as the process of breaking a large, complex task
into smaller and smaller subtasks until the subtasks are
simple enough to be performed with one of these basic instructions.</p>
<!--TOC section id="sec7" Running Python-->
<h2 class="section" id="sec7">1.2&#X2003;Running Python</h2><!--SEC END --><p>One of the challenges of getting started with Python is that you
might have to install Python and related software on your computer.
If you are familiar with your operating system, and especially
if you are comfortable with the command-line interface, you will
have no trouble installing Python. But for beginners, it can be
painful to learn about system administration and programming at the
same time.
<a id="hevea_default12"></a>
<a id="hevea_default13"></a></p><p>To avoid that problem, I recommend that you start out running Python
in a browser. Later, when you are comfortable with Python, I&#X2019;ll
make suggestions for installing Python on your computer.
<a id="hevea_default14"></a></p><p>There are a number of web pages you can use to run Python. If you
already have a favorite, go ahead and use it. Otherwise I recommend
PythonAnywhere. I provide detailed instructions for getting started
at <a href="http://tinyurl.com/thinkpython2e"><span class="c004">http://tinyurl.com/thinkpython2e</span></a>.
<a id="hevea_default15"></a></p><p>There are two versions of Python, called Python 2 and Python 3.
They are very similar, so if you learn one, it is easy to switch
to the other. In fact, there are only a few differences you will
encounter as a beginner.
This book is written for Python 3, but I include some notes
about Python 2.
<a id="hevea_default16"></a></p><p>The Python <span class="c010">interpreter</span> is a program that reads and executes
Python code. Depending on your environment, you might start the
interpreter by clicking on an icon, or by typing <span class="c004">python</span> on
a command line.
When it starts, you should see output like this:
<a id="hevea_default17"></a></p><pre class="verbatim">Python 3.4.0 (default, Jun 19 2015, 14:20:21)
[GCC 4.8.2] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;
</pre><p>
The first three lines contain information about the interpreter
and the operating system it&#X2019;s running on, so it might be different for
you. But you should check that the version number, which is
<span class="c004">3.4.0</span> in this example, begins with 3, which indicates that
you are running Python 3. If it begins with 2, you are running
(you guessed it) Python 2.</p><p>The last line is a <span class="c010">prompt</span> that indicates that the interpreter is
ready for you to enter code.
If you type a line of code and hit Enter, the interpreter displays the
result:
<a id="hevea_default18"></a></p><pre class="verbatim">&gt;&gt;&gt; 1 + 1
2
</pre><p>
Now you&#X2019;re ready to get started.
From here on, I assume that you know how to start the Python
interpreter and run code.</p>
<!--TOC section id="sec8" The first program-->
<h2 class="section" id="sec8">1.3&#X2003;The first program</h2><!--SEC END --><p>
<a id="hello"></a>
<a id="hevea_default19"></a></p><p>Traditionally, the first program you write in a new language
is called &#X201C;Hello, World!&#X201D; because all it does is display the
words &#X201C;Hello, World!&#X201D;. In Python, it looks like this:</p><pre class="verbatim">&gt;&gt;&gt; print('Hello, World!')
</pre><p>
This is an example of a <span class="c010">print statement</span>, although it
doesn&#X2019;t actually print anything on paper. It displays a result on the
screen. In this case, the result is the words</p><pre class="verbatim">Hello, World!
</pre><p>
The quotation marks in the program mark the beginning and end
of the text to be displayed; they don&#X2019;t appear in the result.
<a id="hevea_default20"></a>
<a id="hevea_default21"></a>
<a id="hevea_default22"></a></p><p>The parentheses indicate that <span class="c004">print</span> is a function. We&#X2019;ll get
to functions in Chapter&#XA0;<a href="#funcchap">3</a>.
<a id="hevea_default23"></a> <a id="hevea_default24"></a></p><p>In Python 2, the print statement is slightly different; it is not
a function, so it doesn&#X2019;t use parentheses.
<a id="hevea_default25"></a></p><pre class="verbatim">&gt;&gt;&gt; print 'Hello, World!'
</pre><p>
This distinction will make more sense soon, but that&#X2019;s enough to
get started.</p>
<!--TOC section id="sec9" Arithmetic operators-->
<h2 class="section" id="sec9">1.4&#X2003;Arithmetic operators</h2><!--SEC END --><p>
<a id="hevea_default26"></a>
<a id="hevea_default27"></a></p><p>After &#X201C;Hello, World&#X201D;, the next step is arithmetic. Python provides
<span class="c010">operators</span>, which are special symbols that represent computations
like addition and multiplication.</p><p>The operators <span class="c004">+</span>, <span class="c004">-</span>, and <span class="c004">*</span> perform addition,
subtraction, and multiplication, as in the following examples:</p><pre class="verbatim">&gt;&gt;&gt; 40 + 2
42
&gt;&gt;&gt; 43 - 1
42
&gt;&gt;&gt; 6 * 7
42
</pre><p>
The operator <span class="c004">/</span> performs division:</p><pre class="verbatim">&gt;&gt;&gt; 84 / 2
42.0
</pre><p>
You might wonder why the result is <span class="c004">42.0</span> instead of <span class="c004">42</span>.
I&#X2019;ll explain in the next section.</p><p>Finally, the operator <span class="c004">**</span> performs exponentiation; that is,
it raises a number to a power:</p><pre class="verbatim">&gt;&gt;&gt; 6**2 + 6
42
</pre><p>
In some other languages, <code class="verb">^</code> is used for exponentiation, but
in Python it is a bitwise operator called XOR. If you are not
familiar with bitwise operators, the result will surprise you:</p><pre class="verbatim">&gt;&gt;&gt; 6 ^ 2
4
</pre><p>
I won&#X2019;t cover
bitwise operators in this book, but you can read about
them at <a href="http://wiki.python.org/moin/BitwiseOperators"><span class="c004">http://wiki.python.org/moin/BitwiseOperators</span></a>.
<a id="hevea_default28"></a>
<a id="hevea_default29"></a></p>
<!--TOC section id="sec10" Values and types-->
<h2 class="section" id="sec10">1.5&#X2003;Values and types</h2><!--SEC END --><p>
<a id="hevea_default30"></a>
<a id="hevea_default31"></a>
<a id="hevea_default32"></a></p><p>A <span class="c010">value</span> is one of the basic things a program works with, like a
letter or a number. Some values we have seen so far are <span class="c004">2</span>,
<span class="c004">42.0</span>, and <code class="verb">'Hello, World!'</code>.</p><p>These values belong to different <span class="c010">types</span>:
<span class="c004">2</span> is an <span class="c010">integer</span>, <span class="c004">42.0</span> is a <span class="c010">floating-point number</span>,
and <code class="verb">'Hello, World!'</code> is a <span class="c010">string</span>,
so-called because the letters it contains are strung together.
<a id="hevea_default33"></a>
<a id="hevea_default34"></a></p><p>If you are not sure what type a value has, the interpreter can
tell you:</p><pre class="verbatim">&gt;&gt;&gt; type(2)
&lt;class 'int'&gt;
&gt;&gt;&gt; type(42.0)
&lt;class 'float'&gt;
&gt;&gt;&gt; type('Hello, World!')
&lt;class 'str'&gt;
</pre><p>
In these results, the word &#X201C;class&#X201D; is used in the sense of
a category; a type is a category of values.
<a id="hevea_default35"></a></p><p>Not surprisingly, integers belong to the type <span class="c004">int</span>,
strings belong to <span class="c004">str</span> and floating-point
numbers belong to <span class="c004">float</span>.
<a id="hevea_default36"></a>
<a id="hevea_default37"></a>
<a id="hevea_default38"></a>
<a id="hevea_default39"></a>
<a id="hevea_default40"></a>
<a id="hevea_default41"></a>
<a id="hevea_default42"></a></p><p>What about values like <code class="verb">'2'</code> and <code class="verb">'42.0'</code>?
They look like numbers, but they are in quotation marks like
strings.
<a id="hevea_default43"></a></p><pre class="verbatim">&gt;&gt;&gt; type('2')
&lt;class 'str'&gt;
&gt;&gt;&gt; type('42.0')
&lt;class 'str'&gt;
</pre><p>
They&#X2019;re strings.</p><p>When you type a large integer, you might be tempted to use commas
between groups of digits, as in <span class="c004">1,000,000</span>. This is not a
legal <em>integer</em> in Python, but it is legal:</p><pre class="verbatim">&gt;&gt;&gt; 1,000,000
(1, 0, 0)
</pre><p>
That&#X2019;s not what we expected at all! Python interprets <span class="c004">1,000,000</span> as a comma-separated sequence of integers. We&#X2019;ll learn
more about this kind of sequence later.
<a id="hevea_default44"></a></p>
<!--TOC section id="sec11" Formal and natural languages-->
<h2 class="section" id="sec11">1.6&#X2003;Formal and natural languages</h2><!--SEC END --><p>
<a id="hevea_default45"></a>
<a id="hevea_default46"></a>
<a id="hevea_default47"></a>
<a id="hevea_default48"></a></p><p><span class="c010">Natural languages</span> are the languages people speak,
such as English, Spanish, and French. They were not designed
by people (although people try to impose some order on them);
they evolved naturally.</p><p><span class="c010">Formal languages</span> are languages that are designed by people for
specific applications. For example, the notation that mathematicians
use is a formal language that is particularly good at denoting
relationships among numbers and symbols. Chemists use a formal
language to represent the chemical structure of molecules. And
most importantly:</p><blockquote class="quote">
<span class="c010">Programming languages are formal languages that have been
designed to express computations.</span>
</blockquote><p>Formal languages tend to have strict <span class="c010">syntax</span> rules that
govern the structure of statements.
For example, in mathematics the statement
3 + 3 = 6 has correct syntax, but
3 + = 3 $ 6 does not. In chemistry
<span class="c009">H</span><sub>2</sub><span class="c009">O</span> is a syntactically correct formula, but <sub>2</sub><span class="c009">Zz</span> is not.
<a id="hevea_default49"></a></p><p>Syntax rules come in two flavors, pertaining to <span class="c010">tokens</span> and
structure. Tokens are the basic elements of the language, such as
words, numbers, and chemical elements. One of the problems with
3 += 3 $ 6 is that  $  is not a legal token in mathematics
(at least as far as I know). Similarly, <sub>2</sub><span class="c009">Zz</span> is not legal because
there is no element with the abbreviation <span class="c009">Zz</span>.
<a id="hevea_default50"></a>
<a id="hevea_default51"></a></p><p>The second type of syntax rule pertains to the way tokens are
combined. The equation 3 +/ 3 is illegal because even though +
and / are legal tokens, you can&#X2019;t have one right after the other.
Similarly, in a chemical formula the subscript comes after the element
name, not before.</p><p>This is @ well-structured Engli$h
sentence with invalid t*kens in it. This sentence all valid tokens
has, but invalid structure with.</p><p>When you read a sentence in English or a statement in a formal
language, you have to figure out the structure
(although in a natural language you do this subconsciously). This
process is called <span class="c010">parsing</span>.
<a id="hevea_default52"></a></p><p>Although formal and natural languages have many features in
common&#X2014;tokens, structure, and syntax&#X2014;there are some
differences:
<a id="hevea_default53"></a>
<a id="hevea_default54"></a>
<a id="hevea_default55"></a></p><dl class="description"><dt class="dt-description"><span class="c010">ambiguity:</span></dt><dd class="dd-description"> Natural languages are full of ambiguity, which
people deal with by using contextual clues and other information.
Formal languages are designed to be nearly or completely unambiguous,
which means that any statement has exactly one meaning,
regardless of context.</dd><dt class="dt-description"><span class="c010">redundancy:</span></dt><dd class="dd-description"> In order to make up for ambiguity and reduce
misunderstandings, natural languages employ lots of
redundancy. As a result, they are often verbose. Formal languages
are less redundant and more concise.</dd><dt class="dt-description"><span class="c010">literalness:</span></dt><dd class="dd-description"> Natural languages are full of idiom and metaphor.
If I say, &#X201C;The penny dropped&#X201D;, there is probably no penny and
nothing dropping (this idiom means that someone understood something
after a period of confusion). Formal languages
mean exactly what they say.</dd></dl><p>Because we all grow up speaking natural languages, it is sometimes
hard to adjust to formal languages. The difference between formal and
natural language is like the difference between poetry and prose, but
more so: <a id="hevea_default56"></a> <a id="hevea_default57"></a></p><dl class="description"><dt class="dt-description"><span class="c010">Poetry:</span></dt><dd class="dd-description"> Words are used for their sounds as well as for
their meaning, and the whole poem together creates an effect or
emotional response. Ambiguity is not only common but often
deliberate.</dd><dt class="dt-description"><span class="c010">Prose:</span></dt><dd class="dd-description"> The literal meaning of words is more important,
and the structure contributes more meaning. Prose is more amenable to
analysis than poetry but still often ambiguous.</dd><dt class="dt-description"><span class="c010">Programs:</span></dt><dd class="dd-description"> The meaning of a computer program is unambiguous
and literal, and can be understood entirely by analysis of the
tokens and structure.</dd></dl><p>Formal languages are more dense
than natural languages, so it takes longer to read them. Also, the
structure is important, so it is not always best to read
from top to bottom, left to right. Instead, learn to parse the
program in your head, identifying the tokens and interpreting the
structure. Finally, the details matter. Small errors in
spelling and punctuation, which you can get away
with in natural languages, can make a big difference in a formal
language.</p>
<!--TOC section id="sec12" Debugging-->
<h2 class="section" id="sec12">1.7&#X2003;Debugging</h2><!--SEC END --><p>
<a id="hevea_default58"></a></p><p>Programmers make mistakes. For whimsical reasons, programming errors
are called <span class="c010">bugs</span> and the process of tracking them down is called
<span class="c010">debugging</span>.
<a id="hevea_default59"></a>
<a id="hevea_default60"></a></p><p>Programming, and especially debugging, sometimes brings out strong
emotions. If you are struggling with a difficult bug, you might
feel angry, despondent, or embarrassed.</p><p>There is evidence that people naturally respond to computers as if
they were people. When they work well, we think
of them as teammates, and when they are obstinate or rude, we
respond to them the same way we respond to rude,
obstinate people (Reeves and Nass, <span class="c009">The Media
Equation: How People Treat Computers, Television, and New Media
Like Real People and Places</span>).
<a id="hevea_default61"></a>
<a id="hevea_default62"></a></p><p>Preparing for these reactions might help you deal with them.
One approach is to think of the computer as an employee with
certain strengths, like speed and precision, and
particular weaknesses, like lack of empathy and inability
to grasp the big picture.</p><p>Your job is to be a good manager: find ways to take advantage
of the strengths and mitigate the weaknesses. And find ways
to use your emotions to engage with the problem,
without letting your reactions interfere with your ability
to work effectively.</p><p>Learning to debug can be frustrating, but it is a valuable skill
that is useful for many activities beyond programming. At the
end of each chapter there is a section, like this one,
with my suggestions for debugging. I hope they help!</p>
<!--TOC section id="sec13" Glossary-->
<h2 class="section" id="sec13">1.8&#X2003;Glossary</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c010">problem solving:</span></dt><dd class="dd-description"> The process of formulating a problem, finding
a solution, and expressing it.
<a id="hevea_default63"></a></dd><dt class="dt-description"><span class="c010">high-level language:</span></dt><dd class="dd-description"> A programming language like Python that
is designed to be easy for humans to read and write.
<a id="hevea_default64"></a></dd><dt class="dt-description"><span class="c010">low-level language:</span></dt><dd class="dd-description"> A programming language that is designed
to be easy for a computer to run; also called &#X201C;machine language&#X201D; or
&#X201C;assembly language&#X201D;.
<a id="hevea_default65"></a></dd><dt class="dt-description"><span class="c010">portability:</span></dt><dd class="dd-description"> A property of a program that can run on more
than one kind of computer.
<a id="hevea_default66"></a></dd><dt class="dt-description"><span class="c010">interpreter:</span></dt><dd class="dd-description"> A program that reads another program and executes
it
<a id="hevea_default67"></a></dd><dt class="dt-description"><span class="c010">prompt:</span></dt><dd class="dd-description"> Characters displayed by the interpreter to indicate
that it is ready to take input from the user.
<a id="hevea_default68"></a></dd><dt class="dt-description"><span class="c010">program:</span></dt><dd class="dd-description"> A set of instructions that specifies a computation.
<a id="hevea_default69"></a></dd><dt class="dt-description"><span class="c010">print statement:</span></dt><dd class="dd-description"> An instruction that causes the Python
interpreter to display a value on the screen.
<a id="hevea_default70"></a>
<a id="hevea_default71"></a></dd><dt class="dt-description"><span class="c010">operator:</span></dt><dd class="dd-description"> A special symbol that represents a simple computation like
addition, multiplication, or string concatenation.
<a id="hevea_default72"></a></dd><dt class="dt-description"><span class="c010">value:</span></dt><dd class="dd-description"> One of the basic units of data, like a number or string,
that a program manipulates.
<a id="hevea_default73"></a></dd><dt class="dt-description"><span class="c010">type:</span></dt><dd class="dd-description"> A category of values. The types we have seen so far
are integers (type <span class="c004">int</span>), floating-point numbers (type <span class="c004">float</span>), and strings (type <span class="c004">str</span>).
<a id="hevea_default74"></a></dd><dt class="dt-description"><span class="c010">integer:</span></dt><dd class="dd-description"> A type that represents whole numbers.
<a id="hevea_default75"></a></dd><dt class="dt-description"><span class="c010">floating-point:</span></dt><dd class="dd-description"> A type that represents numbers with fractional
parts.
<a id="hevea_default76"></a></dd><dt class="dt-description"><span class="c010">string:</span></dt><dd class="dd-description"> A type that represents sequences of characters.
<a id="hevea_default77"></a></dd><dt class="dt-description"><span class="c010">natural language:</span></dt><dd class="dd-description"> Any one of the languages that people speak that
evolved naturally.
<a id="hevea_default78"></a></dd><dt class="dt-description"><span class="c010">formal language:</span></dt><dd class="dd-description"> Any one of the languages that people have designed
for specific purposes, such as representing mathematical ideas or
computer programs; all programming languages are formal languages.
<a id="hevea_default79"></a></dd><dt class="dt-description"><span class="c010">token:</span></dt><dd class="dd-description"> One of the basic elements of the syntactic structure of
a program, analogous to a word in a natural language.
<a id="hevea_default80"></a></dd><dt class="dt-description"><span class="c010">syntax:</span></dt><dd class="dd-description"> The rules that govern the structure of a program.
<a id="hevea_default81"></a></dd><dt class="dt-description"><span class="c010">parse:</span></dt><dd class="dd-description"> To examine a program and analyze the syntactic structure.
<a id="hevea_default82"></a></dd><dt class="dt-description"><span class="c010">bug:</span></dt><dd class="dd-description"> An error in a program.
<a id="hevea_default83"></a></dd><dt class="dt-description"><span class="c010">debugging:</span></dt><dd class="dd-description"> The process of finding and correcting bugs.
<a id="hevea_default84"></a></dd></dl>
<!--TOC section id="sec14" Exercises-->
<h2 class="section" id="sec14">1.9&#X2003;Exercises</h2><!--SEC END --><div class="theorem"><span class="c010">Exercise&#XA0;1</span>&#X2003;<p><em>It is a good idea to read this book in front of a computer so you can
try out the examples as you go.</em></p><p><em>Whenever you are experimenting with a new feature, you should try
to make mistakes. For example, in the &#X201C;Hello, world!&#X201D; program,
what happens if you leave out one of the quotation marks? What
if you leave out both? What if you spell <span class="c004">print</span> wrong?
</em><a id="hevea_default85"></a></p><p><em>This kind of experiment helps you remember what you read; it also
helps when you are programming, because you get to know what the error
messages mean. It is better to make mistakes now and on purpose than
later and accidentally.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>In a print statement, what happens if you leave out one
of the parentheses, or both?</em></li><li class="li-enumerate"><em>If you are trying to print a string, what happens if you
leave out one of the quotation marks, or both?</em></li><li class="li-enumerate"><em>You can use a minus sign to make a negative number like
<span class="c004">-2</span>. What happens if you put a plus sign before a number?
What about <span class="c004">2++2</span>?</em></li><li class="li-enumerate"><em>In math notation, leading zeros are ok, as in <span class="c004">09</span>.
What happens if you try this in Python? What about <span class="c004">011</span>?</em></li><li class="li-enumerate"><em>What happens if you have two values with no operator
between them?</em></li></ol></div><div class="theorem"><span class="c010">Exercise&#XA0;2</span>&#X2003;<p><em>Start the Python interpreter and use it as a calculator.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>How many seconds are there in 42 minutes 42 seconds?</em></li><li class="li-enumerate"><em>How many miles are there in 10 kilometers? Hint: there are 1.61
kilometers in a mile.</em></li><li class="li-enumerate"><em>If you run a 10 kilometer race in 42 minutes 42 seconds, what is
your average pace (time per mile in minutes and seconds)? What is
your average speed in miles per hour?</em><p><a id="hevea_default86"></a>
<a id="hevea_default87"></a></p></li></ol></div>
<!--TOC chapter id="sec15" Variables, expressions and statements-->
<h1 class="chapter" id="sec15">Chapter&#XA0;2&#X2003;Variables, expressions and statements</h1><!--SEC END --><p>One of the most powerful features of a programming language is the
ability to manipulate <span class="c010">variables</span>. A variable is a name that
refers to a value.
<a id="hevea_default88"></a></p>
<!--TOC section id="sec16" Assignment statements-->
<h2 class="section" id="sec16">2.1&#X2003;Assignment statements</h2><!--SEC END --><p>
<a id="variables"></a>
<a id="hevea_default89"></a>
<a id="hevea_default90"></a></p><p>An <span class="c010">assignment statement</span> creates a new variable and gives
it a value:</p><pre class="verbatim">&gt;&gt;&gt; message = 'And now for something completely different'
&gt;&gt;&gt; n = 17
&gt;&gt;&gt; pi = 3.1415926535897932
</pre><p>
This example makes three assignments. The first assigns a string
to a new variable named <span class="c004">message</span>;
the second gives the integer <span class="c004">17</span> to <span class="c004">n</span>; the third
assigns the (approximate) value of &#X3C0; to <span class="c004">pi</span>.
<a id="hevea_default91"></a>
<a id="hevea_default92"></a></p><p>A common way to represent variables on paper is to write the name with
an arrow pointing to its value. This kind of figure is
called a <span class="c010">state diagram</span> because it shows what state each of the
variables is in (think of it as the variable&#X2019;s state of mind).
Figure&#XA0;<a href="#fig.state2">2.1</a> shows the result of the previous example.</p><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2001.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 2.1: State diagram.</td></tr>
</table></div>
<a id="fig.state2"></a>
<div class="center"><hr class="floatrule"></div></blockquote>
<!--TOC section id="sec17" Variable names-->
<h2 class="section" id="sec17">2.2&#X2003;Variable names</h2><!--SEC END --><p>
<a id="hevea_default93"></a></p><p>Programmers generally choose names for their variables that
are meaningful&#X2014;they document what the variable is used for.</p><p>Variable names can be as long as you like. They can contain
both letters and numbers, but they can&#X2019;t begin with a number.
It is legal to use uppercase letters, but it is conventional
to use only lower case for variables names.</p><p>The underscore character, <code class="verb">_</code>, can appear in a name.
It is often used in names with multiple words, such as
<code class="verb">your_name</code> or <code class="verb">airspeed_of_unladen_swallow</code>.
<a id="hevea_default94"></a></p><p>If you give a variable an illegal name, you get a syntax error:</p><pre class="verbatim">&gt;&gt;&gt; 76trombones = 'big parade'
SyntaxError: invalid syntax
&gt;&gt;&gt; more@ = 1000000
SyntaxError: invalid syntax
&gt;&gt;&gt; class = 'Advanced Theoretical Zymurgy'
SyntaxError: invalid syntax
</pre><p>
<span class="c004">76trombones</span> is illegal because it begins with a number.
<span class="c004">more@</span> is illegal because it contains an illegal character, <span class="c004">@</span>. But what&#X2019;s wrong with <span class="c004">class</span>?</p><p>It turns out that <span class="c004">class</span> is one of Python&#X2019;s <span class="c010">keywords</span>. The
interpreter uses keywords to recognize the structure of the program,
and they cannot be used as variable names.
<a id="hevea_default95"></a></p><p>Python 3 has these keywords:</p><pre class="verbatim">False      class      finally    is         return
None       continue   for        lambda     try
True       def        from       nonlocal   while
and        del        global     not        with
as         elif       if         or         yield
assert     else       import     pass
break      except     in         raise
</pre><p>
You don&#X2019;t have to memorize this list. In most development environments,
keywords are displayed in a different color; if you try to use one
as a variable name, you&#X2019;ll know.</p>
<!--TOC section id="sec18" Expressions and statements-->
<h2 class="section" id="sec18">2.3&#X2003;Expressions and statements</h2><!--SEC END --><p>An <span class="c010">expression</span> is a combination of values, variables, and operators.
A value all by itself is considered an expression, and so is
a variable, so the following are all legal expressions:
<a id="hevea_default96"></a></p><pre class="verbatim">&gt;&gt;&gt; 42
42
&gt;&gt;&gt; n
17
&gt;&gt;&gt; n + 25
42
</pre><p>
When you type an expression at the prompt, the interpreter
<span class="c010">evaluates</span> it, which means that it finds the value of
the expression.
In this example, <span class="c004">n</span> has the value 17 and
<span class="c004">n + 25</span> has the value 42.
<a id="hevea_default97"></a></p><p>A <span class="c010">statement</span> is a unit of code that has an effect, like
creating a variable or displaying a value.
<a id="hevea_default98"></a></p><pre class="verbatim">&gt;&gt;&gt; n = 17
&gt;&gt;&gt; print(n)
</pre><p>
The first line is an assignment statement that gives a value to
<span class="c004">n</span>. The second line is a print statement that displays the
value of <span class="c004">n</span>.</p><p>When you type a statement, the interpreter <span class="c010">executes</span> it,
which means that it does whatever the statement says. In general,
statements don&#X2019;t have values.
<a id="hevea_default99"></a></p>
<!--TOC section id="sec19" Script mode-->
<h2 class="section" id="sec19">2.4&#X2003;Script mode</h2><!--SEC END --><p>So far we have run Python in <span class="c010">interactive mode</span>, which
means that you interact directly with the interpreter.
Interactive mode is a good way to get started,
but if you are working with more than a few lines of code, it can be
clumsy.
<a id="hevea_default100"></a></p><p>The alternative is to save code in a file called a <span class="c010">script</span> and
then run the interpreter in <span class="c010">script mode</span> to execute the script. By
convention, Python scripts have names that end with <span class="c004">.py</span>.
<a id="hevea_default101"></a>
<a id="hevea_default102"></a></p><p>If you know how to create and run a script on your computer, you
are ready to go. Otherwise I recommend using PythonAnywhere again.
I have posted instructions for running in script mode at
<a href="http://tinyurl.com/thinkpython2e"><span class="c004">http://tinyurl.com/thinkpython2e</span></a>.</p><p>Because Python provides both modes,
you can test bits of code in interactive mode before you put them
in a script. But there are differences between interactive mode
and script mode that can be confusing.
<a id="hevea_default103"></a>
<a id="hevea_default104"></a></p><p>For example, if you are using Python as a calculator, you might type</p><pre class="verbatim">&gt;&gt;&gt; miles = 26.2
&gt;&gt;&gt; miles * 1.61
42.182
</pre><p>The first line assigns a value to <span class="c004">miles</span>, but it has no visible
effect. The second line is an expression, so the
interpreter evaluates it and displays the result. It turns out that a
marathon is about 42 kilometers.</p><p>But if you type the same code into a script and run it, you get no
output at all.
In script mode an expression, all by itself, has no
visible effect. Python evaluates the expression, but it doesn&#X2019;t
display the result.
To display the result, you need a <span class="c004">print</span> statement like this:</p><pre class="verbatim">miles = 26.2
print(miles * 1.61)
</pre><p>This behavior can be confusing at first.
To check your understanding, type the following statements in the
Python interpreter and see what they do:</p><pre class="verbatim">5
x = 5
x + 1
</pre><p>Now put the same statements in a script and run it. What
is the output? Modify the script by transforming each
expression into a print statement and then run it again.</p>
<!--TOC section id="sec20" Order of operations-->
<h2 class="section" id="sec20">2.5&#X2003;Order of operations</h2><!--SEC END --><p>
<a id="hevea_default105"></a>
<a id="hevea_default106"></a></p><p>When an expression contains more than one operator, the order of
evaluation depends on the <span class="c010">order of operations</span>. For
mathematical operators, Python follows mathematical convention.
The acronym <span class="c010">PEMDAS</span> is a useful way to
remember the rules:</p><ul class="itemize"><li class="li-itemize"><span class="c010">P</span>arentheses have the highest precedence and can be used
to force an expression to evaluate in the order you want. Since
expressions in parentheses are evaluated first, <span class="c004">2 * (3-1)</span> is 4,
and <span class="c004">(1+1)**(5-2)</span> is 8. You can also use parentheses to make an
expression easier to read, as in <span class="c004">(minute * 100) / 60</span>, even
if it doesn&#X2019;t change the result.</li><li class="li-itemize"><span class="c010">E</span>xponentiation has the next highest precedence, so
<span class="c004">1 + 2**3</span> is 9, not 27, and <span class="c004">2 * 3**2</span> is 18, not 36.</li><li class="li-itemize"><span class="c010">M</span>ultiplication and <span class="c010">D</span>ivision have higher precedence
than <span class="c010">A</span>ddition and <span class="c010">S</span>ubtraction. So <span class="c004">2*3-1</span> is 5, not
4, and <span class="c004">6+4/2</span> is 8, not 5.</li><li class="li-itemize">Operators with the same precedence are evaluated from left to
right (except exponentiation). So in the expression <span class="c004">degrees /
2 * pi</span>, the division happens first and the result is multiplied
by <span class="c004">pi</span>. To divide by 2 &#X3C0;, you can use parentheses or write
<span class="c004">degrees / 2 / pi</span>.</li></ul><p>I don&#X2019;t work very hard to remember the precedence of
operators. If I can&#X2019;t tell by looking at the expression, I use
parentheses to make it obvious.</p>
<!--TOC section id="sec21" String operations-->
<h2 class="section" id="sec21">2.6&#X2003;String operations</h2><!--SEC END --><p>
<a id="hevea_default107"></a>
<a id="hevea_default108"></a></p><p>In general, you can&#X2019;t perform mathematical operations on strings, even
if the strings look like numbers, so the following are illegal:</p><pre class="verbatim">'chinese'-'food'    'eggs'/'easy'    'third'*'a charm'
</pre><p>
But there are two exceptions, <span class="c004">+</span> and <span class="c004">*</span>.</p><p>The <span class="c004">+</span> operator performs <span class="c010">string concatenation</span>, which means
it joins the strings by linking them end-to-end. For example:
<a id="hevea_default109"></a></p><pre class="verbatim">&gt;&gt;&gt; first = 'throat'
&gt;&gt;&gt; second = 'warbler'
&gt;&gt;&gt; first + second
throatwarbler
</pre><p>
The <span class="c004">*</span> operator also works on strings; it performs repetition.
For example, <code class="verb">'Spam'*3</code> is <code class="verb">'SpamSpamSpam'</code>. If one of the
values is a string, the other has to be an integer.</p><p>This use of <span class="c004">+</span> and <span class="c004">*</span> makes sense by
analogy with addition and multiplication. Just as <span class="c004">4*3</span> is
equivalent to <span class="c004">4+4+4</span>, we expect <code class="verb">'Spam'*3</code> to be the same as
<code class="verb">'Spam'+'Spam'+'Spam'</code>, and it is. On the other hand, there is a
significant way in which string concatenation and repetition are
different from integer addition and multiplication.
Can you think of a property that addition has
that string concatenation does not?
<a id="hevea_default110"></a></p>
<!--TOC section id="sec22" Comments-->
<h2 class="section" id="sec22">2.7&#X2003;Comments</h2><!--SEC END --><p>
<a id="hevea_default111"></a></p><p>As programs get bigger and more complicated, they get more difficult
to read. Formal languages are dense, and it is often difficult to
look at a piece of code and figure out what it is doing, or why.</p><p>For this reason, it is a good idea to add notes to your programs to explain
in natural language what the program is doing. These notes are called
<span class="c010">comments</span>, and they start with the <code class="verb">#</code> symbol:</p><pre class="verbatim"># compute the percentage of the hour that has elapsed
percentage = (minute * 100) / 60
</pre><p>
In this case, the comment appears on a line by itself. You can also put
comments at the end of a line:</p><pre class="verbatim">percentage = (minute * 100) / 60     # percentage of an hour
</pre><p>
Everything from the <span class="c004">#</span> to the end of the line is ignored&#X2014;it
has no effect on the execution of the program.</p><p>Comments are most useful when they document non-obvious features of
the code. It is reasonable to assume that the reader can figure out
<em>what</em> the code does; it is more useful to explain <em>why</em>.</p><p>This comment is redundant with the code and useless:</p><pre class="verbatim">v = 5     # assign 5 to v
</pre><p>
This comment contains useful information that is not in the code:</p><pre class="verbatim">v = 5     # velocity in meters/second.
</pre><p>
Good variable names can reduce the need for comments, but
long names can make complex expressions hard to read, so there is
a tradeoff.</p>
<!--TOC section id="sec23" Debugging-->
<h2 class="section" id="sec23">2.8&#X2003;Debugging</h2><!--SEC END --><p>
<a id="hevea_default112"></a>
<a id="hevea_default113"></a></p><p>Three kinds of errors can occur in a program: syntax errors, runtime
errors, and semantic errors. It is useful
to distinguish between them in order to track them down more quickly.</p><dl class="description"><dt class="dt-description"><span class="c010">Syntax error:</span></dt><dd class="dd-description"> &#X201C;Syntax&#X201D; refers to the structure of a program
and the rules about that structure. For example, parentheses have
to come in matching pairs, so <span class="c004">(1 + 2)</span> is legal, but <span class="c004">8)</span>
is a <span class="c010">syntax error</span>. <a id="hevea_default114"></a> <a id="hevea_default115"></a>
<a id="hevea_default116"></a>
<a id="hevea_default117"></a><p>If there is a syntax error
anywhere in your program, Python displays an error message and quits,
and you will not be able to run the program. During the first few
weeks of your programming career, you might spend a lot of
time tracking down syntax errors. As you gain experience, you will
make fewer errors and find them faster.</p></dd><dt class="dt-description"><span class="c010">Runtime error:</span></dt><dd class="dd-description"> The second type of error is a runtime error, so
called because the error does not appear until after the program has
started running. These errors are also called <span class="c010">exceptions</span>
because they usually indicate that something exceptional (and bad)
has happened. <a id="hevea_default118"></a> <a id="hevea_default119"></a>
<a id="hevea_default120"></a> <a id="hevea_default121"></a> <a id="hevea_default122"></a><p>Runtime errors are rare in the simple programs you will see in the
first few chapters, so it might be a while before you encounter one.</p></dd><dt class="dt-description"><span class="c010">Semantic error:</span></dt><dd class="dd-description"> The third type of error is &#X201C;semantic&#X201D;, which
means related to meaning. If there is a semantic error in your
program, it will run without generating error messages, but it will
not do the right thing. It will do something else. Specifically,
it will do what you told it to do. <a id="hevea_default123"></a>
<a id="hevea_default124"></a> <a id="hevea_default125"></a><p>Identifying semantic errors can be tricky because it requires you to work
backward by looking at the output of the program and trying to figure
out what it is doing.</p></dd></dl>
<!--TOC section id="sec24" Glossary-->
<h2 class="section" id="sec24">2.9&#X2003;Glossary</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c010">variable:</span></dt><dd class="dd-description"> A name that refers to a value.
<a id="hevea_default126"></a></dd><dt class="dt-description"><span class="c010">assignment:</span></dt><dd class="dd-description"> A statement that assigns a value to a variable.
<a id="hevea_default127"></a></dd><dt class="dt-description"><span class="c010">state diagram:</span></dt><dd class="dd-description"> A graphical representation of a set of variables and the
values they refer to.
<a id="hevea_default128"></a></dd><dt class="dt-description"><span class="c010">keyword:</span></dt><dd class="dd-description"> A reserved word that is used to parse a
program; you cannot use keywords like <span class="c004">if</span>, <span class="c004">def</span>, and <span class="c004">while</span> as
variable names.
<a id="hevea_default129"></a></dd><dt class="dt-description"><span class="c010">operand:</span></dt><dd class="dd-description"> One of the values on which an operator operates.
<a id="hevea_default130"></a></dd><dt class="dt-description"><span class="c010">expression:</span></dt><dd class="dd-description"> A combination of variables, operators, and values that
represents a single result.
<a id="hevea_default131"></a></dd><dt class="dt-description"><span class="c010">evaluate:</span></dt><dd class="dd-description"> To simplify an expression by performing the operations
in order to yield a single value.</dd><dt class="dt-description"><span class="c010">statement:</span></dt><dd class="dd-description"> A section of code that represents a command or action. So
far, the statements we have seen are assignments and print statements.
<a id="hevea_default132"></a></dd><dt class="dt-description"><span class="c010">execute:</span></dt><dd class="dd-description"> To run a statement and do what it says.
<a id="hevea_default133"></a></dd><dt class="dt-description"><span class="c010">interactive mode:</span></dt><dd class="dd-description"> A way of using the Python interpreter by
typing code at the prompt.
<a id="hevea_default134"></a></dd><dt class="dt-description"><span class="c010">script mode:</span></dt><dd class="dd-description"> A way of using the Python interpreter to read
code from a script and run it.
<a id="hevea_default135"></a></dd><dt class="dt-description"><span class="c010">script:</span></dt><dd class="dd-description"> A program stored in a file.
<a id="hevea_default136"></a></dd><dt class="dt-description"><span class="c010">order of operations:</span></dt><dd class="dd-description"> Rules governing the order in which
expressions involving multiple operators and operands are evaluated.
<a id="hevea_default137"></a></dd><dt class="dt-description"><span class="c010">concatenate:</span></dt><dd class="dd-description"> To join two operands end-to-end.
<a id="hevea_default138"></a></dd><dt class="dt-description"><span class="c010">comment:</span></dt><dd class="dd-description"> Information in a program that is meant for other
programmers (or anyone reading the source code) and has no effect on the
execution of the program.
<a id="hevea_default139"></a></dd><dt class="dt-description"><span class="c010">syntax error:</span></dt><dd class="dd-description"> An error in a program that makes it impossible
to parse (and therefore impossible to interpret).
<a id="hevea_default140"></a></dd><dt class="dt-description"><span class="c010">exception:</span></dt><dd class="dd-description"> An error that is detected while the program is running.
<a id="hevea_default141"></a></dd><dt class="dt-description"><span class="c010">semantics:</span></dt><dd class="dd-description"> The meaning of a program.
<a id="hevea_default142"></a></dd><dt class="dt-description"><span class="c010">semantic error:</span></dt><dd class="dd-description"> An error in a program that makes it do something
other than what the programmer intended.
<a id="hevea_default143"></a></dd></dl>
<!--TOC section id="sec25" Exercises-->
<h2 class="section" id="sec25">2.10&#X2003;Exercises</h2><!--SEC END --><div class="theorem"><span class="c010">Exercise&#XA0;1</span>&#X2003;<p><em>Repeating my advice from the previous chapter, whenever you learn
a new feature, you should try it out in interactive mode and make
errors on purpose to see what goes wrong.</em></p><ul class="itemize"><li class="li-itemize"><em>We&#X2019;ve seen that <span class="c004">n = 42</span> is legal. What about <span class="c004">42 = n</span>?</em></li><li class="li-itemize"><em>How about <span class="c004">x = y = 1</span>?</em></li><li class="li-itemize"><em>In some languages every statement ends with a semi-colon, <span class="c004">;</span>.
What happens if you put a semi-colon at the end of a Python statement?</em></li><li class="li-itemize"><em>What if you put a period at the end of a statement?</em></li><li class="li-itemize"><em>In math notation you can multiply </em><span class="c009">x</span><em> and </em><span class="c009">y</span><em> like this: </em><span class="c009">x y</span><em>.
What happens if you try that in Python?</em></li></ul></div><div class="theorem"><span class="c010">Exercise&#XA0;2</span>&#X2003;<p><em>Practice using the Python interpreter as a calculator:
</em><a id="hevea_default144"></a></p><ol class="enumerate" type=1><li class="li-enumerate"><em>The volume of a sphere with radius </em><span class="c009">r</span><em> is </em>4/3 &#X3C0; <span class="c009">r</span><sup>3</sup><em>.
What is the volume of a sphere with radius 5?</em></li><li class="li-enumerate"><em>Suppose the cover price of a book is $24.95, but bookstores get a
40% discount. Shipping costs $3 for the first copy and 75 cents
for each additional copy. What is the total wholesale cost for
60 copies?</em></li><li class="li-enumerate"><em>If I leave my house at 6:52 am and run 1 mile at an easy pace
(8:15 per mile), then 3 miles at tempo (7:12 per mile) and 1 mile at
easy pace again, what time do I get home for breakfast?
</em><a id="hevea_default145"></a></li></ol></div>
<!--TOC chapter id="sec26" Functions-->
<h1 class="chapter" id="sec26">Chapter&#XA0;3&#X2003;Functions</h1><!--SEC END --><p>
<a id="funcchap"></a></p><p>In the context of programming, a <span class="c010">function</span> is a named sequence of
statements that performs a computation. When you define a function,
you specify the name and the sequence of statements. Later, you can
&#X201C;call&#X201D; the function by name.
<a id="hevea_default146"></a></p>
<!--TOC section id="sec27" Function calls-->
<h2 class="section" id="sec27">3.1&#X2003;Function calls</h2><!--SEC END --><p>
<a id="functionchap"></a>
<a id="hevea_default147"></a></p><p>We have already seen one example of a <span class="c010">function call</span>:</p><pre class="verbatim">&gt;&gt;&gt; type(42)
&lt;class 'int'&gt;
</pre><p>
The name of the function is <span class="c004">type</span>. The expression in parentheses
is called the <span class="c010">argument</span> of the function. The result, for this
function, is the type of the argument.
<a id="hevea_default148"></a></p><p>It is common to say that a function &#X201C;takes&#X201D; an argument and &#X201C;returns&#X201D;
a result. The result is also called the <span class="c010">return value</span>.
<a id="hevea_default149"></a>
<a id="hevea_default150"></a></p><p>Python provides functions that convert values
from one type to another. The <span class="c004">int</span> function takes any value and
converts it to an integer, if it can, or complains otherwise:
<a id="hevea_default151"></a>
<a id="hevea_default152"></a>
<a id="hevea_default153"></a>
<a id="hevea_default154"></a></p><pre class="verbatim">&gt;&gt;&gt; int('32')
32
&gt;&gt;&gt; int('Hello')
ValueError: invalid literal for int(): Hello
</pre><p>
<span class="c004">int</span> can convert floating-point values to integers, but it
doesn&#X2019;t round off; it chops off the fraction part:</p><pre class="verbatim">&gt;&gt;&gt; int(3.99999)
3
&gt;&gt;&gt; int(-2.3)
-2
</pre><p>
<span class="c004">float</span> converts integers and strings to floating-point
numbers:
<a id="hevea_default155"></a>
<a id="hevea_default156"></a></p><pre class="verbatim">&gt;&gt;&gt; float(32)
32.0
&gt;&gt;&gt; float('3.14159')
3.14159
</pre><p>
Finally, <span class="c004">str</span> converts its argument to a string:
<a id="hevea_default157"></a>
<a id="hevea_default158"></a></p><pre class="verbatim">&gt;&gt;&gt; str(32)
'32'
&gt;&gt;&gt; str(3.14159)
'3.14159'
</pre>
<!--TOC section id="sec28" Math functions-->
<h2 class="section" id="sec28">3.2&#X2003;Math functions</h2><!--SEC END --><p>
<a id="hevea_default159"></a>
<a id="hevea_default160"></a></p><p>Python has a math module that provides most of the familiar
mathematical functions. A <span class="c010">module</span> is a file that contains a
collection of related functions.
<a id="hevea_default161"></a>
<a id="hevea_default162"></a></p><p>Before we can use the functions in a module, we have to import it with
an <span class="c010">import statement</span>:</p><pre class="verbatim">&gt;&gt;&gt; import math
</pre><p>
This statement creates a <span class="c010">module object</span> named math. If
you display the module object, you get some information about it:</p><pre class="verbatim">&gt;&gt;&gt; math
&lt;module 'math' (built-in)&gt;
</pre><p>
The module object contains the functions and variables defined in the
module. To access one of the functions, you have to specify the name
of the module and the name of the function, separated by a dot (also
known as a period). This format is called <span class="c010">dot notation</span>.
<a id="hevea_default163"></a></p><pre class="verbatim">&gt;&gt;&gt; ratio = signal_power / noise_power
&gt;&gt;&gt; decibels = 10 * math.log10(ratio)

&gt;&gt;&gt; radians = 0.7
&gt;&gt;&gt; height = math.sin(radians)
</pre><p>
The first example uses <code class="verb">math.log10</code> to compute
a signal-to-noise ratio in decibels (assuming that <code class="verb">signal_power</code> and
<code class="verb">noise_power</code> are defined). The math module also provides <span class="c004">log</span>,
which computes logarithms base <span class="c004">e</span>.
<a id="hevea_default164"></a>
<a id="hevea_default165"></a>
<a id="hevea_default166"></a>
<a id="hevea_default167"></a>
<a id="hevea_default168"></a>
<a id="hevea_default169"></a></p><p>The second example finds the sine of <span class="c004">radians</span>. The variable name <span class="c004">radians</span> is a hint that <span class="c004">sin</span> and the other trigonometric
functions (<span class="c004">cos</span>, <span class="c004">tan</span>, etc.) take arguments in radians. To
convert from degrees to radians, divide by 180 and multiply by
&#X3C0;:</p><pre class="verbatim">&gt;&gt;&gt; degrees = 45
&gt;&gt;&gt; radians = degrees / 180.0 * math.pi
&gt;&gt;&gt; math.sin(radians)
0.707106781187
</pre><p>
The expression <span class="c004">math.pi</span> gets the variable <span class="c004">pi</span> from the math
module. Its value is a floating-point approximation
of &#X3C0;, accurate to about 15 digits.
<a id="hevea_default170"></a></p><p>If you know
trigonometry, you can check the previous result by comparing it to
the square root of two, divided by two:
<a id="hevea_default171"></a>
<a id="hevea_default172"></a></p><pre class="verbatim">&gt;&gt;&gt; math.sqrt(2) / 2.0
0.707106781187
</pre>
<!--TOC section id="sec29" Composition-->
<h2 class="section" id="sec29">3.3&#X2003;Composition</h2><!--SEC END --><p>
<a id="hevea_default173"></a></p><p>So far, we have looked at the elements of a program&#X2014;variables,
expressions, and statements&#X2014;in isolation, without talking about how to
combine them.</p><p>One of the most useful features of programming languages is their
ability to take small building blocks and <span class="c010">compose</span> them. For
example, the argument of a function can be any kind of expression,
including arithmetic operators:</p><pre class="verbatim">x = math.sin(degrees / 360.0 * 2 * math.pi)
</pre><p>
And even function calls:</p><pre class="verbatim">x = math.exp(math.log(x+1))
</pre><p>
Almost anywhere you can put a value, you can put an arbitrary
expression, with one exception: the left side of an assignment
statement has to be a variable name. Any other expression on the left
side is a syntax error (we will see exceptions to this rule
later).</p><pre class="verbatim">&gt;&gt;&gt; minutes = hours * 60                 # right
&gt;&gt;&gt; hours * 60 = minutes                 # wrong!
SyntaxError: can't assign to operator
</pre><p>
<a id="hevea_default174"></a>
<a id="hevea_default175"></a></p>
<!--TOC section id="sec30" Adding new functions-->
<h2 class="section" id="sec30">3.4&#X2003;Adding new functions</h2><!--SEC END --><p>So far, we have only been using the functions that come with Python,
but it is also possible to add new functions.
A <span class="c010">function definition</span> specifies the name of a new function and
the sequence of statements that run when the function is called.
<a id="hevea_default176"></a>
<a id="hevea_default177"></a>
<a id="hevea_default178"></a></p><p>Here is an example:</p><pre class="verbatim">def print_lyrics():
    print("I'm a lumberjack, and I'm okay.")
    print("I sleep all night and I work all day.")
</pre><p>
<span class="c004">def</span> is a keyword that indicates that this is a function
definition. The name of the function is <code class="verb">print_lyrics</code>. The
rules for function names are the same as for variable names: letters,
numbers and underscore are legal, but the first character
can&#X2019;t be a number. You can&#X2019;t use a keyword as the name of a function,
and you should avoid having a variable and a function with the same
name.
<a id="hevea_default179"></a>
<a id="hevea_default180"></a>
<a id="hevea_default181"></a></p><p>The empty parentheses after the name indicate that this function
doesn&#X2019;t take any arguments.
<a id="hevea_default182"></a>
<a id="hevea_default183"></a>
<a id="hevea_default184"></a>
<a id="hevea_default185"></a>
<a id="hevea_default186"></a></p><p>The first line of the function definition is called the <span class="c010">header</span>;
the rest is called the <span class="c010">body</span>. The header has to end with a colon
and the body has to be indented. By convention, indentation is
always four spaces. The body can contain
any number of statements.</p><p>The strings in the print statements are enclosed in double
quotes. Single quotes and double quotes do the same thing;
most people use single quotes except in cases like this where
a single quote (which is also an apostrophe) appears in the string.</p><p>All quotation marks (single and double)
must be &#X201C;straight quotes&#X201D;, usually
located next to Enter on the keyboard. &#X201C;Curly quotes&#X201D;, like
the ones in this sentence, are not legal in Python.</p><p>If you type a function definition in interactive mode, the interpreter
prints dots (<span class="c004">...</span>) to let you know that the definition
isn&#X2019;t complete:
<a id="hevea_default187"></a></p><pre class="verbatim">&gt;&gt;&gt; def print_lyrics():
...     print("I'm a lumberjack, and I'm okay.")
...     print("I sleep all night and I work all day.")
...
</pre><p>
To end the function, you have to enter an empty line.</p><p>Defining a function creates a <span class="c010">function object</span>, which
has type <code class="verb">function</code>:
<a id="hevea_default188"></a>
<a id="hevea_default189"></a></p><pre class="verbatim">&gt;&gt;&gt; print(print_lyrics)
&lt;function print_lyrics at 0xb7e99e9c&gt;
&gt;&gt;&gt; type(print_lyrics)
&lt;class 'function'&gt;
</pre><p>
The syntax for calling the new function is the same as
for built-in functions:</p><pre class="verbatim">&gt;&gt;&gt; print_lyrics()
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.
</pre><p>
Once you have defined a function, you can use it inside another
function. For example, to repeat the previous refrain, we could write
a function called <code class="verb">repeat_lyrics</code>:</p><pre class="verbatim">def repeat_lyrics():
    print_lyrics()
    print_lyrics()
</pre><p>
And then call <code class="verb">repeat_lyrics</code>:</p><pre class="verbatim">&gt;&gt;&gt; repeat_lyrics()
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.
</pre><p>
But that&#X2019;s not really how the song goes.</p>
<!--TOC section id="sec31" Definitions and uses-->
<h2 class="section" id="sec31">3.5&#X2003;Definitions and uses</h2><!--SEC END --><p>
<a id="hevea_default190"></a></p><p>Pulling together the code fragments from the previous section, the
whole program looks like this:</p><pre class="verbatim">def print_lyrics():
    print("I'm a lumberjack, and I'm okay.")
    print("I sleep all night and I work all day.")

def repeat_lyrics():
    print_lyrics()
    print_lyrics()

repeat_lyrics()
</pre><p>
This program contains two function definitions: <code class="verb">print_lyrics</code> and
<code class="verb">repeat_lyrics</code>. Function definitions get executed just like other
statements, but the effect is to create function objects. The statements
inside the function do not run until the function is called, and
the function definition generates no output.
<a id="hevea_default191"></a></p><p>As you might expect, you have to create a function before you can
run it. In other words, the function definition has to run
before the function gets called.</p><p>As an exercise, move the last line of this program
to the top, so the function call appears before the definitions. Run
the program and see what error
message you get.</p><p>Now move the function call back to the bottom
and move the definition of <code class="verb">print_lyrics</code> after the definition of
<code class="verb">repeat_lyrics</code>. What happens when you run this program?</p>
<!--TOC section id="sec32" Flow of execution-->
<h2 class="section" id="sec32">3.6&#X2003;Flow of execution</h2><!--SEC END --><p>
<a id="hevea_default192"></a></p><p>To ensure that a function is defined before its first use,
you have to know the order statements run in, which is
called the <span class="c010">flow of execution</span>.</p><p>Execution always begins at the first statement of the program.
Statements are run one at a time, in order from top to bottom.</p><p>Function definitions do not alter the flow of execution of the
program, but remember that statements inside the function don&#X2019;t
run until the function is called.</p><p>A function call is like a detour in the flow of execution. Instead of
going to the next statement, the flow jumps to the body of
the function, runs the statements there, and then comes back
to pick up where it left off.</p><p>That sounds simple enough, until you remember that one function can
call another. While in the middle of one function, the program might
have to run the statements in another function. Then, while
running that new function, the program might have to run yet
another function!</p><p>Fortunately, Python is good at keeping track of where it is, so each
time a function completes, the program picks up where it left off in
the function that called it. When it gets to the end of the program,
it terminates.</p><p>In summary, when you read a program, you
don&#X2019;t always want to read from top to bottom. Sometimes it makes
more sense if you follow the flow of execution.</p>
<!--TOC section id="sec33" Parameters and arguments-->
<h2 class="section" id="sec33">3.7&#X2003;Parameters and arguments</h2><!--SEC END --><p>
<a id="parameters"></a>
<a id="hevea_default193"></a>
<a id="hevea_default194"></a>
<a id="hevea_default195"></a>
<a id="hevea_default196"></a></p><p>Some of the functions we have seen require arguments. For
example, when you call <span class="c004">math.sin</span> you pass a number
as an argument. Some functions take more than one argument:
<span class="c004">math.pow</span> takes two, the base and the exponent.</p><p>Inside the function, the arguments are assigned to
variables called <span class="c010">parameters</span>. Here is a definition for
a function that takes an argument:
<a id="hevea_default197"></a></p><pre class="verbatim">def print_twice(bruce):
    print(bruce)
    print(bruce)
</pre><p>
This function assigns the argument to a parameter
named <span class="c004">bruce</span>. When the function is called, it prints the value of
the parameter (whatever it is) twice.</p><p>This function works with any value that can be printed.</p><pre class="verbatim">&gt;&gt;&gt; print_twice('Spam')
Spam
Spam
&gt;&gt;&gt; print_twice(42)
42
42
&gt;&gt;&gt; print_twice(math.pi)
3.14159265359
3.14159265359
</pre><p>
The same rules of composition that apply to built-in functions also
apply to programmer-defined functions, so we can use any kind of expression
as an argument for <code class="verb">print_twice</code>:
<a id="hevea_default198"></a>
<a id="hevea_default199"></a>
<a id="hevea_default200"></a></p><pre class="verbatim">&gt;&gt;&gt; print_twice('Spam '*4)
Spam Spam Spam Spam
Spam Spam Spam Spam
&gt;&gt;&gt; print_twice(math.cos(math.pi))
-1.0
-1.0
</pre><p>
The argument is evaluated before the function is called, so
in the examples the expressions <code class="verb">'Spam '*4</code> and
<span class="c004">math.cos(math.pi)</span> are only evaluated once.
<a id="hevea_default201"></a></p><p>You can also use a variable as an argument:</p><pre class="verbatim">&gt;&gt;&gt; michael = 'Eric, the half a bee.'
&gt;&gt;&gt; print_twice(michael)
Eric, the half a bee.
Eric, the half a bee.
</pre><p>
The name of the variable we pass as an argument (<span class="c004">michael</span>) has
nothing to do with the name of the parameter (<span class="c004">bruce</span>). It
doesn&#X2019;t matter what the value was called back home (in the caller);
here in <code class="verb">print_twice</code>, we call everybody <span class="c004">bruce</span>.</p>
<!--TOC section id="sec34" Variables and parameters are local-->
<h2 class="section" id="sec34">3.8&#X2003;Variables and parameters are local</h2><!--SEC END --><p>
<a id="hevea_default202"></a>
<a id="hevea_default203"></a></p><p>When you create a variable inside a function, it is <span class="c010">local</span>,
which means that it only
exists inside the function. For example:
<a id="hevea_default204"></a></p><pre class="verbatim">def cat_twice(part1, part2):
    cat = part1 + part2
    print_twice(cat)
</pre><p>
This function takes two arguments, concatenates them, and prints
the result twice. Here is an example that uses it:
<a id="hevea_default205"></a></p><pre class="verbatim">&gt;&gt;&gt; line1 = 'Bing tiddle '
&gt;&gt;&gt; line2 = 'tiddle bang.'
&gt;&gt;&gt; cat_twice(line1, line2)
Bing tiddle tiddle bang.
Bing tiddle tiddle bang.
</pre><p>
When <code class="verb">cat_twice</code> terminates, the variable <span class="c004">cat</span>
is destroyed. If we try to print it, we get an exception:
<a id="hevea_default206"></a>
<a id="hevea_default207"></a></p><pre class="verbatim">&gt;&gt;&gt; print(cat)
NameError: name 'cat' is not defined
</pre><p>
Parameters are also local.
For example, outside <code class="verb">print_twice</code>, there is no
such thing as <span class="c004">bruce</span>.
<a id="hevea_default208"></a></p>
<!--TOC section id="sec35" Stack diagrams-->
<h2 class="section" id="sec35">3.9&#X2003;Stack diagrams</h2><!--SEC END --><p>
<a id="stackdiagram"></a>
<a id="hevea_default209"></a>
<a id="hevea_default210"></a>
<a id="hevea_default211"></a></p><p>To keep track of which variables can be used where, it is sometimes
useful to draw a <span class="c010">stack diagram</span>. Like state diagrams, stack
diagrams show the value of each variable, but they also show the
function each variable belongs to.
<a id="hevea_default212"></a>
<a id="hevea_default213"></a></p><p>Each function is represented by a <span class="c010">frame</span>. A frame is a box with
the name of a function beside it and the parameters and variables of
the function inside it. The stack diagram for the previous example is
shown in Figure&#XA0;<a href="#fig.stack">3.1</a>.</p><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2002.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 3.1: Stack diagram.</td></tr>
</table></div>
<a id="fig.stack"></a>
<div class="center"><hr class="floatrule"></div></blockquote><p>The frames are arranged in a stack that indicates which function
called which, and so on. In this example, <code class="verb">print_twice</code>
was called by <code class="verb">cat_twice</code>, and <code class="verb">cat_twice</code> was called by
<code class="verb">__main__</code>, which is a special name for the topmost frame. When
you create a variable outside of any function, it belongs to
<code class="verb">__main__</code>.</p><p><a id="hevea_default214"></a></p><p>Each parameter refers to the same value as its corresponding
argument. So, <span class="c004">part1</span> has the same value as
<span class="c004">line1</span>, <span class="c004">part2</span> has the same value as <span class="c004">line2</span>,
and <span class="c004">bruce</span> has the same value as <span class="c004">cat</span>.</p><p>If an error occurs during a function call, Python prints the
name of the function, the name of the function that called
it, and the name of the function that called <em>that</em>, all the
way back to <code class="verb">__main__</code>.</p><p>For example, if you try to access <span class="c004">cat</span> from within
<code class="verb">print_twice</code>, you get a <span class="c004">NameError</span>:</p><pre class="verbatim">Traceback (innermost last):
  File "test.py", line 13, in __main__
    cat_twice(line1, line2)
  File "test.py", line 5, in cat_twice
    print_twice(cat)
  File "test.py", line 9, in print_twice
    print(cat)
NameError: name 'cat' is not defined
</pre><p>
This list of functions is called a <span class="c010">traceback</span>. It tells you what
program file the error occurred in, and what line, and what functions
were executing at the time. It also shows the line of code that
caused the error.
<a id="hevea_default215"></a></p><p>The order of the functions in the traceback is the same as the
order of the frames in the stack diagram. The function that is
currently running is at the bottom.</p>
<!--TOC section id="sec36" Fruitful functions and void functions-->
<h2 class="section" id="sec36">3.10&#X2003;Fruitful functions and void functions</h2><!--SEC END --><p>
<a id="hevea_default216"></a>
<a id="hevea_default217"></a>
<a id="hevea_default218"></a>
<a id="hevea_default219"></a></p><p>Some of the functions we have used, such as the math functions, return
results; for lack of a better name, I call them <span class="c010">fruitful
functions</span>. Other functions, like <code class="verb">print_twice</code>, perform an
action but don&#X2019;t return a value. They are called <span class="c010">void
functions</span>.</p><p>When you call a fruitful function, you almost always
want to do something with the result; for example, you might
assign it to a variable or use it as part of an expression:</p><pre class="verbatim">x = math.cos(radians)
golden = (math.sqrt(5) + 1) / 2
</pre><p>
When you call a function in interactive mode, Python displays
the result:</p><pre class="verbatim">&gt;&gt;&gt; math.sqrt(5)
2.2360679774997898
</pre><p>
But in a script, if you call a fruitful function all by itself,
the return value is lost forever!</p><pre class="verbatim">math.sqrt(5)
</pre><p>
This script computes the square root of 5, but since it doesn&#X2019;t store
or display the result, it is not very useful.
<a id="hevea_default220"></a>
<a id="hevea_default221"></a></p><p>Void functions might display something on the screen or have some
other effect, but they don&#X2019;t have a return value. If you
assign the result to a variable, you get a special value called
<span class="c004">None</span>.
<a id="hevea_default222"></a>
<a id="hevea_default223"></a></p><pre class="verbatim">&gt;&gt;&gt; result = print_twice('Bing')
Bing
Bing
&gt;&gt;&gt; print(result)
None
</pre><p>
The value <span class="c004">None</span> is not the same as the string <code class="verb">'None'</code>.
It is a special value that has its own type:</p><pre class="verbatim">&gt;&gt;&gt; type(None)
&lt;class 'NoneType'&gt;
</pre><p>
The functions we have written so far are all void. We will start
writing fruitful functions in a few chapters.
<a id="hevea_default224"></a>
<a id="hevea_default225"></a></p>
<!--TOC section id="sec37" Why functions?-->
<h2 class="section" id="sec37">3.11&#X2003;Why functions?</h2><!--SEC END --><p>
<a id="hevea_default226"></a></p><p>It may not be clear why it is worth the trouble to divide
a program into functions. There are several reasons:</p><ul class="itemize"><li class="li-itemize">Creating a new function gives you an opportunity to name a group
of statements, which makes your program easier to read and debug.</li><li class="li-itemize">Functions can make a program smaller by eliminating repetitive
code. Later, if you make a change, you only have
to make it in one place.</li><li class="li-itemize">Dividing a long program into functions allows you to debug the
parts one at a time and then assemble them into a working whole.</li><li class="li-itemize">Well-designed functions are often useful for many programs.
Once you write and debug one, you can reuse it.</li></ul>
<!--TOC section id="sec38" Debugging-->
<h2 class="section" id="sec38">3.12&#X2003;Debugging</h2><!--SEC END --><p>One of the most important skills you will acquire is debugging.
Although it can be frustrating, debugging is one of the most
intellectually rich, challenging, and interesting parts of
programming.
<a id="hevea_default227"></a>
<a id="hevea_default228"></a></p><p>In some ways debugging is like detective work. You are confronted
with clues and you have to infer the processes and events that led
to the results you see.</p><p>Debugging is also like an experimental science. Once you have an idea
about what is going wrong, you modify your program and try again. If
your hypothesis was correct, you can predict the result of the
modification, and you take a step closer to a working program. If
your hypothesis was wrong, you have to come up with a new one. As
Sherlock Holmes pointed out, &#X201C;When you have eliminated the
impossible, whatever remains, however improbable, must be the truth.&#X201D;
(A. Conan Doyle, <em>The Sign of Four</em>)
<a id="hevea_default229"></a>
<a id="hevea_default230"></a></p><p>For some people, programming and debugging are the same thing. That
is, programming is the process of gradually debugging a program until
it does what you want. The idea is that you should start with a
working program and make small modifications,
debugging them as you go.</p><p>For example, Linux is an operating system that contains millions of
lines of code, but it started out as a simple program Linus Torvalds
used to explore the Intel 80386 chip. According to Larry Greenfield,
&#X201C;One of Linus&#X2019;s earlier projects was a program that would switch
between printing AAAA and BBBB. This later evolved to Linux.&#X201D;
(<em>The Linux Users&#X2019; Guide</em> Beta Version 1).
<a id="hevea_default231"></a></p>
<!--TOC section id="sec39" Glossary-->
<h2 class="section" id="sec39">3.13&#X2003;Glossary</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c010">function:</span></dt><dd class="dd-description"> A named sequence of statements that performs some
useful operation. Functions may or may not take arguments and may or
may not produce a result.
<a id="hevea_default232"></a></dd><dt class="dt-description"><span class="c010">function definition:</span></dt><dd class="dd-description"> A statement that creates a new function,
specifying its name, parameters, and the statements it contains.
<a id="hevea_default233"></a></dd><dt class="dt-description"><span class="c010">function object:</span></dt><dd class="dd-description"> A value created by a function definition.
The name of the function is a variable that refers to a function
object.
<a id="hevea_default234"></a></dd><dt class="dt-description"><span class="c010">header:</span></dt><dd class="dd-description"> The first line of a function definition.
<a id="hevea_default235"></a></dd><dt class="dt-description"><span class="c010">body:</span></dt><dd class="dd-description"> The sequence of statements inside a function definition.
<a id="hevea_default236"></a></dd><dt class="dt-description"><span class="c010">parameter:</span></dt><dd class="dd-description"> A name used inside a function to refer to the value
passed as an argument.
<a id="hevea_default237"></a></dd><dt class="dt-description"><span class="c010">function call:</span></dt><dd class="dd-description"> A statement that runs a function. It
consists of the function name followed by an argument list in
parentheses.
<a id="hevea_default238"></a></dd><dt class="dt-description"><span class="c010">argument:</span></dt><dd class="dd-description"> A value provided to a function when the function is called.
This value is assigned to the corresponding parameter in the function.
<a id="hevea_default239"></a></dd><dt class="dt-description"><span class="c010">local variable:</span></dt><dd class="dd-description"> A variable defined inside a function. A local
variable can only be used inside its function.
<a id="hevea_default240"></a></dd><dt class="dt-description"><span class="c010">return value:</span></dt><dd class="dd-description"> The result of a function. If a function call
is used as an expression, the return value is the value of
the expression.
<a id="hevea_default241"></a></dd><dt class="dt-description"><span class="c010">fruitful function:</span></dt><dd class="dd-description"> A function that returns a value.
<a id="hevea_default242"></a></dd><dt class="dt-description"><span class="c010">void function:</span></dt><dd class="dd-description"> A function that always returns <span class="c004">None</span>.
<a id="hevea_default243"></a></dd><dt class="dt-description"><span class="c010"><span class="c004">None</span>:</span></dt><dd class="dd-description"> A special value returned by void functions.
<a id="hevea_default244"></a>
<a id="hevea_default245"></a></dd><dt class="dt-description"><span class="c010">module:</span></dt><dd class="dd-description"> A file that contains a
collection of related functions and other definitions.
<a id="hevea_default246"></a></dd><dt class="dt-description"><span class="c010">import statement:</span></dt><dd class="dd-description"> A statement that reads a module file and creates
a module object.
<a id="hevea_default247"></a>
<a id="hevea_default248"></a></dd><dt class="dt-description"><span class="c010">module object:</span></dt><dd class="dd-description"> A value created by an <span class="c004">import</span> statement
that provides access to the values defined in a module.
<a id="hevea_default249"></a></dd><dt class="dt-description"><span class="c010">dot notation:</span></dt><dd class="dd-description"> The syntax for calling a function in another
module by specifying the module name followed by a dot (period) and
the function name.
<a id="hevea_default250"></a></dd><dt class="dt-description"><span class="c010">composition:</span></dt><dd class="dd-description"> Using an expression as part of a larger expression,
or a statement as part of a larger statement.
<a id="hevea_default251"></a></dd><dt class="dt-description"><span class="c010">flow of execution:</span></dt><dd class="dd-description"> The order statements run in.
<a id="hevea_default252"></a></dd><dt class="dt-description"><span class="c010">stack diagram:</span></dt><dd class="dd-description"> A graphical representation of a stack of functions,
their variables, and the values they refer to.
<a id="hevea_default253"></a></dd><dt class="dt-description"><span class="c010">frame:</span></dt><dd class="dd-description"> A box in a stack diagram that represents a function call.
It contains the local variables and parameters of the function.
<a id="hevea_default254"></a>
<a id="hevea_default255"></a></dd><dt class="dt-description"><span class="c010">traceback:</span></dt><dd class="dd-description"> A list of the functions that are executing,
printed when an exception occurs.
<a id="hevea_default256"></a></dd></dl>
<!--TOC section id="sec40" Exercises-->
<h2 class="section" id="sec40">3.14&#X2003;Exercises</h2><!--SEC END --><div class="theorem"><span class="c010">Exercise&#XA0;1</span>&#X2003;
<a id="hevea_default257"></a>
<a id="hevea_default258"></a><p><em>Write a function named </em><code class="verb"><em>right_justify</em></code><em> that takes a string
named <span class="c004">s</span> as a parameter and prints the string with enough
leading spaces so that the last letter of the string is in column 70
of the display.</em></p><pre class="verbatim"><em>&gt;&gt;&gt; right_justify('monty')
                                                                 monty
</em></pre><p><em>Hint: Use string concatenation and repetition. Also,
Python provides a built-in function called <span class="c004">len</span> that
returns the length of a string, so the value of </em><code class="verb"><em>len('monty')</em></code><em> is 5.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;2</span>&#X2003;
<a id="hevea_default259"></a>
<a id="hevea_default260"></a><p><em>A function object is a value you can assign to a variable
or pass as an argument. For example, </em><code class="verb"><em>do_twice</em></code><em> is a function
that takes a function object as an argument and calls it twice:</em></p><pre class="verbatim"><em>def do_twice(f):
    f()
    f()
</em></pre><p><em>Here&#X2019;s an example that uses </em><code class="verb"><em>do_twice</em></code><em> to call a function
named </em><code class="verb"><em>print_spam</em></code><em> twice.</em></p><pre class="verbatim"><em>def print_spam():
    print('spam')

do_twice(print_spam)
</em></pre><ol class="enumerate" type=1><li class="li-enumerate"><em>Type this example into a script and test it.</em></li><li class="li-enumerate"><em>Modify </em><code class="verb"><em>do_twice</em></code><em> so that it takes two arguments, a
function object and a value, and calls the function twice,
passing the value as an argument.</em></li><li class="li-enumerate"><em>Copy the definition of
</em><code class="verb"><em>print_twice</em></code><em> from earlier in this chapter to your script.</em></li><li class="li-enumerate"><em>Use the modified version of </em><code class="verb"><em>do_twice</em></code><em> to call
</em><code class="verb"><em>print_twice</em></code><em> twice, passing </em><code class="verb"><em>'spam'</em></code><em> as an argument.</em></li><li class="li-enumerate"><em>Define a new function called
</em><code class="verb"><em>do_four</em></code><em> that takes a function object and a value
and calls the function four times, passing the value
as a parameter. There should be only
two statements in the body of this function, not four.</em></li></ol><p><em>Solution: </em><a href="https://thinkpython.com/code/do_four.py"><em><span class="c004">https://thinkpython.com/code/do_four.py</span></em></a><em>.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;3</span>&#X2003;<p><em>Note: This exercise should be
done using only the statements and other features we have learned so
far.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Write a function that draws a grid like the following:
</em><a id="hevea_default261"></a><pre class="verbatim"><em>+ - - - - + - - - - +
|         |         |
|         |         |
|         |         |
|         |         |
+ - - - - + - - - - +
|         |         |
|         |         |
|         |         |
|         |         |
+ - - - - + - - - - +
</em></pre><p><em>
Hint: to print more than one value on a line, you can print
a comma-separated sequence of values:</em></p><pre class="verbatim"><em>print('+', '-')
</em></pre><p><em>
By default, <span class="c004">print</span> advances to the next line, but you
can override that behavior and put a space at the end, like this:</em></p><pre class="verbatim"><em>print('+', end=' ')
print('-')
</em></pre><p><em>
The output of these statements is </em><code class="verb"><em>'+ -'</em></code><em> on the same line.
The output from the next print statement would begin on the next line.</em></p></li><li class="li-enumerate"><em>Write a function that draws a similar grid
with four rows and four columns.</em></li></ol><p><em>Solution: </em><a href="https://thinkpython.com/code/grid.py"><em><span class="c004">https://thinkpython.com/code/grid.py</span></em></a><em>.
Credit: This exercise is based on an exercise in Oualline, </em>Practical C Programming, Third Edition<em>, O&#X2019;Reilly Media, 1997.</em></p></div>
<!--TOC chapter id="sec41" Case study: interface design-->
<h1 class="chapter" id="sec41">Chapter&#XA0;4&#X2003;Case study: interface design</h1><!--SEC END --><p>
<a id="turtlechap"></a></p><p>This chapter presents a case study that demonstrates a process for
designing functions that work together.</p><p>It introduces the <span class="c004">turtle</span> module, which allows you to
create images using turtle graphics. The <span class="c004">turtle</span> module is
included in most Python installations, but if you are running Python
using PythonAnywhere, you won&#X2019;t be able to run the turtle examples (at
least you couldn&#X2019;t when I wrote this).</p><p>If you have already installed Python on your computer, you should
be able to run the examples. Otherwise, now is a good time
to install. I have posted instructions at
<a href="http://tinyurl.com/thinkpython2e"><span class="c004">http://tinyurl.com/thinkpython2e</span></a>.</p><p>Code examples from this chapter are available from
<a href="https://thinkpython.com/code/polygon.py"><span class="c004">https://thinkpython.com/code/polygon.py</span></a>.</p>
<!--TOC section id="sec42" The turtle module-->
<h2 class="section" id="sec42">4.1&#X2003;The turtle module</h2><!--SEC END --><p>
<a id="turtle"></a></p><p>To check whether you have the <span class="c004">turtle</span> module, open the Python
interpreter and type</p><pre class="verbatim">&gt;&gt;&gt; import turtle
&gt;&gt;&gt; bob = turtle.Turtle()
</pre><p>When you run this code, it should create a new window
with small arrow that represents the turtle. Close the window.</p><p>Create a file named <span class="c004">mypolygon.py</span> and type in the following
code:</p><pre class="verbatim">import turtle
bob = turtle.Turtle()
print(bob)
turtle.mainloop()
</pre><p>
The <span class="c004">turtle</span> module (with a lowercase &#X2019;t&#X2019;) provides a function
called <span class="c004">Turtle</span> (with an uppercase &#X2019;T&#X2019;) that creates a Turtle
object, which we assign to a variable named <span class="c004">bob</span>.
Printing <span class="c004">bob</span> displays something like:</p><pre class="verbatim">&lt;turtle.Turtle object at 0xb7bfbf4c&gt;
</pre><p>
This means that <span class="c004">bob</span> refers to an object with type
<span class="c004">Turtle</span>
as defined in module <span class="c004">turtle</span>.</p><p><code class="verb">mainloop</code> tells the window to wait for the user
to do something, although in this case there&#X2019;s not much for
the user to do except close the window.</p><p>Once you create a Turtle, you can call a <span class="c010">method</span> to move it
around the window. A method is similar to a function, but it
uses slightly different syntax. For example, to move the turtle
forward:</p><pre class="verbatim">bob.fd(100)
</pre><p>
The method, <span class="c004">fd</span>, is associated with the turtle
object we&#X2019;re calling <span class="c004">bob</span>.
Calling a method is like making a request: you are asking <span class="c004">bob</span>
to move forward.</p><p>The argument of <span class="c004">fd</span> is a distance in pixels, so the actual
size depends on your display.</p><p>Other methods you can call on a Turtle are <span class="c004">bk</span> to move
backward, <span class="c004">lt</span> for left turn, and <span class="c004">rt</span> right turn. The
argument for <span class="c004">lt</span> and <span class="c004">rt</span> is an angle in degrees.</p><p>Also, each Turtle is holding a pen, which is
either down or up; if the pen is down, the Turtle leaves
a trail when it moves. The methods <span class="c004">pu</span> and <span class="c004">pd</span>
stand for &#X201C;pen up&#X201D; and &#X201C;pen down&#X201D;.</p><p>To draw a right angle, add these lines to the program
(after creating <span class="c004">bob</span> and before calling <code class="verb">mainloop</code>):</p><pre class="verbatim">bob.fd(100)
bob.lt(90)
bob.fd(100)
</pre><p>
When you run this program, you should see <span class="c004">bob</span> move east and then
north, leaving two line segments behind.</p><p>Now modify the program to draw a square. Don&#X2019;t go on until
you&#X2019;ve got it working!</p>
<!--TOC section id="sec43" Simple repetition-->
<h2 class="section" id="sec43">4.2&#X2003;Simple repetition</h2><!--SEC END --><p>
<a id="repetition"></a>
<a id="hevea_default262"></a></p><p>Chances are you wrote something like this:</p><pre class="verbatim">bob.fd(100)
bob.lt(90)

bob.fd(100)
bob.lt(90)

bob.fd(100)
bob.lt(90)

bob.fd(100)
</pre><p>
We can do the same thing more concisely with a <span class="c004">for</span> statement.
Add this example to <span class="c004">mypolygon.py</span> and run it again:
<a id="hevea_default263"></a>
<a id="hevea_default264"></a>
<a id="hevea_default265"></a></p><pre class="verbatim">for i in range(4):
    print('Hello!')
</pre><p>
You should see something like this:</p><pre class="verbatim">Hello!
Hello!
Hello!
Hello!
</pre><p>
This is the simplest use of the <span class="c004">for</span> statement; we will see
more later. But that should be enough to let you rewrite your
square-drawing program. Don&#X2019;t go on until you do.</p><p>Here is a <span class="c004">for</span> statement that draws a square:</p><pre class="verbatim">for i in range(4):
    bob.fd(100)
    bob.lt(90)
</pre><p>
The syntax of a <span class="c004">for</span> statement is similar to a function
definition. It has a header that ends with a colon and an indented
body. The body can contain any number of statements.</p><p>A <span class="c004">for</span> statement is also called a <span class="c010">loop</span> because
the flow of execution runs through the body and then loops back
to the top. In this case, it runs the body four times.
<a id="hevea_default266"></a></p><p>This version is actually a little different from the previous
square-drawing code because it makes another turn after
drawing the last side of the square. The extra turn takes
more time, but it simplifies the code if we do the same thing
every time through the loop. This version also has the effect
of leaving the turtle back in the starting position, facing in
the starting direction.</p>
<!--TOC section id="sec44" Exercises-->
<h2 class="section" id="sec44">4.3&#X2003;Exercises</h2><!--SEC END --><p>The following is a series of exercises using the <span class="c004">turtle</span> module. They
are meant to be fun, but they have a point, too. While you are
working on them, think about what the point is.</p><p>The following sections have solutions to the exercises, so
don&#X2019;t look until you have finished (or at least tried).</p><ol class="enumerate" type=1><li class="li-enumerate">Write a function called <span class="c004">square</span> that takes a parameter
named <span class="c004">t</span>, which is a turtle. It should use the turtle to draw
a square.<p>Write a function call that passes <span class="c004">bob</span> as an argument to
<span class="c004">square</span>, and then run the program again.</p></li><li class="li-enumerate">Add another parameter, named <span class="c004">length</span>, to <span class="c004">square</span>.
Modify the body so length of the sides is <span class="c004">length</span>, and then
modify the function call to provide a second argument. Run the
program again. Test your program with a range of values for <span class="c004">length</span>.</li><li class="li-enumerate">Make a copy of <span class="c004">square</span> and change the name to <span class="c004">polygon</span>. Add another parameter named <span class="c004">n</span> and modify the body
so it draws an n-sided regular polygon. Hint: The exterior angles
of an n-sided regular polygon are 360/<span class="c009">n</span> degrees. <a id="hevea_default267"></a> <a id="hevea_default268"></a></li><li class="li-enumerate">Write a function called <span class="c004">circle</span> that takes a turtle,
<span class="c004">t</span>, and radius, <span class="c004">r</span>, as parameters and that draws an
approximate circle by calling <span class="c004">polygon</span> with an appropriate
length and number of sides. Test your function with a range of values
of <span class="c004">r</span>. <a id="hevea_default269"></a> <a id="hevea_default270"></a><p>Hint: figure out the circumference of the circle and make sure that
<span class="c004">length * n = circumference</span>.</p></li><li class="li-enumerate">Make a more general version of <span class="c004">circle</span> called <span class="c004">arc</span>
that takes an additional parameter <span class="c004">angle</span>, which determines
what fraction of a circle to draw. <span class="c004">angle</span> is in units of
degrees, so when <span class="c004">angle=360</span>, <span class="c004">arc</span> should draw a complete
circle.
<a id="hevea_default271"></a>
<a id="hevea_default272"></a></li></ol>
<!--TOC section id="sec45" Encapsulation-->
<h2 class="section" id="sec45">4.4&#X2003;Encapsulation</h2><!--SEC END --><p>The first exercise asks you to put your square-drawing code
into a function definition and then call the function, passing
the turtle as a parameter. Here is a solution:</p><pre class="verbatim">def square(t):
    for i in range(4):
        t.fd(100)
        t.lt(90)

square(bob)
</pre><p>
The innermost statements, <span class="c004">fd</span> and <span class="c004">lt</span> are indented twice to
show that they are inside the <span class="c004">for</span> loop, which is inside the
function definition. The next line, <span class="c004">square(bob)</span>, is flush with
the left margin, which indicates the end of both the <span class="c004">for</span> loop
and the function definition.</p><p>Inside the function, <span class="c004">t</span> refers to the same turtle <span class="c004">bob</span>, so
<span class="c004">t.lt(90)</span> has the same effect as <span class="c004">bob.lt(90)</span>. In that
case, why not
call the parameter <span class="c004">bob</span>? The idea is that <span class="c004">t</span> can be any
turtle, not just <span class="c004">bob</span>, so you could create a second turtle and
pass it as an argument to <span class="c004">square</span>:</p><pre class="verbatim">alice = turtle.Turtle()
square(alice)
</pre><p>
Wrapping a piece of code up in a function is called <span class="c010">encapsulation</span>. One of the benefits of encapsulation is that it
attaches a name to the code, which serves as a kind of documentation.
Another advantage is that if you re-use the code, it is more concise
to call a function twice than to copy and paste the body!
<a id="hevea_default273"></a></p>
<!--TOC section id="sec46" Generalization-->
<h2 class="section" id="sec46">4.5&#X2003;Generalization</h2><!--SEC END --><p>The next step is to add a <span class="c004">length</span> parameter to <span class="c004">square</span>.
Here is a solution:</p><pre class="verbatim">def square(t, length):
    for i in range(4):
        t.fd(length)
        t.lt(90)

square(bob, 100)
</pre><p>
Adding a parameter to a function is called <span class="c010">generalization</span>
because it makes the function more general: in the previous
version, the square is always the same size; in this version
it can be any size.
<a id="hevea_default274"></a></p><p>The next step is also a generalization. Instead of drawing
squares, <span class="c004">polygon</span> draws regular polygons with any number of
sides. Here is a solution:</p><pre class="verbatim">def polygon(t, n, length):
    angle = 360 / n
    for i in range(n):
        t.fd(length)
        t.lt(angle)

polygon(bob, 7, 70)
</pre><p>
This example draws a 7-sided polygon with side length 70.</p><p>If you are using Python 2, the value of <span class="c004">angle</span> might be off
because of integer division. A simple solution is to compute
<span class="c004">angle = 360.0 / n</span>. Because the numerator is a floating-point
number, the result is floating point.
<a id="hevea_default275"></a></p><p>When a function has more than a few numeric arguments, it is easy to
forget what they are, or what order they should be in. In that case
it is often a good idea to include the names of the parameters in the
argument list:</p><pre class="verbatim">polygon(bob, n=7, length=70)
</pre><p>
These are called <span class="c010">keyword arguments</span> because they include
the parameter names as &#X201C;keywords&#X201D; (not to be confused with
Python keywords like <span class="c004">while</span> and <span class="c004">def</span>).
<a id="hevea_default276"></a>
<a id="hevea_default277"></a></p><p>This syntax makes the program more readable. It is also a reminder
about how arguments and parameters work: when you call a function, the
arguments are assigned to the parameters.</p>
<!--TOC section id="sec47" Interface design-->
<h2 class="section" id="sec47">4.6&#X2003;Interface design</h2><!--SEC END --><p>The next step is to write <span class="c004">circle</span>, which takes a radius,
<span class="c004">r</span>, as a parameter. Here is a simple solution that uses
<span class="c004">polygon</span> to draw a 50-sided polygon:</p><pre class="verbatim">import math

def circle(t, r):
    circumference = 2 * math.pi * r
    n = 50
    length = circumference / n
    polygon(t, n, length)
</pre><p>
The first line computes the circumference of a circle with radius
<span class="c004">r</span> using the formula 2 &#X3C0; <span class="c009">r</span>. Since we use <span class="c004">math.pi</span>, we
have to import <span class="c004">math</span>. By convention, <span class="c004">import</span> statements
are usually at the beginning of the script.</p><p><span class="c004">n</span> is the number of line segments in our approximation of a circle,
so <span class="c004">length</span> is the length of each segment. Thus, <span class="c004">polygon</span>
draws a 50-sided polygon that approximates a circle with radius <span class="c004">r</span>.</p><p>One limitation of this solution is that <span class="c004">n</span> is a constant, which
means that for very big circles, the line segments are too long, and
for small circles, we waste time drawing very small segments. One
solution would be to generalize the function by taking <span class="c004">n</span> as
a parameter. This would give the user (whoever calls <span class="c004">circle</span>)
more control, but the interface would be less clean.
<a id="hevea_default278"></a></p><p>The <span class="c010">interface</span> of a function is a summary of how it is used: what
are the parameters? What does the function do? And what is the return
value? An interface is &#X201C;clean&#X201D; if it allows the caller to do
what they want without dealing with unnecessary details.</p><p>In this example, <span class="c004">r</span> belongs in the interface because it
specifies the circle to be drawn. <span class="c004">n</span> is less appropriate
because it pertains to the details of <em>how</em> the circle should
be rendered.</p><p>Rather than clutter up the interface, it is better
to choose an appropriate value of <span class="c004">n</span>
depending on <span class="c004">circumference</span>:</p><pre class="verbatim">def circle(t, r):
    circumference = 2 * math.pi * r
    n = int(circumference / 3) + 3
    length = circumference / n
    polygon(t, n, length)
</pre><p>
Now the number of segments is an integer near <span class="c004">circumference/3</span>,
so the length of each segment is approximately 3, which is small
enough that the circles look good, but big enough to be efficient,
and acceptable for any size circle.</p><p>Adding 3 to <span class="c004">n</span> guarantees that the polygon has at least 3 sides.</p>
<!--TOC section id="sec48" Refactoring-->
<h2 class="section" id="sec48">4.7&#X2003;Refactoring</h2><!--SEC END --><p>
<a id="refactoring"></a>
<a id="hevea_default279"></a></p><p>When I wrote <span class="c004">circle</span>, I was able to re-use <span class="c004">polygon</span>
because a many-sided polygon is a good approximation of a circle.
But <span class="c004">arc</span> is not as cooperative; we can&#X2019;t use <span class="c004">polygon</span>
or <span class="c004">circle</span> to draw an arc.</p><p>One alternative is to start with a copy
of <span class="c004">polygon</span> and transform it into <span class="c004">arc</span>. The result
might look like this:</p><pre class="verbatim">def arc(t, r, angle):
    arc_length = 2 * math.pi * r * angle / 360
    n = int(arc_length / 3) + 1
    step_length = arc_length / n
    step_angle = angle / n

    for i in range(n):
        t.fd(step_length)
        t.lt(step_angle)
</pre><p>
The second half of this function looks like <span class="c004">polygon</span>, but we
can&#X2019;t re-use <span class="c004">polygon</span> without changing the interface. We could
generalize <span class="c004">polygon</span> to take an angle as a third argument,
but then <span class="c004">polygon</span> would no longer be an appropriate name!
Instead, let&#X2019;s call the more general function <span class="c004">polyline</span>:</p><pre class="verbatim">def polyline(t, n, length, angle):
    for i in range(n):
        t.fd(length)
        t.lt(angle)
</pre><p>
Now we can rewrite <span class="c004">polygon</span> and <span class="c004">arc</span> to use <span class="c004">polyline</span>:</p><pre class="verbatim">def polygon(t, n, length):
    angle = 360.0 / n
    polyline(t, n, length, angle)

def arc(t, r, angle):
    arc_length = 2 * math.pi * r * angle / 360
    n = int(arc_length / 3) + 1
    step_length = arc_length / n
    step_angle = float(angle) / n
    polyline(t, n, step_length, step_angle)
</pre><p>
Finally, we can rewrite <span class="c004">circle</span> to use <span class="c004">arc</span>:</p><pre class="verbatim">def circle(t, r):
    arc(t, r, 360)
</pre><p>
This process&#X2014;rearranging a program to improve
interfaces and facilitate code re-use&#X2014;is called <span class="c010">refactoring</span>.
In this case, we noticed that there was similar code in <span class="c004">arc</span> and
<span class="c004">polygon</span>, so we &#X201C;factored it out&#X201D; into <span class="c004">polyline</span>.
<a id="hevea_default280"></a></p><p>If we had planned ahead, we might have written <span class="c004">polyline</span> first
and avoided refactoring, but often you don&#X2019;t know enough at the
beginning of a project to design all the interfaces. Once you start
coding, you understand the problem better. Sometimes refactoring is a
sign that you have learned something.</p>
<!--TOC section id="sec49" A development plan-->
<h2 class="section" id="sec49">4.8&#X2003;A development plan</h2><!--SEC END --><p>
<a id="hevea_default281"></a></p><p>A <span class="c010">development plan</span> is a process for writing programs. The
process we used in this case study is &#X201C;encapsulation and
generalization&#X201D;. The steps of this process are:</p><ol class="enumerate" type=1><li class="li-enumerate">Start by writing a small program with no function definitions.</li><li class="li-enumerate">Once you get the program working, identify a coherent piece of
it, encapsulate the piece in a function and give it a name.</li><li class="li-enumerate">Generalize the function by adding appropriate parameters.</li><li class="li-enumerate">Repeat steps 1&#X2013;3 until you have a set of working functions.
Copy and paste working code to avoid retyping (and re-debugging).</li><li class="li-enumerate">Look for opportunities to improve the program by refactoring.
For example, if you have similar code in several places, consider
factoring it into an appropriately general function.</li></ol><p>This process has some drawbacks&#X2014;we will see alternatives later&#X2014;but
it can be useful if you don&#X2019;t know ahead of time how to divide the
program into functions. This approach lets you design as you go
along.</p>
<!--TOC section id="sec50" docstring-->
<h2 class="section" id="sec50">4.9&#X2003;docstring</h2><!--SEC END --><p>
<a id="docstring"></a>
<a id="hevea_default282"></a></p><p>A <span class="c010">docstring</span> is a string at the beginning of a function that
explains the interface (&#X201C;doc&#X201D; is short for &#X201C;documentation&#X201D;). Here
is an example:</p><pre class="verbatim">def polyline(t, n, length, angle):
    """Draws n line segments with the given length and
    angle (in degrees) between them.  t is a turtle.
    """
    for i in range(n):
        t.fd(length)
        t.lt(angle)
</pre><p>
By convention, all docstrings are triple-quoted strings, also known
as multiline strings because the triple quotes allow the string
to span more than one line.
<a id="hevea_default283"></a>
<a id="hevea_default284"></a>
<a id="hevea_default285"></a>
<a id="hevea_default286"></a>
<a id="hevea_default287"></a></p><p>It is terse, but it contains the essential information
someone would need to use this function. It explains concisely what
the function does (without getting into the details of how it does
it). It explains what effect each parameter has on the behavior of
the function and what type each parameter should be (if it is not
obvious).</p><p>Writing this kind of documentation is an important part of interface
design. A well-designed interface should be simple to explain;
if you have a hard time explaining one of your functions,
maybe the interface could be improved.</p>
<!--TOC section id="sec51" Debugging-->
<h2 class="section" id="sec51">4.10&#X2003;Debugging</h2><!--SEC END --><p>
<a id="hevea_default288"></a>
<a id="hevea_default289"></a></p><p>An interface is like a contract between a function and a caller.
The caller agrees to provide certain parameters and the function
agrees to do certain work.</p><p>For example, <span class="c004">polyline</span> requires four arguments: <span class="c004">t</span> has to be
a Turtle; <span class="c004">n</span> has to be an
integer; <span class="c004">length</span> should be a positive number; and <span class="c004">angle</span> has to be a number, which is understood to be in degrees.</p><p>These requirements are called <span class="c010">preconditions</span> because they
are supposed to be true before the function starts executing.
Conversely, conditions at the end of the function are
<span class="c010">postconditions</span>. Postconditions include the intended
effect of the function (like drawing line segments) and any
side effects (like moving the Turtle or making other changes).
<a id="hevea_default290"></a>
<a id="hevea_default291"></a></p><p>Preconditions are the responsibility of the caller. If the caller
violates a (properly documented!) precondition and the function
doesn&#X2019;t work correctly, the bug is in the caller, not the function.</p><p>If the preconditions are satisfied and the postconditions are
not, the bug is in the function. If your pre- and postconditions
are clear, they can help with debugging.</p>
<!--TOC section id="sec52" Glossary-->
<h2 class="section" id="sec52">4.11&#X2003;Glossary</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c010">method:</span></dt><dd class="dd-description"> A function that is associated with an object and called
using dot notation.
<a id="hevea_default292"></a></dd><dt class="dt-description"><span class="c010">loop:</span></dt><dd class="dd-description"> A part of a program that can run repeatedly.
<a id="hevea_default293"></a></dd><dt class="dt-description"><span class="c010">encapsulation:</span></dt><dd class="dd-description"> The process of transforming a sequence of
statements into a function definition.
<a id="hevea_default294"></a></dd><dt class="dt-description"><span class="c010">generalization:</span></dt><dd class="dd-description"> The process of replacing something
unnecessarily specific (like a number) with something appropriately
general (like a variable or parameter).
<a id="hevea_default295"></a></dd><dt class="dt-description"><span class="c010">keyword argument:</span></dt><dd class="dd-description"> An argument that includes the name of
the parameter as a &#X201C;keyword&#X201D;.
<a id="hevea_default296"></a>
<a id="hevea_default297"></a></dd><dt class="dt-description"><span class="c010">interface:</span></dt><dd class="dd-description"> A description of how to use a function, including
the name and descriptions of the arguments and return value.
<a id="hevea_default298"></a></dd><dt class="dt-description"><span class="c010">refactoring:</span></dt><dd class="dd-description"> The process of modifying a working program to
improve function interfaces and other qualities of the code.
<a id="hevea_default299"></a></dd><dt class="dt-description"><span class="c010">development plan:</span></dt><dd class="dd-description"> A process for writing programs.
<a id="hevea_default300"></a></dd><dt class="dt-description"><span class="c010">docstring:</span></dt><dd class="dd-description"> A string that appears at the top of a function
definition to document the function&#X2019;s interface.
<a id="hevea_default301"></a></dd><dt class="dt-description"><span class="c010">precondition:</span></dt><dd class="dd-description"> A requirement that should be satisfied by
the caller before a function starts.
<a id="hevea_default302"></a></dd><dt class="dt-description"><span class="c010">postcondition:</span></dt><dd class="dd-description"> A requirement that should be satisfied by
the function before it ends.
<a id="hevea_default303"></a></dd></dl>
<!--TOC section id="sec53" Exercises-->
<h2 class="section" id="sec53">4.12&#X2003;Exercises</h2><!--SEC END --><div class="theorem"><span class="c010">Exercise&#XA0;1</span>&#X2003;<p><em>Download the code in this chapter from
</em><a href="https://thinkpython.com/code/polygon.py"><em><span class="c004">https://thinkpython.com/code/polygon.py</span></em></a><em>.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Draw a stack diagram that shows the state of the program
while executing <span class="c004">circle(bob, radius)</span>. You can do the
arithmetic by hand or add <span class="c004">print</span> statements to the code.
</em><a id="hevea_default304"></a></li><li class="li-enumerate"><em>The version of <span class="c004">arc</span> in Section&#XA0;</em><a href="#refactoring"><em>4.7</em></a><em> is not
very accurate because the linear approximation of the
circle is always outside the true circle. As a result,
the Turtle ends up a few pixels away from the correct
destination. My solution shows a way to reduce
the effect of this error. Read the code and see if it makes
sense to you. If you draw a diagram, you might see how it works.</em></li></ol></div><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2003.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 4.1: Turtle flowers.</td></tr>
</table></div>
<a id="fig.flowers"></a>
<div class="center"><hr class="floatrule"></div></blockquote><div class="theorem"><span class="c010">Exercise&#XA0;2</span>&#X2003;
<a id="hevea_default305"></a><p><em>Write an appropriately general set of functions that
can draw flowers as in Figure&#XA0;</em><a href="#fig.flowers"><em>4.1</em></a><em>.</em></p><p><em>Solution: </em><a href="https://thinkpython.com/code/flower.py"><em><span class="c004">https://thinkpython.com/code/flower.py</span></em></a><em>,
also requires </em><a href="https://thinkpython.com/code/polygon.py"><em><span class="c004">https://thinkpython.com/code/polygon.py</span></em></a><em>.</em></p></div><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2004.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 4.2: Turtle pies.</td></tr>
</table></div>
<a id="fig.pies"></a>
<div class="center"><hr class="floatrule"></div></blockquote><div class="theorem"><span class="c010">Exercise&#XA0;3</span>&#X2003;
<a id="hevea_default306"></a><p><em>Write an appropriately general set of functions that
can draw shapes as in Figure&#XA0;</em><a href="#fig.pies"><em>4.2</em></a><em>.</em></p><p><em>Solution: </em><a href="https://thinkpython.com/code/pie.py"><em><span class="c004">https://thinkpython.com/code/pie.py</span></em></a><em>.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;4</span>&#X2003;
<a id="hevea_default307"></a>
<a id="hevea_default308"></a>
<a id="hevea_default309"></a><p><em>The letters of the alphabet can be constructed from a moderate number
of basic elements, like vertical and horizontal lines and a few
curves. Design an alphabet that can be drawn with a minimal
number of basic elements and then write functions that draw the letters.</em></p><p><em>You should write one function for each letter, with names
</em><code class="verb"><em>draw_a</em></code><em>, </em><code class="verb"><em>draw_b</em></code><em>, etc., and put your functions
in a file named <span class="c004">letters.py</span>. You can download a
&#X201C;turtle typewriter&#X201D; from </em><a href="https://thinkpython.com/code/typewriter.py"><span class="c004"><em>https://thinkpython.com/code/typewriter.py</em></span></a><em>
to help you test your code.</em></p><p><em>You can get a solution from </em><a href="https://thinkpython.com/code/letters.py"><em><span class="c004">https://thinkpython.com/code/letters.py</span></em></a><em>;
it also requires
</em><a href="https://thinkpython.com/code/polygon.py"><em><span class="c004">https://thinkpython.com/code/polygon.py</span></em></a><em>.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;5</span>&#X2003;<p><em>Read about spirals at </em><a href="http://en.wikipedia.org/wiki/Spiral"><span class="c004"><em>http://en.wikipedia.org/wiki/Spiral</em></span></a><em>; then
write a program that draws an Archimedian spiral (or one of the other
kinds). Solution: </em><a href="https://thinkpython.com/code/spiral.py"><span class="c004"><em>https://thinkpython.com/code/spiral.py</em></span></a><em>.
</em><a id="hevea_default310"></a>
<a id="hevea_default311"></a></p></div>
<!--TOC chapter id="sec54" Conditionals and recursion-->
<h1 class="chapter" id="sec54">Chapter&#XA0;5&#X2003;Conditionals and recursion</h1><!--SEC END --><p>The main topic of this chapter is the <span class="c004">if</span> statement, which
executes different code depending on the state of the program.
But first I want to introduce two new operators: floor division
and modulus.</p>
<!--TOC section id="sec55" Floor division and modulus-->
<h2 class="section" id="sec55">5.1&#X2003;Floor division and modulus</h2><!--SEC END --><p>The <span class="c010">floor division</span> operator, <code class="verb">//</code>, divides
two numbers and rounds down to an integer. For example, suppose the
run time of a movie is 105 minutes. You might want to know how
long that is in hours. Conventional division
returns a floating-point number:</p><pre class="verbatim">&gt;&gt;&gt; minutes = 105
&gt;&gt;&gt; minutes / 60
1.75
</pre><p>But we don&#X2019;t normally write hours with decimal points. Floor
division returns the integer number of hours, rounding down:</p><pre class="verbatim">&gt;&gt;&gt; minutes = 105
&gt;&gt;&gt; hours = minutes // 60
&gt;&gt;&gt; hours
1
</pre><p>To get the remainder, you could subtract off one hour in minutes:</p><pre class="verbatim">&gt;&gt;&gt; remainder = minutes - hours * 60
&gt;&gt;&gt; remainder
45
</pre><p><a id="hevea_default312"></a>
<a id="hevea_default313"></a>
<a id="hevea_default314"></a>
<a id="hevea_default315"></a>
<a id="hevea_default316"></a>
<a id="hevea_default317"></a></p><p>An alternative is to use the <span class="c010">modulus operator</span>, <code class="verb">%</code>, which
divides two numbers and returns the remainder.</p><pre class="verbatim">&gt;&gt;&gt; remainder = minutes % 60
&gt;&gt;&gt; remainder
45
</pre><p>
The modulus operator is more useful than it seems. For
example, you can check whether one number is divisible by another&#X2014;if
<span class="c004">x % y</span> is zero, then <span class="c004">x</span> is divisible by <span class="c004">y</span>.
<a id="hevea_default318"></a></p><p>Also, you can extract the right-most digit
or digits from a number. For example, <span class="c004">x % 10</span> yields the
right-most digit of <span class="c004">x</span> (in base 10). Similarly <span class="c004">x % 100</span>
yields the last two digits.</p><p>If you are using Python 2, division works differently. The
division operator, <code class="verb">/</code>, performs floor division if both
operands are integers, and floating-point division if either
operand is a <span class="c004">float</span>.
<a id="hevea_default319"></a></p>
<!--TOC section id="sec56" Boolean expressions-->
<h2 class="section" id="sec56">5.2&#X2003;Boolean expressions</h2><!--SEC END --><p>
<a id="hevea_default320"></a>
<a id="hevea_default321"></a>
<a id="hevea_default322"></a>
<a id="hevea_default323"></a></p><p>A <span class="c010">boolean expression</span> is an expression that is either true
or false. The following examples use the
operator <span class="c004">==</span>, which compares two operands and produces
<span class="c004">True</span> if they are equal and <span class="c004">False</span> otherwise:</p><pre class="verbatim">&gt;&gt;&gt; 5 == 5
True
&gt;&gt;&gt; 5 == 6
False
</pre><p>
<span class="c004">True</span> and <span class="c004">False</span> are special
values that belong to the type <span class="c004">bool</span>; they are not strings:
<a id="hevea_default324"></a>
<a id="hevea_default325"></a>
<a id="hevea_default326"></a>
<a id="hevea_default327"></a>
<a id="hevea_default328"></a>
<a id="hevea_default329"></a></p><pre class="verbatim">&gt;&gt;&gt; type(True)
&lt;class 'bool'&gt;
&gt;&gt;&gt; type(False)
&lt;class 'bool'&gt;
</pre><p>
The <span class="c004">==</span> operator is one of the <span class="c010">relational operators</span>; the
others are:</p><pre class="verbatim">      x != y               # x is not equal to y
      x &gt; y                # x is greater than y
      x &lt; y                # x is less than y
      x &gt;= y               # x is greater than or equal to y
      x &lt;= y               # x is less than or equal to y
</pre><p>
Although these operations are probably familiar to you, the Python
symbols are different from the mathematical symbols. A common error
is to use a single equal sign (<span class="c004">=</span>) instead of a double equal sign
(<span class="c004">==</span>). Remember that <span class="c004">=</span> is an assignment operator and
<span class="c004">==</span> is a relational operator. There is no such thing as
<span class="c004">=&lt;</span> or <span class="c004">=&gt;</span>.
<a id="hevea_default330"></a>
<a id="hevea_default331"></a></p>
<!--TOC section id="sec57" Logical operators-->
<h2 class="section" id="sec57">5.3&#X2003;Logical operators</h2><!--SEC END --><p>
<a id="hevea_default332"></a>
<a id="hevea_default333"></a></p><p>There are three <span class="c010">logical operators</span>: <span class="c004">and</span>, <span class="c004">or</span>, and <span class="c004">not</span>. The semantics (meaning) of these operators is
similar to their meaning in English. For example,
<span class="c004">x &gt; 0 and x &lt; 10</span> is true only if <span class="c004">x</span> is greater than 0
<em>and</em> less than 10.
<a id="hevea_default334"></a>
<a id="hevea_default335"></a>
<a id="hevea_default336"></a>
<a id="hevea_default337"></a>
<a id="hevea_default338"></a>
<a id="hevea_default339"></a></p><p><span class="c004">n%2 == 0 or n%3 == 0</span> is true if <em>either or both</em> of the
conditions is true, that is, if the number is divisible by 2 <em>or</em>
3.</p><p>Finally, the <span class="c004">not</span> operator negates a boolean
expression, so <span class="c004">not (x &gt; y)</span> is true if <span class="c004">x &gt; y</span> is false,
that is, if <span class="c004">x</span> is less than or equal to <span class="c004">y</span>.</p><p>Strictly speaking, the operands of the logical operators should be
boolean expressions, but Python is not very strict.
Any nonzero number is interpreted as <span class="c004">True</span>:</p><pre class="verbatim">&gt;&gt;&gt; 42 and True
True
</pre><p>
This flexibility can be useful, but there are some subtleties to
it that might be confusing. You might want to avoid it (unless
you know what you are doing).</p>
<!--TOC section id="sec58" Conditional execution-->
<h2 class="section" id="sec58">5.4&#X2003;Conditional execution</h2><!--SEC END --><p>
<a id="conditional.execution"></a></p><p><a id="hevea_default340"></a>
<a id="hevea_default341"></a>
<a id="hevea_default342"></a>
<a id="hevea_default343"></a>
<a id="hevea_default344"></a>
In order to write useful programs, we almost always need the ability
to check conditions and change the behavior of the program
accordingly. <span class="c010">Conditional statements</span> give us this ability. The
simplest form is the <span class="c004">if</span> statement:</p><pre class="verbatim">if x &gt; 0:
    print('x is positive')
</pre><p>
The boolean expression after <span class="c004">if</span> is
called the <span class="c010">condition</span>. If it is true, the indented
statement runs. If not, nothing happens.
<a id="hevea_default345"></a>
<a id="hevea_default346"></a>
<a id="hevea_default347"></a></p><p><span class="c004">if</span> statements have the same structure as function definitions:
a header followed by an indented body. Statements like this are
called <span class="c010">compound statements</span>.</p><p>There is no limit on the number of statements that can appear in
the body, but there has to be at least one.
Occasionally, it is useful to have a body with no statements (usually
as a place keeper for code you haven&#X2019;t written yet). In that
case, you can use the <span class="c004">pass</span> statement, which does nothing.
<a id="hevea_default348"></a>
<a id="hevea_default349"></a></p><pre class="verbatim">if x &lt; 0:
    pass          # TODO: need to handle negative values!
</pre>
<!--TOC section id="sec59" Alternative execution-->
<h2 class="section" id="sec59">5.5&#X2003;Alternative execution</h2><!--SEC END --><p>
<a id="alternative.execution"></a>
<a id="hevea_default350"></a>
<a id="hevea_default351"></a>
<a id="hevea_default352"></a></p><p>A second form of the <span class="c004">if</span> statement is &#X201C;alternative execution&#X201D;,
in which there are two possibilities and the condition determines
which one runs. The syntax looks like this:</p><pre class="verbatim">if x % 2 == 0:
    print('x is even')
else:
    print('x is odd')
</pre><p>
If the remainder when <span class="c004">x</span> is divided by 2 is 0, then we know that
<span class="c004">x</span> is even, and the program displays an appropriate message. If
the condition is false, the second set of statements runs.
Since the condition must be true or false, exactly one of the
alternatives will run. The alternatives are called <span class="c010">branches</span>, because they are branches in the flow of execution.
<a id="hevea_default353"></a></p>
<!--TOC section id="sec60" Chained conditionals-->
<h2 class="section" id="sec60">5.6&#X2003;Chained conditionals</h2><!--SEC END --><p>
<a id="hevea_default354"></a>
<a id="hevea_default355"></a></p><p>Sometimes there are more than two possibilities and we need more than
two branches. One way to express a computation like that is a <span class="c010">chained conditional</span>:</p><pre class="verbatim">if x &lt; y:
    print('x is less than y')
elif x &gt; y:
    print('x is greater than y')
else:
    print('x and y are equal')
</pre><p>
<span class="c004">elif</span> is an abbreviation of &#X201C;else if&#X201D;. Again, exactly one
branch will run. There is no limit on the number of <span class="c004">elif</span> statements. If there is an <span class="c004">else</span> clause, it has to be
at the end, but there doesn&#X2019;t have to be one.
<a id="hevea_default356"></a>
<a id="hevea_default357"></a></p><pre class="verbatim">if choice == 'a':
    draw_a()
elif choice == 'b':
    draw_b()
elif choice == 'c':
    draw_c()
</pre><p>
Each condition is checked in order. If the first is false,
the next is checked, and so on. If one of them is
true, the corresponding branch runs and the statement
ends. Even if more than one condition is true, only the
first true branch runs.</p>
<!--TOC section id="sec61" Nested conditionals-->
<h2 class="section" id="sec61">5.7&#X2003;Nested conditionals</h2><!--SEC END --><p>
<a id="hevea_default358"></a>
<a id="hevea_default359"></a></p><p>One conditional can also be nested within another. We could have
written the example in the previous section like this:</p><pre class="verbatim">if x == y:
    print('x and y are equal')
else:
    if x &lt; y:
        print('x is less than y')
    else:
        print('x is greater than y')
</pre><p>
The outer conditional contains two branches. The
first branch contains a simple statement. The second branch
contains another <span class="c004">if</span> statement, which has two branches of its
own. Those two branches are both simple statements,
although they could have been conditional statements as well.</p><p>Although the indentation of the statements makes the structure
apparent, <span class="c010">nested conditionals</span> become difficult to read very
quickly. It is a good idea to avoid them when you can.</p><p>Logical operators often provide a way to simplify nested conditional
statements. For example, we can rewrite the following code using a
single conditional:</p><pre class="verbatim">if 0 &lt; x:
    if x &lt; 10:
        print('x is a positive single-digit number.')
</pre><p>
The <span class="c004">print</span> statement runs only if we make it past both
conditionals, so we can get the same effect with the <span class="c004">and</span> operator:</p><pre class="verbatim">if 0 &lt; x and x &lt; 10:
    print('x is a positive single-digit number.')
</pre><p>For this kind of condition, Python provides a more concise option:</p><pre class="verbatim">if 0 &lt; x &lt; 10:
    print('x is a positive single-digit number.')
</pre>
<!--TOC section id="sec62" Recursion-->
<h2 class="section" id="sec62">5.8&#X2003;Recursion</h2><!--SEC END --><p>
<a id="recursion"></a>
<a id="hevea_default360"></a></p><p>It is legal for one function to call another;
it is also legal for a function to call itself. It may not be obvious
why that is a good thing, but it turns out to be one of the most
magical things a program can do.
For example, look at the following function:</p><pre class="verbatim">def countdown(n):
    if n &lt;= 0:
        print('Blastoff!')
    else:
        print(n)
        countdown(n-1)
</pre><p>
If <span class="c004">n</span> is 0 or negative, it outputs the word, &#X201C;Blastoff!&#X201D;
Otherwise, it outputs <span class="c004">n</span> and then calls a function named <span class="c004">countdown</span>&#X2014;itself&#X2014;passing <span class="c004">n-1</span> as an argument.</p><p>What happens if we call this function like this?</p><pre class="verbatim">&gt;&gt;&gt; countdown(3)
</pre><p>
The execution of <span class="c004">countdown</span> begins with <span class="c004">n=3</span>, and since
<span class="c004">n</span> is greater than 0, it outputs the value 3, and then calls itself...</p><blockquote class="quote">
The execution of <span class="c004">countdown</span> begins with <span class="c004">n=2</span>, and since
<span class="c004">n</span> is greater than 0, it outputs the value 2, and then calls itself...<blockquote class="quote">
The execution of <span class="c004">countdown</span> begins with <span class="c004">n=1</span>, and since
<span class="c004">n</span> is greater than 0, it outputs the value 1, and then calls itself...<blockquote class="quote">
The execution of <span class="c004">countdown</span> begins with <span class="c004">n=0</span>, and since <span class="c004">n</span> is not greater than 0, it outputs the word, &#X201C;Blastoff!&#X201D; and then
returns.
</blockquote><p>The <span class="c004">countdown</span> that got <span class="c004">n=1</span> returns.
</p></blockquote><p>The <span class="c004">countdown</span> that got <span class="c004">n=2</span> returns.
</p></blockquote><p>The <span class="c004">countdown</span> that got <span class="c004">n=3</span> returns.</p><p>And then you&#X2019;re back in <code class="verb">__main__</code>. So, the
total output looks like this:
<a id="hevea_default361"></a></p><pre class="verbatim">3
2
1
Blastoff!
</pre><p>
A function that calls itself is <span class="c010">recursive</span>; the process of
executing it is called <span class="c010">recursion</span>.
<a id="hevea_default362"></a>
<a id="hevea_default363"></a></p><p>As another example, we can write a function that prints a
string <span class="c004">n</span> times.</p><pre class="verbatim">def print_n(s, n):
    if n &lt;= 0:
        return
    print(s)
    print_n(s, n-1)
</pre><p>
If <span class="c004">n &lt;= 0</span> the <span class="c010">return statement</span> exits the function. The
flow of execution immediately returns to the caller, and the remaining
lines of the function don&#X2019;t run.
<a id="hevea_default364"></a>
<a id="hevea_default365"></a></p><p>The rest of the function is similar to <span class="c004">countdown</span>: it displays
<span class="c004">s</span> and then calls itself to display <span class="c004">s</span> <span class="c009">n</span>&#X2212;1 additional
times. So the number of lines of output is <span class="c004">1 + (n - 1)</span>, which
adds up to <span class="c004">n</span>.</p><p>For simple examples like this, it is probably easier to use a <span class="c004">for</span> loop. But we will see examples later that are hard to write
with a <span class="c004">for</span> loop and easy to write with recursion, so it is
good to start early.
<a id="hevea_default366"></a>
<a id="hevea_default367"></a></p>
<!--TOC section id="sec63" Stack diagrams for recursive functions-->
<h2 class="section" id="sec63">5.9&#X2003;Stack diagrams for recursive functions</h2><!--SEC END --><p>
<a id="recursive.stack"></a>
<a id="hevea_default368"></a>
<a id="hevea_default369"></a>
<a id="hevea_default370"></a></p><p>In Section&#XA0;<a href="#stackdiagram">3.9</a>, we used a stack diagram to represent
the state of a program during a function call. The same kind of
diagram can help interpret a recursive function.</p><p>Every time a function gets called, Python creates a
frame to contain the function&#X2019;s local variables and parameters.
For a recursive function, there might be more than one frame on the
stack at the same time.</p><p>Figure&#XA0;<a href="#fig.stack2">5.1</a> shows a stack diagram for <span class="c004">countdown</span> called with
<span class="c004">n = 3</span>.</p><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2005.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 5.1: Stack diagram.</td></tr>
</table></div>
<a id="fig.stack2"></a>
<div class="center"><hr class="floatrule"></div></blockquote><p>As usual, the top of the stack is the frame for <code class="verb">__main__</code>.
It is empty because we did not create any variables in
<code class="verb">__main__</code> or pass any arguments to it.
<a id="hevea_default371"></a>
<a id="hevea_default372"></a></p><p>The four <span class="c004">countdown</span> frames have different values for the
parameter <span class="c004">n</span>. The bottom of the stack, where <span class="c004">n=0</span>, is
called the <span class="c010">base case</span>. It does not make a recursive call, so
there are no more frames.</p><p>As an exercise, draw a stack diagram for <code class="verb">print_n</code> called with
<code class="verb">s = 'Hello'</code> and <span class="c004">n=2</span>.
Then write a function called <code class="verb">do_n</code> that takes a function
object and a number, <span class="c004">n</span>, as arguments, and that calls
the given function <span class="c004">n</span> times.</p>
<!--TOC section id="sec64" Infinite recursion-->
<h2 class="section" id="sec64">5.10&#X2003;Infinite recursion</h2><!--SEC END --><p>
<a id="hevea_default373"></a>
<a id="hevea_default374"></a>
<a id="hevea_default375"></a>
<a id="hevea_default376"></a>
<a id="hevea_default377"></a></p><p>If a recursion never reaches a base case, it goes on making
recursive calls forever, and the program never terminates. This is
known as <span class="c010">infinite recursion</span>, and it is generally not
a good idea. Here is a minimal program with an infinite recursion:</p><pre class="verbatim">def recurse():
    recurse()
</pre><p>
In most programming environments, a program with infinite recursion
does not really run forever. Python reports an error
message when the maximum recursion depth is reached:
<a id="hevea_default378"></a>
<a id="hevea_default379"></a></p><pre class="verbatim">  File "&lt;stdin&gt;", line 2, in recurse
  File "&lt;stdin&gt;", line 2, in recurse
  File "&lt;stdin&gt;", line 2, in recurse
                  .
                  .
                  .
  File "&lt;stdin&gt;", line 2, in recurse
RuntimeError: Maximum recursion depth exceeded
</pre><p>
This traceback is a little bigger than the one we saw in the
previous chapter. When the error occurs, there are 1000
<span class="c004">recurse</span> frames on the stack!</p><p>If you encounter an infinite recursion by accident, review
your function to confirm that there is a base case that does not
make a recursive call. And if there is a base case, check whether
you are guaranteed to reach it.</p>
<!--TOC section id="sec65" Keyboard input-->
<h2 class="section" id="sec65">5.11&#X2003;Keyboard input</h2><!--SEC END --><p>
<a id="hevea_default380"></a></p><p>The programs we have written so far accept no input from the user.
They just do the same thing every time.</p><p>Python provides a built-in function called <span class="c004">input</span> that
stops the program and
waits for the user to type something. When the user presses <span class="c006">Return</span> or <span class="c006">Enter</span>, the program resumes and <code class="verb">input</code>
returns what the user typed as a string. In Python 2, the same
function is called <code class="verb">raw_input</code>.
<a id="hevea_default381"></a>
<a id="hevea_default382"></a>
<a id="hevea_default383"></a></p><pre class="verbatim">&gt;&gt;&gt; text = input()
What are you waiting for?
&gt;&gt;&gt; text
'What are you waiting for?'
</pre><p>
Before getting input from the user, it is a good idea to print a
prompt telling the user what to type. <code class="verb">input</code> can take a
prompt as an argument:
<a id="hevea_default384"></a></p><pre class="verbatim">&gt;&gt;&gt; name = input('What...is your name?\n')
What...is your name?
Arthur, King of the Britons!
&gt;&gt;&gt; name
'Arthur, King of the Britons!'
</pre><p>
The sequence <code class="verb">\n</code> at the end of the prompt represents a <span class="c010">newline</span>, which is a special character that causes a line break.
That&#X2019;s why the user&#X2019;s input appears below the prompt. <a id="hevea_default385"></a></p><p>If you expect the user to type an integer, you can try to convert
the return value to <span class="c004">int</span>:</p><pre class="verbatim">&gt;&gt;&gt; prompt = 'What...is the airspeed velocity of an unladen swallow?\n'
&gt;&gt;&gt; speed = input(prompt)
What...is the airspeed velocity of an unladen swallow?
42
&gt;&gt;&gt; int(speed)
42
</pre><p>
But if the user types something other than a string of digits,
you get an error:</p><pre class="verbatim">&gt;&gt;&gt; speed = input(prompt)
What...is the airspeed velocity of an unladen swallow?
What do you mean, an African or a European swallow?
&gt;&gt;&gt; int(speed)
ValueError: invalid literal for int() with base 10
</pre><p>
We will see how to handle this kind of error later.
<a id="hevea_default386"></a>
<a id="hevea_default387"></a></p>
<!--TOC section id="sec66" Debugging-->
<h2 class="section" id="sec66">5.12&#X2003;Debugging</h2><!--SEC END --><p>
<a id="whitespace"></a>
<a id="hevea_default388"></a>
<a id="hevea_default389"></a></p><p>When a syntax or runtime error occurs, the error message contains
a lot of information, but it can be overwhelming. The most
useful parts are usually:</p><ul class="itemize"><li class="li-itemize">What kind of error it was, and</li><li class="li-itemize">Where it occurred.</li></ul><p>Syntax errors are usually easy to find, but there are a few
gotchas. Whitespace errors can be tricky because spaces and
tabs are invisible and we are used to ignoring them.
<a id="hevea_default390"></a></p><pre class="verbatim">&gt;&gt;&gt; x = 5
&gt;&gt;&gt;  y = 6
  File "&lt;stdin&gt;", line 1
    y = 6
    ^
IndentationError: unexpected indent
</pre><p>
In this example, the problem is that the second line is indented by
one space. But the error message points to <span class="c004">y</span>, which is
misleading. In general, error messages indicate where the problem was
discovered, but the actual error might be earlier in the code,
sometimes on a previous line.
<a id="hevea_default391"></a>
<a id="hevea_default392"></a></p><p>The same is true of runtime errors. Suppose you are trying
to compute a signal-to-noise ratio in decibels. The formula
is <span class="c009">SNR</span><sub><span class="c009">db</span></sub> = 10 log<sub>10</sub> (<span class="c009">P</span><sub><span class="c009">signal</span></sub> / <span class="c009">P</span><sub><span class="c009">noise</span></sub>). In Python,
you might write something like this:</p><pre class="verbatim">import math
signal_power = 9
noise_power = 10
ratio = signal_power // noise_power
decibels = 10 * math.log10(ratio)
print(decibels)
</pre><p>
When you run this program, you get an exception:
<a id="hevea_default393"></a>
<a id="hevea_default394"></a></p><pre class="verbatim">Traceback (most recent call last):
  File "snr.py", line 5, in ?
    decibels = 10 * math.log10(ratio)
ValueError: math domain error
</pre><p>
The error message indicates line 5, but there is nothing
wrong with that line. To find the real error, it might be
useful to print the value of <span class="c004">ratio</span>, which turns out to
be 0. The problem is in line 4, which uses floor division
instead of floating-point division.
<a id="hevea_default395"></a>
<a id="hevea_default396"></a></p><p>You should take the time to read error messages carefully, but don&#X2019;t
assume that everything they say is correct.</p>
<!--TOC section id="sec67" Glossary-->
<h2 class="section" id="sec67">5.13&#X2003;Glossary</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c010">floor division:</span></dt><dd class="dd-description"> An operator, denoted <span class="c004">//</span>, that divides two
numbers and rounds down (toward negative infinity) to an integer.
<a id="hevea_default397"></a>
<a id="hevea_default398"></a></dd><dt class="dt-description"><span class="c010">modulus operator:</span></dt><dd class="dd-description"> An operator, denoted with a percent sign
(<span class="c004">%</span>), that works on integers and returns the remainder when one
number is divided by another.
<a id="hevea_default399"></a>
<a id="hevea_default400"></a></dd><dt class="dt-description"><span class="c010">boolean expression:</span></dt><dd class="dd-description"> An expression whose value is either
<span class="c004">True</span> or <span class="c004">False</span>.
<a id="hevea_default401"></a>
<a id="hevea_default402"></a></dd><dt class="dt-description"><span class="c010">relational operator:</span></dt><dd class="dd-description"> One of the operators that compares
its operands: <span class="c004">==</span>, <span class="c004">!=</span>, <span class="c004">&gt;</span>, <span class="c004">&lt;</span>, <span class="c004">&gt;=</span>, and <span class="c004">&lt;=</span>.</dd><dt class="dt-description"><span class="c010">logical operator:</span></dt><dd class="dd-description"> One of the operators that combines boolean
expressions: <span class="c004">and</span>, <span class="c004">or</span>, and <span class="c004">not</span>.</dd><dt class="dt-description"><span class="c010">conditional statement:</span></dt><dd class="dd-description"> A statement that controls the flow of
execution depending on some condition.
<a id="hevea_default403"></a>
<a id="hevea_default404"></a></dd><dt class="dt-description"><span class="c010">condition:</span></dt><dd class="dd-description"> The boolean expression in a conditional statement
that determines which branch runs.
<a id="hevea_default405"></a></dd><dt class="dt-description"><span class="c010">compound statement:</span></dt><dd class="dd-description"> A statement that consists of a header
and a body. The header ends with a colon (:). The body is indented
relative to the header.
<a id="hevea_default406"></a></dd><dt class="dt-description"><span class="c010">branch:</span></dt><dd class="dd-description"> One of the alternative sequences of statements in
a conditional statement.
<a id="hevea_default407"></a></dd><dt class="dt-description"><span class="c010">chained conditional:</span></dt><dd class="dd-description"> A conditional statement with a series
of alternative branches.
<a id="hevea_default408"></a>
<a id="hevea_default409"></a></dd><dt class="dt-description"><span class="c010">nested conditional:</span></dt><dd class="dd-description"> A conditional statement that appears
in one of the branches of another conditional statement.
<a id="hevea_default410"></a>
<a id="hevea_default411"></a></dd><dt class="dt-description"><span class="c010">return statement:</span></dt><dd class="dd-description"> A statement that causes a function to
end immediately and return to the caller.</dd><dt class="dt-description"><span class="c010">recursion:</span></dt><dd class="dd-description"> The process of calling the function that is
currently executing.
<a id="hevea_default412"></a></dd><dt class="dt-description"><span class="c010">base case:</span></dt><dd class="dd-description"> A conditional branch in a
recursive function that does not make a recursive call.
<a id="hevea_default413"></a></dd><dt class="dt-description"><span class="c010">infinite recursion:</span></dt><dd class="dd-description"> A recursion that doesn&#X2019;t have a
base case, or never reaches it. Eventually, an infinite recursion
causes a runtime error.
<a id="hevea_default414"></a></dd></dl>
<!--TOC section id="sec68" Exercises-->
<h2 class="section" id="sec68">5.14&#X2003;Exercises</h2><!--SEC END --><div class="theorem"><span class="c010">Exercise&#XA0;1</span>&#X2003;<p><em>The <span class="c004">time</span> module provides a function, also named <span class="c004">time</span>, that
returns the current Greenwich Mean Time in &#X201C;the epoch&#X201D;, which is
an arbitrary time used as a reference point. On UNIX systems, the
epoch is 1 January 1970.</em></p><pre class="verbatim"><em>&gt;&gt;&gt; import time
&gt;&gt;&gt; time.time()
1437746094.5735958
</em></pre><p><em>Write a script that reads the current time and converts it to
a time of day in hours, minutes, and seconds, plus the number of
days since the epoch.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;2</span>&#X2003;
<a id="hevea_default415"></a><p><em>Fermat&#X2019;s Last Theorem says that there are no positive integers
</em><span class="c009">a</span><em>, </em><span class="c009">b</span><em>, and </em><span class="c009">c</span><em> such that</em></p><table class="display dcenter"><tr class="c017"><td class="dcell"><span class="c009">a</span><sup><span class="c009">n</span></sup>&#X2004;+&#X2004;<span class="c009">b</span><sup><span class="c009">n</span></sup>&#X2004;=&#X2004;<span class="c009">c</span><sup><span class="c009">n</span></sup>&#X2004;</td></tr>
</table><p><em>
for any values of </em><span class="c009">n</span><em> greater than 2.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Write a function named </em><code class="verb"><em>check_fermat</em></code><em> that takes four
parameters&#X2014;<span class="c004">a</span>, <span class="c004">b</span>, <span class="c004">c</span> and <span class="c004">n</span>&#X2014;and
checks to see if Fermat&#X2019;s theorem holds. If
</em><span class="c009">n</span><em> is greater than 2 and</em><table class="display dcenter"><tr class="c017"><td class="dcell"><span class="c009"><em>a</em></span><sup><span class="c009"><em>n</em></span></sup><em>&#X2004;+&#X2004;<span class="c009">b</span></em><sup><span class="c009"><em>n</em></span></sup><em>&#X2004;=&#X2004;<span class="c009">c</span></em><sup><span class="c009"><em>n</em></span></sup><em>&#X2004;</em></td></tr>
</table><p><em>
the program should print, &#X201C;Holy smokes, Fermat was wrong!&#X201D;
Otherwise the program should print, &#X201C;No, that doesn&#X2019;t work.&#X201D;</em></p></li><li class="li-enumerate"><em>Write a function that prompts the user to input values
for <span class="c004">a</span>, <span class="c004">b</span>, <span class="c004">c</span> and <span class="c004">n</span>, converts them to
integers, and uses </em><code class="verb"><em>check_fermat</em></code><em> to check whether they
violate Fermat&#X2019;s theorem.</em></li></ol></div><div class="theorem"><span class="c010">Exercise&#XA0;3</span>&#X2003;
<a id="hevea_default416"></a><p><em>If you are given three sticks, you may or may not be able to arrange
them in a triangle. For example, if one of the sticks is 12 inches
long and the other two are one inch long, you will
not be able to get the short sticks to meet in the middle. For any
three lengths, there is a simple test to see if it is possible to form
a triangle:</em></p><blockquote class="quotation"><em>
If any of the three lengths is greater than the sum of the other
two, then you cannot form a triangle. Otherwise, you
can. (If the sum of two lengths equals the third, they form
what is called a &#X201C;degenerate&#X201D; triangle.)
</em></blockquote><ol class="enumerate" type=1><li class="li-enumerate"><em>Write a function named </em><code class="verb"><em>is_triangle</em></code><em> that takes three
integers as arguments, and that prints either &#X201C;Yes&#X201D; or &#X201C;No&#X201D;, depending
on whether you can or cannot form a triangle from sticks with the
given lengths.</em></li><li class="li-enumerate"><em>Write a function that prompts the user to input three stick
lengths, converts them to integers, and uses </em><code class="verb"><em>is_triangle</em></code><em> to
check whether sticks with the given lengths can form a triangle.</em></li></ol></div><div class="theorem"><span class="c010">Exercise&#XA0;4</span>&#X2003;<em>
What is the output of the following program?
Draw a stack diagram that shows the state of the program
when it prints the result.</em><pre class="verbatim"><em>def recurse(n, s):
    if n == 0:
        print(s)
    else:
        recurse(n-1, n+s)

recurse(3, 0)
</em></pre><ol class="enumerate" type=1><li class="li-enumerate"><em>What would happen if you called this function like this: <span class="c004">recurse(-1, 0)</span>?</em></li><li class="li-enumerate"><em>Write a docstring that explains everything someone would need to
know in order to use this function (and nothing else).</em></li></ol></div><p>The following exercises use the <span class="c004">turtle</span> module, described in
Chapter&#XA0;<a href="#turtlechap">4</a>:
<a id="hevea_default417"></a></p><div class="theorem"><span class="c010">Exercise&#XA0;5</span>&#X2003;<p><em>Read the following function and see if you can figure out
what it does (see the examples in Chapter&#XA0;</em><a href="#turtlechap"><em>4</em></a><em>). Then run it
and see if you got it right.</em></p><pre class="verbatim"><em>def draw(t, length, n):
    if n == 0:
        return
    angle = 50
    t.fd(length*n)
    t.lt(angle)
    draw(t, length, n-1)
    t.rt(2*angle)
    draw(t, length, n-1)
    t.lt(angle)
    t.bk(length*n)
</em></pre></div><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2006.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 5.2: A Koch curve.</td></tr>
</table></div>
<a id="fig.koch"></a>
<div class="center"><hr class="floatrule"></div></blockquote><div class="theorem"><span class="c010">Exercise&#XA0;6</span>&#X2003;
<a id="hevea_default418"></a><p><em>The Koch curve is a fractal that looks something like
Figure&#XA0;</em><a href="#fig.koch"><em>5.2</em></a><em>. To draw a Koch curve with length </em><span class="c009">x</span><em>, all you
have to do is</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Draw a Koch curve with length </em><span class="c009">x</span>/3<em>.</em></li><li class="li-enumerate"><em>Turn left 60 degrees.</em></li><li class="li-enumerate"><em>Draw a Koch curve with length </em><span class="c009">x</span>/3<em>.</em></li><li class="li-enumerate"><em>Turn right 120 degrees.</em></li><li class="li-enumerate"><em>Draw a Koch curve with length </em><span class="c009">x</span>/3<em>.</em></li><li class="li-enumerate"><em>Turn left 60 degrees.</em></li><li class="li-enumerate"><em>Draw a Koch curve with length </em><span class="c009">x</span>/3<em>.</em></li></ol><p><em>The exception is if </em><span class="c009">x</span><em> is less than 3: in that case,
you can just draw a straight line with length </em><span class="c009">x</span><em>.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Write a function called <span class="c004">koch</span> that takes a turtle and
a length as parameters, and that uses the turtle to draw a Koch
curve with the given length.</em></li><li class="li-enumerate"><em>Write a function called <span class="c004">snowflake</span> that draws three
Koch curves to make the outline of a snowflake.</em><p><em>Solution: </em><a href="https://thinkpython.com/code/koch.py"><em><span class="c004">https://thinkpython.com/code/koch.py</span></em></a><em>.</em></p></li><li class="li-enumerate"><em>The Koch curve can be generalized in several ways. See
</em><a href="http://en.wikipedia.org/wiki/Koch_snowflake"><em><span class="c004">http://en.wikipedia.org/wiki/Koch_snowflake</span></em></a><em> for examples and
implement your favorite.</em></li></ol></div>
<!--TOC chapter id="sec69" Fruitful functions-->
<h1 class="chapter" id="sec69">Chapter&#XA0;6&#X2003;Fruitful functions</h1><!--SEC END --><p>
<a id="fruitchap"></a></p><p>Many of the Python functions we have used, such as the math
functions, produce return values. But the functions we&#X2019;ve written
are all void: they have an effect, like printing a value
or moving a turtle, but they don&#X2019;t have a return value. In
this chapter you will learn to write fruitful functions.</p>
<!--TOC section id="sec70" Return values-->
<h2 class="section" id="sec70">6.1&#X2003;Return values</h2><!--SEC END --><p>
<a id="hevea_default419"></a></p><p>Calling the function generates a return
value, which we usually assign to a variable or use as part of an
expression.</p><pre class="verbatim">e = math.exp(1.0)
height = radius * math.sin(radians)
</pre><p>
The functions we have written so far are void. Speaking casually,
they have no return value; more precisely,
their return value is <span class="c004">None</span>.</p><p>In this chapter, we are (finally) going to write fruitful functions.
The first example is <span class="c004">area</span>, which returns the area of a circle
with the given radius:</p><pre class="verbatim">def area(radius):
    a = math.pi * radius**2
    return a
</pre><p>
We have seen the <span class="c004">return</span> statement before, but in a fruitful
function the <span class="c004">return</span> statement includes
an expression. This statement means: &#X201C;Return immediately from
this function and use the following expression as a return value.&#X201D;
The expression can be arbitrarily complicated, so we could
have written this function more concisely:
<a id="hevea_default420"></a>
<a id="hevea_default421"></a></p><pre class="verbatim">def area(radius):
    return math.pi * radius**2
</pre><p>
On the other hand, <span class="c010">temporary variables</span> like <span class="c004">a</span> can make
debugging easier.
<a id="hevea_default422"></a>
<a id="hevea_default423"></a></p><p>Sometimes it is useful to have multiple return statements, one in each
branch of a conditional:</p><pre class="verbatim">def absolute_value(x):
    if x &lt; 0:
        return -x
    else:
        return x
</pre><p>
Since these <span class="c004">return</span> statements are in an alternative conditional,
only one runs.</p><p>As soon as a return statement runs, the function
terminates without executing any subsequent statements.
Code that appears after a <span class="c004">return</span> statement, or any other place
the flow of execution can never reach, is called <span class="c010">dead code</span>.
<a id="hevea_default424"></a></p><p>In a fruitful function, it is a good idea to ensure
that every possible path through the program hits a
<span class="c004">return</span> statement. For example:</p><pre class="verbatim">def absolute_value(x):
    if x &lt; 0:
        return -x
    if x &gt; 0:
        return x
</pre><p>
This function is incorrect because if <span class="c004">x</span> happens to be 0,
neither condition is true, and the function ends without hitting a
<span class="c004">return</span> statement. If the flow of execution gets to the end
of a function, the return value is <span class="c004">None</span>, which is not
the absolute value of 0.
<a id="hevea_default425"></a>
<a id="hevea_default426"></a></p><pre class="verbatim">&gt;&gt;&gt; print(absolute_value(0))
None
</pre><p>
By the way, Python provides a built-in function called
<span class="c004">abs</span> that computes absolute values.
<a id="hevea_default427"></a>
<a id="hevea_default428"></a></p><p>As an exercise, write a <span class="c004">compare</span> function that
takes two values, <span class="c004">x</span> and <span class="c004">y</span>, and returns <span class="c004">1</span> if <span class="c004">x &gt; y</span>,
<span class="c004">0</span> if <span class="c004">x == y</span>, and <span class="c004">-1</span> if <span class="c004">x &lt; y</span>.
<a id="hevea_default429"></a>
<a id="hevea_default430"></a></p>
<!--TOC section id="sec71" Incremental development-->
<h2 class="section" id="sec71">6.2&#X2003;Incremental development</h2><!--SEC END --><p>
<a id="incremental.development"></a>
<a id="hevea_default431"></a></p><p>As you write larger functions, you might find yourself
spending more time debugging.</p><p>To deal with increasingly complex programs,
you might want to try a process called
<span class="c010">incremental development</span>. The goal of incremental development
is to avoid long debugging sessions by adding and testing only
a small amount of code at a time.
<a id="hevea_default432"></a>
<a id="hevea_default433"></a></p><p>As an example, suppose you want to find the distance between two
points, given by the coordinates (<span class="c009">x</span><sub>1</sub>, <span class="c009">y</span><sub>1</sub>) and (<span class="c009">x</span><sub>2</sub>, <span class="c009">y</span><sub>2</sub>).
By the Pythagorean theorem, the distance is:</p><table class="display dcenter"><tr class="c017"><td class="dcell"><span class="c009">distance</span>&#X2004;=&#X2004;</td><td class="dcell"><span class="c008">&#X221A;</span></td><td class="dcell"><table class="c002 cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td class="c012">(<span class="c009">x</span><sub>2</sub>&#X2004;&#X2212;&#X2004;<span class="c009">x</span><sub>1</sub>)<sup>2</sup>&#X2004;+&#X2004;(<span class="c009">y</span><sub>2</sub>&#X2004;&#X2212;&#X2004;<span class="c009">y</span><sub>1</sub>)<sup>2</sup></td></tr>
</table></td></tr>
</table><p>
The first step is to consider what a <span class="c004">distance</span> function should
look like in Python. In other words, what are the inputs (parameters)
and what is the output (return value)?</p><p>In this case, the inputs are two points, which you can represent
using four numbers. The return value is the distance represented by
a floating-point value.</p><p>Immediately you can write an outline of the function:</p><pre class="verbatim">def distance(x1, y1, x2, y2):
    return 0.0
</pre><p>
Obviously, this version doesn&#X2019;t compute distances; it always returns
zero. But it is syntactically correct, and it runs, which means that
you can test it before you make it more complicated.</p><p>To test the new function, call it with sample arguments:</p><pre class="verbatim">&gt;&gt;&gt; distance(1, 2, 4, 6)
0.0
</pre><p>
I chose these values so that the horizontal distance is 3 and the
vertical distance is 4; that way, the result is 5, the hypotenuse
of a 3-4-5 right triangle. When testing a function, it is
useful to know the right answer.
<a id="hevea_default434"></a></p><p>At this point we have confirmed that the function is syntactically
correct, and we can start adding code to the body.
A reasonable next step is to find the differences
<span class="c009">x</span><sub>2</sub> &#X2212; <span class="c009">x</span><sub>1</sub> and <span class="c009">y</span><sub>2</sub> &#X2212; <span class="c009">y</span><sub>1</sub>. The next version stores those values in
temporary variables and prints them.</p><pre class="verbatim">def distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    print('dx is', dx)
    print('dy is', dy)
    return 0.0
</pre><p>
If the function is working, it should display <code class="verb">dx is 3</code> and
<code class="verb">dy is 4</code>. If so, we know that the function is getting the right
arguments and performing the first computation correctly. If not,
there are only a few lines to check.</p><p>Next we compute the sum of squares of <span class="c004">dx</span> and <span class="c004">dy</span>:</p><pre class="verbatim">def distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    dsquared = dx**2 + dy**2
    print('dsquared is: ', dsquared)
    return 0.0
</pre><p>
Again, you would run the program at this stage and check the output
(which should be 25).
Finally, you can use <span class="c004">math.sqrt</span> to compute and return the result:
<a id="hevea_default435"></a>
<a id="hevea_default436"></a></p><pre class="verbatim">def distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    dsquared = dx**2 + dy**2
    result = math.sqrt(dsquared)
    return result
</pre><p>
If that works correctly, you are done. Otherwise, you might
want to print the value of <span class="c004">result</span> before the return
statement.</p><p>The final version of the function doesn&#X2019;t display anything when it
runs; it only returns a value. The <span class="c004">print</span> statements we wrote
are useful for debugging, but once you get the function working, you
should remove them. Code like that is called <span class="c010">scaffolding</span>
because it is helpful for building the program but is not part of the
final product.
<a id="hevea_default437"></a></p><p>When you start out, you should add only a line or two of code at a
time. As you gain more experience, you might find yourself writing
and debugging bigger chunks. Either way, incremental development
can save you a lot of debugging time.</p><p>The key aspects of the process are:</p><ol class="enumerate" type=1><li class="li-enumerate">Start with a working program and make small incremental changes.
At any point, if there is an error, you should have a good idea
where it is.</li><li class="li-enumerate">Use variables to hold intermediate values so you can
display and check them.</li><li class="li-enumerate">Once the program is working, you might want to remove some of
the scaffolding or consolidate multiple statements into compound
expressions, but only if it does not make the program difficult to
read.</li></ol><p>As an exercise, use incremental development to write a function
called <span class="c004">hypotenuse</span> that returns the length of the hypotenuse of a
right triangle given the lengths of the other two legs as arguments.
Record each stage of the development process as you go.
<a id="hevea_default438"></a></p>
<!--TOC section id="sec72" Composition-->
<h2 class="section" id="sec72">6.3&#X2003;Composition</h2><!--SEC END --><p>
<a id="hevea_default439"></a>
<a id="hevea_default440"></a></p><p>As you should expect by now, you can call one function from within
another. As an example, we&#X2019;ll write a function that takes two points,
the center of the circle and a point on the perimeter, and computes
the area of the circle.</p><p>Assume that the center point is stored in the variables <span class="c004">xc</span> and
<span class="c004">yc</span>, and the perimeter point is in <span class="c004">xp</span> and <span class="c004">yp</span>. The
first step is to find the radius of the circle, which is the distance
between the two points. We just wrote a function, <span class="c004">distance</span>, that does that:</p><pre class="verbatim">radius = distance(xc, yc, xp, yp)
</pre><p>
The next step is to find the area of a circle with that radius;
we just wrote that, too:</p><pre class="verbatim">result = area(radius)
</pre><p>
Encapsulating these steps in a function, we get:
<a id="hevea_default441"></a></p><pre class="verbatim">def circle_area(xc, yc, xp, yp):
    radius = distance(xc, yc, xp, yp)
    result = area(radius)
    return result
</pre><p>
The temporary variables <span class="c004">radius</span> and <span class="c004">result</span> are useful for
development and debugging, but once the program is working, we can
make it more concise by composing the function calls:</p><pre class="verbatim">def circle_area(xc, yc, xp, yp):
    return area(distance(xc, yc, xp, yp))
</pre>
<!--TOC section id="sec73" Boolean functions-->
<h2 class="section" id="sec73">6.4&#X2003;Boolean functions</h2><!--SEC END --><p>
<a id="boolean"></a></p><p>Functions can return booleans, which is often convenient for hiding
complicated tests inside functions. <a id="hevea_default442"></a>
For example:</p><pre class="verbatim">def is_divisible(x, y):
    if x % y == 0:
        return True
    else:
        return False
</pre><p>
It is common to give boolean functions names that sound like yes/no
questions; <code class="verb">is_divisible</code> returns either <span class="c004">True</span> or <span class="c004">False</span>
to indicate whether <span class="c004">x</span> is divisible by <span class="c004">y</span>.</p><p>Here is an example:</p><pre class="verbatim">&gt;&gt;&gt; is_divisible(6, 4)
False
&gt;&gt;&gt; is_divisible(6, 3)
True
</pre><p>
The result of the <span class="c004">==</span> operator is a boolean, so we can write the
function more concisely by returning it directly:</p><pre class="verbatim">def is_divisible(x, y):
    return x % y == 0
</pre><p>
Boolean functions are often used in conditional statements:
<a id="hevea_default443"></a>
<a id="hevea_default444"></a></p><pre class="verbatim">if is_divisible(x, y):
    print('x is divisible by y')
</pre><p>
It might be tempting to write something like:</p><pre class="verbatim">if is_divisible(x, y) == True:
    print('x is divisible by y')
</pre><p>
But the extra comparison is unnecessary.</p><p>As an exercise, write a function <code class="verb">is_between(x, y, z)</code> that
returns <span class="c004">True</span> if <span class="c009">x</span> &#X2264; <span class="c009">y</span> &#X2264; <span class="c009">z</span> or <span class="c004">False</span> otherwise.</p>
<!--TOC section id="sec74" More recursion-->
<h2 class="section" id="sec74">6.5&#X2003;More recursion</h2><!--SEC END --><p>
<a id="more.recursion"></a>
<a id="hevea_default445"></a>
<a id="hevea_default446"></a>
<a id="hevea_default447"></a>
<a id="hevea_default448"></a>
<a id="hevea_default449"></a></p><p>We have only covered a small subset of Python, but you might
be interested to know that this subset is a <em>complete</em>
programming language, which means that anything that can be
computed can be expressed in this language. Any program ever written
could be rewritten using only the language features you have learned
so far (actually, you would need a few commands to control devices
like the mouse, disks, etc., but that&#X2019;s all).</p><p>Proving that claim is a nontrivial exercise first accomplished by Alan
Turing, one of the first computer scientists (some would argue that he
was a mathematician, but a lot of early computer scientists started as
mathematicians). Accordingly, it is known as the Turing Thesis.
For a more complete (and accurate) discussion of the Turing Thesis,
I recommend Michael Sipser&#X2019;s book <em>Introduction to the
Theory of Computation</em>.</p><p>To give you an idea of what you can do with the tools you have learned
so far, we&#X2019;ll evaluate a few recursively defined mathematical
functions. A recursive definition is similar to a circular
definition, in the sense that the definition contains a reference to
the thing being defined. A truly circular definition is not very
useful:</p><dl class="description"><dt class="dt-description"><span class="c010">vorpal:</span></dt><dd class="dd-description"> An adjective used to describe something that is vorpal.
<a id="hevea_default450"></a>
<a id="hevea_default451"></a>
<a id="hevea_default452"></a></dd></dl><p>If you saw that definition in the dictionary, you might be annoyed. On
the other hand, if you looked up the definition of the factorial
function, denoted with the symbol !, you might get something like
this:
</p><table class="display dcenter"><tr class="c017"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c015">&nbsp;</td><td class="c012">&nbsp;</td><td class="c013">0!&#X2004;=&#X2004;1&#X2004;</td></tr>
<tr><td class="c015">&nbsp;</td><td class="c012">&nbsp;</td><td class="c013"><span class="c009">n</span>!&#X2004;=&#X2004;<span class="c009">n</span>&#X2004;(<span class="c009">n</span>&#X2212;1)!
</td></tr>
</table></td></tr>
</table><p>
This definition says that the factorial of 0 is 1, and the factorial
of any other value, <span class="c009">n</span>, is <span class="c009">n</span> multiplied by the factorial of <span class="c009">n</span>&#X2212;1.</p><p>So 3! is 3 times 2!, which is 2 times 1!, which is 1 times
0!. Putting it all together, 3! equals 3 times 2 times 1 times 1,
which is 6.
<a id="hevea_default453"></a>
<a id="hevea_default454"></a>
<a id="hevea_default455"></a></p><p>If you can write a recursive definition of something, you can
write a Python program to evaluate it. The first step is to decide
what the parameters should be. In this case it should be clear
that <span class="c004">factorial</span> takes an integer:</p><pre class="verbatim">def factorial(n):
</pre><p>
If the argument happens to be 0, all we have to do is return 1:</p><pre class="verbatim">def factorial(n):
    if n == 0:
        return 1
</pre><p>
Otherwise, and this is the interesting part, we have to make a
recursive call to find the factorial of <span class="c009">n</span>&#X2212;1 and then multiply it by
<span class="c009">n</span>:</p><pre class="verbatim">def factorial(n):
    if n == 0:
        return 1
    else:
        recurse = factorial(n-1)
        result = n * recurse
        return result
</pre><p>
The flow of execution for this program is similar to the flow of <span class="c004">countdown</span> in Section&#XA0;<a href="#recursion">5.8</a>. If we call <span class="c004">factorial</span>
with the value 3:</p><p>Since 3 is not 0, we take the second branch and calculate the factorial
of <span class="c004">n-1</span>...</p><blockquote class="quote">
Since 2 is not 0, we take the second branch and calculate the factorial of
<span class="c004">n-1</span>...<blockquote class="quote">
Since 1 is not 0, we take the second branch and calculate the factorial
of <span class="c004">n-1</span>...<blockquote class="quote">
Since 0 equals 0, we take the first branch and return 1
without making any more recursive calls.
</blockquote><p>The return value, 1, is multiplied by <span class="c009">n</span>, which is 1, and the
result is returned.
</p></blockquote><p>The return value, 1, is multiplied by <span class="c009">n</span>, which is 2, and the
result is returned.
</p></blockquote><p>The return value (2) is multiplied by <span class="c009">n</span>, which is 3, and the result, 6,
becomes the return value of the function call that started the whole
process.
<a id="hevea_default456"></a></p><p>Figure&#XA0;<a href="#fig.stack3">6.1</a> shows what the stack diagram looks like for
this sequence of function calls.</p><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2007.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 6.1: Stack diagram.</td></tr>
</table></div>
<a id="fig.stack3"></a>
<div class="center"><hr class="floatrule"></div></blockquote><p>The return values are shown being passed back up the stack. In each
frame, the return value is the value of <span class="c004">result</span>, which is the
product of <span class="c004">n</span> and <span class="c004">recurse</span>.
<a id="hevea_default457"></a>
<a id="hevea_default458"></a></p><p>In the last frame, the local
variables <span class="c004">recurse</span> and <span class="c004">result</span> do not exist, because
the branch that creates them does not run.</p>
<!--TOC section id="sec75" Leap of faith-->
<h2 class="section" id="sec75">6.6&#X2003;Leap of faith</h2><!--SEC END --><p>
<a id="hevea_default459"></a>
<a id="hevea_default460"></a></p><p>Following the flow of execution is one way to read programs, but
it can quickly become overwhelming. An
alternative is what I call the &#X201C;leap of faith&#X201D;. When you come to a
function call, instead of following the flow of execution, you <em>assume</em> that the function works correctly and returns the right
result.</p><p>In fact, you are already practicing this leap of faith when you use
built-in functions. When you call <span class="c004">math.cos</span> or <span class="c004">math.exp</span>,
you don&#X2019;t examine the bodies of those functions. You just
assume that they work because the people who wrote the built-in
functions were good programmers.</p><p>The same is true when you call one of your own functions. For
example, in Section&#XA0;<a href="#boolean">6.4</a>, we wrote a function called
<code class="verb">is_divisible</code> that determines whether one number is divisible by
another. Once we have convinced ourselves that this function is
correct&#X2014;by examining the code and testing&#X2014;we can use the function
without looking at the body again.
<a id="hevea_default461"></a></p><p>The same is true of recursive programs. When you get to the recursive
call, instead of following the flow of execution, you should assume
that the recursive call works (returns the correct result) and then ask
yourself, &#X201C;Assuming that I can find the factorial of <span class="c009">n</span>&#X2212;1, can I
compute the factorial of <span class="c009">n</span>?&#X201D; It is clear that you
can, by multiplying by <span class="c009">n</span>.</p><p>Of course, it&#X2019;s a bit strange to assume that the function works
correctly when you haven&#X2019;t finished writing it, but that&#X2019;s why
it&#X2019;s called a leap of faith!</p>
<!--TOC section id="sec76" One more example-->
<h2 class="section" id="sec76">6.7&#X2003;One more example</h2><!--SEC END --><p>
<a id="one.more.example"></a></p><p><a id="hevea_default462"></a>
<a id="hevea_default463"></a>
After <span class="c004">factorial</span>, the most common example of a recursively
defined mathematical function is <span class="c004">fibonacci</span>, which has the
following definition (see
<a href="http://en.wikipedia.org/wiki/Fibonacci_number"><span class="c004">http://en.wikipedia.org/wiki/Fibonacci_number</span></a>):
</p><table class="display dcenter"><tr class="c017"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c015">&nbsp;</td><td class="c012">&nbsp;</td><td class="c013"><span class="c009">fibonacci</span>(0)&#X2004;=&#X2004;0&#X2004;</td></tr>
<tr><td class="c015">&nbsp;</td><td class="c012">&nbsp;</td><td class="c013"><span class="c009">fibonacci</span>(1)&#X2004;=&#X2004;1&#X2004;</td></tr>
<tr><td class="c015">&nbsp;</td><td class="c012">&nbsp;</td><td class="c013"><span class="c009">fibonacci</span>(<span class="c009">n</span>)&#X2004;=&#X2004;<span class="c009">fibonacci</span>(<span class="c009">n</span>&#X2212;1)&#X2004;+&#X2004;<span class="c009">fibonacci</span>(<span class="c009">n</span>&#X2212;2)
</td></tr>
</table></td></tr>
</table><p>
Translated into Python, it looks like this:</p><pre class="verbatim">def fibonacci(n):
    if n == 0:
        return 0
    elif  n == 1:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)
</pre><p>
If you try to follow the flow of execution here, even for fairly
small values of <span class="c009">n</span>, your head explodes. But according to the
leap of faith, if you assume that the two recursive calls
work correctly, then it is clear that you get
the right result by adding them together.
<a id="hevea_default464"></a></p>
<!--TOC section id="sec77" Checking types-->
<h2 class="section" id="sec77">6.8&#X2003;Checking types</h2><!--SEC END --><p>
<a id="guardian"></a></p><p>What happens if we call <span class="c004">factorial</span> and give it 1.5 as an argument?
<a id="hevea_default465"></a>
<a id="hevea_default466"></a>
<a id="hevea_default467"></a>
<a id="hevea_default468"></a></p><pre class="verbatim">&gt;&gt;&gt; factorial(1.5)
RuntimeError: Maximum recursion depth exceeded
</pre><p>
It looks like an infinite recursion. How can that be? The function
has a base case&#X2014;when <span class="c004">n == 0</span>. But if <span class="c004">n</span> is not an integer,
we can <em>miss</em> the base case and recurse forever.
<a id="hevea_default469"></a>
<a id="hevea_default470"></a></p><p>In the first recursive call, the value of <span class="c004">n</span> is 0.5.
In the next, it is -0.5. From there, it gets smaller
(more negative), but it will never be 0.</p><p>We have two choices. We can try to generalize the <span class="c004">factorial</span>
function to work with floating-point numbers, or we can make <span class="c004">factorial</span> check the type of its argument. The first option is
called the gamma function and it&#X2019;s a
little beyond the scope of this book. So we&#X2019;ll go for the second.
<a id="hevea_default471"></a></p><p>We can use the built-in function <span class="c004">isinstance</span> to verify the type
of the argument. While we&#X2019;re at it, we can also make sure the
argument is positive:
<a id="hevea_default472"></a>
<a id="hevea_default473"></a></p><pre class="verbatim">def factorial(n):
    if not isinstance(n, int):
        print('Factorial is only defined for integers.')
        return None
    elif n &lt; 0:
        print('Factorial is not defined for negative integers.')
        return None
    elif n == 0:
        return 1
    else:
        return n * factorial(n-1)
</pre><p>
The first base case handles nonintegers; the
second handles negative integers. In both cases, the program prints
an error message and returns <span class="c004">None</span> to indicate that something
went wrong:</p><pre class="verbatim">&gt;&gt;&gt; print(factorial('fred'))
Factorial is only defined for integers.
None
&gt;&gt;&gt; print(factorial(-2))
Factorial is not defined for negative integers.
None
</pre><p>
If we get past both checks, we know that <span class="c009">n</span> is a non-negative integer, so we can prove that the recursion terminates.
<a id="hevea_default474"></a>
<a id="hevea_default475"></a></p><p>This program demonstrates a pattern sometimes called a <span class="c010">guardian</span>.
The first two conditionals act as guardians, protecting the code that
follows from values that might cause an error. The guardians make it
possible to prove the correctness of the code.</p><p>In Section&#XA0;<a href="#raise">11.4</a> we will see a more flexible alternative to printing
an error message: raising an exception.</p>
<!--TOC section id="sec78" Debugging-->
<h2 class="section" id="sec78">6.9&#X2003;Debugging</h2><!--SEC END --><p>
<a id="factdebug"></a></p><p>Breaking a large program into smaller functions creates natural
checkpoints for debugging. If a function is not
working, there are three possibilities to consider:
<a id="hevea_default476"></a></p><ul class="itemize"><li class="li-itemize">There is something wrong with the arguments the function
is getting; a precondition is violated.</li><li class="li-itemize">There is something wrong with the function; a postcondition
is violated.</li><li class="li-itemize">There is something wrong with the return value or the
way it is being used.</li></ul><p>To rule out the first possibility, you can add a <span class="c004">print</span> statement
at the beginning of the function and display the values of the
parameters (and maybe their types). Or you can write code
that checks the preconditions explicitly.
<a id="hevea_default477"></a>
<a id="hevea_default478"></a></p><p>If the parameters look good, add a <span class="c004">print</span> statement before each
<span class="c004">return</span> statement and display the return value. If
possible, check the result by hand. Consider calling the
function with values that make it easy to check the result
(as in Section&#XA0;<a href="#incremental.development">6.2</a>).</p><p>If the function seems to be working, look at the function call
to make sure the return value is being used correctly (or used
at all!).
<a id="hevea_default479"></a></p><p>Adding print statements at the beginning and end of a function
can help make the flow of execution more visible.
For example, here is a version of <span class="c004">factorial</span> with
print statements:</p><pre class="verbatim">def factorial(n):
    space = ' ' * (4 * n)
    print(space, 'factorial', n)
    if n == 0:
        print(space, 'returning 1')
        return 1
    else:
        recurse = factorial(n-1)
        result = n * recurse
        print(space, 'returning', result)
        return result
</pre><p>
<span class="c004">space</span> is a string of space characters that controls the
indentation of the output. Here is the result of <span class="c004">factorial(4)</span> :</p><pre class="verbatim">                 factorial 4
             factorial 3
         factorial 2
     factorial 1
 factorial 0
 returning 1
     returning 1
         returning 2
             returning 6
                 returning 24
</pre><p>
If you are confused about the flow of execution, this kind of
output can be helpful. It takes some time to develop effective
scaffolding, but a little bit of scaffolding can save a lot of debugging.</p>
<!--TOC section id="sec79" Glossary-->
<h2 class="section" id="sec79">6.10&#X2003;Glossary</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c010">temporary variable:</span></dt><dd class="dd-description"> A variable used to store an intermediate value in
a complex calculation.
<a id="hevea_default480"></a>
<a id="hevea_default481"></a></dd><dt class="dt-description"><span class="c010">dead code:</span></dt><dd class="dd-description"> Part of a program that can never run, often because
it appears after a <span class="c004">return</span> statement.
<a id="hevea_default482"></a></dd><dt class="dt-description"><span class="c010">incremental development:</span></dt><dd class="dd-description"> A program development plan intended to
avoid debugging by adding and testing only
a small amount of code at a time.
<a id="hevea_default483"></a></dd><dt class="dt-description"><span class="c010">scaffolding:</span></dt><dd class="dd-description"> Code that is used during program development but is
not part of the final version.
<a id="hevea_default484"></a></dd><dt class="dt-description"><span class="c010">guardian:</span></dt><dd class="dd-description"> A programming pattern that uses a conditional
statement to check for and handle circumstances that
might cause an error.
<a id="hevea_default485"></a>
<a id="hevea_default486"></a></dd></dl>
<!--TOC section id="sec80" Exercises-->
<h2 class="section" id="sec80">6.11&#X2003;Exercises</h2><!--SEC END --><div class="theorem"><span class="c010">Exercise&#XA0;1</span>&#X2003;<p><em>Draw a stack diagram for the following program. What does the program print?
</em><a id="hevea_default487"></a></p><pre class="verbatim"><em>def b(z):
    prod = a(z, z)
    print(z, prod)
    return prod

def a(x, y):
    x = x + 1
    return x * y

def c(x, y, z):
    total = x + y + z
    square = b(total)**2
    return square

x = 1
y = x + 1
print(c(x, y+3, x+y))
</em></pre></div><div class="theorem"><span class="c010">Exercise&#XA0;2</span>&#X2003;
<a id="ackermann"></a><p><em>The Ackermann function, </em><span class="c009">A</span>(<span class="c009">m</span>, <span class="c009">n</span>)<em>, is defined:</em></p><table class="display dcenter"><tr class="c017"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c015"><table class="display"><tr class="c017"><td class="dcell"><span class="c009">A</span>(<span class="c009">m</span>,&#X2004;<span class="c009">n</span>)&#X2004;=&#X2004;</td><td class="dcell"><table class="display"><tr class="c017"><td class="dcell">&#X23A7;<br>
&#X23AA;<br>
&#X23A8;<br>
&#X23AA;<br>
&#X23A9;</td><td class="dcell"><table class="c001 cellpading0"><tr><td class="c013">&#X2004;&#X2004;&#X2004;&#X2004;&#X2004;&#X2004;&#X2004;&#X2004;&#X2004;&#X2004;&#X2004;&#X2004;&#X2004;&#X2004;<span class="c009">n</span>+1</td><td class="c013">if &#X2004;<span class="c009">m</span>&#X2004;=&#X2004;0&#X2004;</td></tr>
<tr><td class="c013">&#X2004;&#X2004;&#X2004;&#X2004;&#X2004;&#X2004;&#X2004;&#X2004;<span class="c009">A</span>(<span class="c009">m</span>&#X2212;1,&#X2004;1)</td><td class="c013">if &#X2004;<span class="c009">m</span>&#X2004;&gt;&#X2004;0&#X2004; and &#X2004;<span class="c009">n</span>&#X2004;=&#X2004;0&#X2004;</td></tr>
<tr><td class="c013"><span class="c009">A</span>(<span class="c009">m</span>&#X2212;1,&#X2004;<span class="c009">A</span>(<span class="c009">m</span>,&#X2004;<span class="c009">n</span>&#X2212;1))</td><td class="c013">if &#X2004;<span class="c009">m</span>&#X2004;&gt;&#X2004;0&#X2004; and &#X2004;<span class="c009">n</span>&#X2004;&gt;&#X2004;0.
</td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table><p><em>
See </em><a href="http://en.wikipedia.org/wiki/Ackermann_function"><span class="c004"><em>http://en.wikipedia.org/wiki/Ackermann_function</em></span></a><em>.
Write a function named <span class="c004">ack</span> that evaluates the Ackermann function.
Use your function to evaluate <span class="c004">ack(3, 4)</span>, which should be 125.
What happens for larger values of <span class="c004">m</span> and <span class="c004">n</span>?
Solution: </em><a href="https://thinkpython.com/code/ackermann.py"><span class="c004"><em>https://thinkpython.com/code/ackermann.py</em></span></a><em>.
</em><a id="hevea_default488"></a>
<a id="hevea_default489"></a></p></div><div class="theorem"><span class="c010">Exercise&#XA0;3</span>&#X2003;
<a id="palindrome"></a><p><em>A palindrome is a word that is spelled the same backward and
forward, like &#X201C;noon&#X201D; and &#X201C;redivider&#X201D;. Recursively, a word
is a palindrome if the first and last letters are the same
and the middle is a palindrome.
</em><a id="hevea_default490"></a></p><p><em>The following are functions that take a string argument and
return the first, last, and middle letters:</em></p><pre class="verbatim"><em>def first(word):
    return word[0]

def last(word):
    return word[-1]

def middle(word):
    return word[1:-1]
</em></pre><p><em>
We&#X2019;ll see how they work in Chapter&#XA0;</em><a href="#strings"><em>8</em></a><em>.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Type these functions into a file named <span class="c004">palindrome.py</span>
and test them out. What happens if you call <span class="c004">middle</span> with
a string with two letters? One letter? What about the empty
string, which is written </em><code class="verb"><em>''</em></code><em> and contains no letters?</em></li><li class="li-enumerate"><em>Write a function called </em><code class="verb"><em>is_palindrome</em></code><em> that takes
a string argument and returns <span class="c004">True</span> if it is a palindrome
and <span class="c004">False</span> otherwise. Remember that you can use the
built-in function <span class="c004">len</span> to check the length of a string.</em></li></ol><p><em>Solution: </em><a href="https://thinkpython.com/code/palindrome_soln.py"><em><span class="c004">https://thinkpython.com/code/palindrome_soln.py</span></em></a><em>.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;4</span>&#X2003;<p><em>A number, </em><span class="c009">a</span><em>, is a power of </em><span class="c009">b</span><em> if it is divisible by </em><span class="c009">b</span><em>
and </em><span class="c009">a</span>/<span class="c009">b</span><em> is a power of </em><span class="c009">b</span><em>. Write a function called
</em><code class="verb"><em>is_power</em></code><em> that takes parameters <span class="c004">a</span> and <span class="c004">b</span>
and returns <span class="c004">True</span> if <span class="c004">a</span> is a power of <span class="c004">b</span>.
Note: you will have to think about the base case.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;5</span>&#X2003;
<a id="hevea_default491"></a>
<a id="hevea_default492"></a><p><em>The greatest common divisor (GCD) of </em><span class="c009">a</span><em> and </em><span class="c009">b</span><em> is the largest number
that divides both of them with no remainder.</em></p><p><em>One way to find the GCD of two numbers is based on the observation
that if </em><span class="c009">r</span><em> is the remainder when </em><span class="c009">a</span><em> is divided by </em><span class="c009">b</span><em>, then </em><span class="c009">gcd</span>(<span class="c009">a</span>,
<span class="c009">b</span>) = <span class="c009">gcd</span>(<span class="c009">b</span>, <span class="c009">r</span>)<em>. As a base case, we can use </em><span class="c009">gcd</span>(<span class="c009">a</span>, 0) = <span class="c009">a</span><em>.</em></p><p><em>Write a function called
</em><code class="verb"><em>gcd</em></code><em> that takes parameters <span class="c004">a</span> and <span class="c004">b</span>
and returns their greatest common divisor.</em></p><p><em>Credit: This exercise is based on an example from Abelson and
Sussman&#X2019;s </em>Structure and Interpretation of Computer Programs<em>.</em></p></div>
<!--TOC chapter id="sec81" Iteration-->
<h1 class="chapter" id="sec81">Chapter&#XA0;7&#X2003;Iteration</h1><!--SEC END --><p>This chapter is about iteration, which is the ability to run
a block of statements repeatedly. We saw a kind of iteration,
using recursion, in Section&#XA0;<a href="#recursion">5.8</a>.
We saw another kind, using a <span class="c004">for</span> loop,
in Section&#XA0;<a href="#repetition">4.2</a>. In this chapter we&#X2019;ll see yet another
kind, using a <span class="c004">while</span> statement.
But first I want to say a little more about variable assignment.</p>
<!--TOC section id="sec82" Reassignment-->
<h2 class="section" id="sec82">7.1&#X2003;Reassignment</h2><!--SEC END --><p>
<a id="hevea_default493"></a>
<a id="hevea_default494"></a>
<a id="hevea_default495"></a></p><p>As you may have discovered, it is legal to make more than one
assignment to the same variable. A new assignment makes an existing
variable refer to a new value (and stop referring to the old value).</p><pre class="verbatim">&gt;&gt;&gt; x = 5
&gt;&gt;&gt; x
5
&gt;&gt;&gt; x = 7
&gt;&gt;&gt; x
7
</pre><p>
The first time we display
<span class="c004">x</span>, its value is 5; the second time, its
value is 7.</p><p>Figure&#XA0;<a href="#fig.assign2">7.1</a> shows what <span class="c010">reassignment</span> looks
like in a state diagram. <a id="hevea_default496"></a> <a id="hevea_default497"></a></p><p>At this point I want to address a common source of
confusion.
Because Python uses the equal sign (<span class="c004">=</span>) for assignment, it is
tempting to interpret a statement like <span class="c004">a = b</span> as a
mathematical
proposition of equality; that is, the claim that <span class="c004">a</span> and
<span class="c004">b</span> are equal. But this interpretation is wrong.
<a id="hevea_default498"></a></p><p>First, equality is a symmetric relationship and assignment is not. For
example, in mathematics, if <span class="c009">a</span>=7 then 7=<span class="c009">a</span>. But in Python, the
statement <span class="c004">a = 7</span> is legal and <span class="c004">7 = a</span> is not.</p><p>Also, in mathematics, a proposition of equality is either true or
false for all time. If <span class="c009">a</span>=<span class="c009">b</span> now, then <span class="c009">a</span> will always equal <span class="c009">b</span>.
In Python, an assignment statement can make two variables equal, but
they don&#X2019;t have to stay that way:</p><pre class="verbatim">&gt;&gt;&gt; a = 5
&gt;&gt;&gt; b = a    # a and b are now equal
&gt;&gt;&gt; a = 3    # a and b are no longer equal
&gt;&gt;&gt; b
5
</pre><p>
The third line changes the value of <span class="c004">a</span> but does not change the
value of <span class="c004">b</span>, so they are no longer equal.</p><p>Reassigning variables is often useful, but you should use it
with caution. If the values of variables change frequently, it can
make the code difficult to read and debug.</p><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2008.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 7.1: State diagram.</td></tr>
</table></div>
<a id="fig.assign2"></a>
<div class="center"><hr class="floatrule"></div></blockquote>
<!--TOC section id="sec83" Updating variables-->
<h2 class="section" id="sec83">7.2&#X2003;Updating variables</h2><!--SEC END --><p>
<a id="update"></a></p><p><a id="hevea_default499"></a>
<a id="hevea_default500"></a></p><p>A common kind of reassignment is an <span class="c010">update</span>,
where the new value of the variable depends on the old.</p><pre class="verbatim">&gt;&gt;&gt; x = x + 1
</pre><p>
This means &#X201C;get the current value of <span class="c004">x</span>, add one, and then
update <span class="c004">x</span> with the new value.&#X201D;</p><p>If you try to update a variable that doesn&#X2019;t exist, you get an
error, because Python evaluates the right side before it assigns
a value to <span class="c004">x</span>:</p><pre class="verbatim">&gt;&gt;&gt; x = x + 1
NameError: name 'x' is not defined
</pre><p>
Before you can update a variable, you have to <span class="c010">initialize</span>
it, usually with a simple assignment:
<a id="hevea_default501"></a></p><pre class="verbatim">&gt;&gt;&gt; x = 0
&gt;&gt;&gt; x = x + 1
</pre><p>
Updating a variable by adding 1 is called an <span class="c010">increment</span>;
subtracting 1 is called a <span class="c010">decrement</span>.
<a id="hevea_default502"></a>
<a id="hevea_default503"></a></p>
<!--TOC section id="sec84" The <span class="c004">while</span> statement-->
<h2 class="section" id="sec84">7.3&#X2003;The <span class="c004">while</span> statement</h2><!--SEC END --><p>
<a id="hevea_default504"></a>
<a id="hevea_default505"></a>
<a id="hevea_default506"></a>
<a id="hevea_default507"></a></p><p>Computers are often used to automate repetitive tasks. Repeating
identical or similar tasks without making errors is something that
computers do well and people do poorly. In a computer program,
repetition is also called <span class="c010">iteration</span>.</p><p>We have already seen two functions, <span class="c004">countdown</span> and
<code class="verb">print_n</code>, that iterate using recursion. Because iteration is so
common, Python provides language features to make it easier.
One is the <span class="c004">for</span> statement we saw in Section&#XA0;<a href="#repetition">4.2</a>.
We&#X2019;ll get back to that later.</p><p>Another is the <span class="c004">while</span> statement. Here is a version of <span class="c004">countdown</span> that uses a <span class="c004">while</span> statement:</p><pre class="verbatim">def countdown(n):
    while n &gt; 0:
        print(n)
        n = n - 1
    print('Blastoff!')
</pre><p>
You can almost read the <span class="c004">while</span> statement as if it were English.
It means, &#X201C;While <span class="c004">n</span> is greater than 0,
display the value of <span class="c004">n</span> and then decrement
<span class="c004">n</span>. When you get to 0, display the word <span class="c004">Blastoff!</span>&#X201D;
<a id="hevea_default508"></a></p><p>More formally, here is the flow of execution for a <span class="c004">while</span> statement:</p><ol class="enumerate" type=1><li class="li-enumerate">Determine whether the condition is true or false.</li><li class="li-enumerate">If false, exit the <span class="c004">while</span> statement
and continue execution at the next statement.</li><li class="li-enumerate">If the condition is true, run the
body and then go back to step 1.</li></ol><p>This type of flow is called a loop because the third step
loops back around to the top.
<a id="hevea_default509"></a>
<a id="hevea_default510"></a>
<a id="hevea_default511"></a></p><p>The body of the loop should change the value of one or more variables
so that the condition becomes false eventually and the loop
terminates. Otherwise the loop will repeat forever, which is called
an <span class="c010">infinite loop</span>. An endless source of amusement for computer
scientists is the observation that the directions on shampoo,
&#X201C;Lather, rinse, repeat&#X201D;, are an infinite loop.
<a id="hevea_default512"></a>
<a id="hevea_default513"></a></p><p>In the case of <span class="c004">countdown</span>, we can prove that the loop
terminates: if <span class="c004">n</span> is zero or negative, the loop never runs.
Otherwise, <span class="c004">n</span> gets smaller each time through the
loop, so eventually we have to get to 0.</p><p>For some other loops, it is not so easy to tell. For example:</p><pre class="verbatim">def sequence(n):
    while n != 1:
        print(n)
        if n % 2 == 0:        # n is even
            n = n / 2
        else:                 # n is odd
            n = n*3 + 1
</pre><p>
The condition for this loop is <span class="c004">n != 1</span>, so the loop will continue
until <span class="c004">n</span> is <span class="c004">1</span>, which makes the condition false.</p><p>Each time through the loop, the program outputs the value of <span class="c004">n</span>
and then checks whether it is even or odd. If it is even, <span class="c004">n</span> is
divided by 2. If it is odd, the value of <span class="c004">n</span> is replaced with
<span class="c004">n*3 + 1</span>. For example, if the argument passed to <span class="c004">sequence</span>
is 3, the resulting values of <span class="c004">n</span> are 3, 10, 5, 16, 8, 4, 2, 1.</p><p>Since <span class="c004">n</span> sometimes increases and sometimes decreases, there is no
obvious proof that <span class="c004">n</span> will ever reach 1, or that the program
terminates. For some particular values of <span class="c004">n</span>, we can prove
termination. For example, if the starting value is a power of two,
<span class="c004">n</span> will be even every time through the loop
until it reaches 1. The previous example ends with such a sequence,
starting with 16.
<a id="hevea_default514"></a></p><p>The hard question is whether we can prove that this program terminates
for <em>all</em> positive values of <span class="c004">n</span>. So far, no one has
been able to prove it <em>or</em> disprove it! (See
<a href="http://en.wikipedia.org/wiki/Collatz_conjecture"><span class="c004">http://en.wikipedia.org/wiki/Collatz_conjecture</span></a>.)</p><p>As an exercise, rewrite the function <code class="verb">print_n</code> from
Section&#XA0;<a href="#recursion">5.8</a> using iteration instead of recursion.</p>
<!--TOC section id="sec85" <span class="c004">break</span>-->
<h2 class="section" id="sec85">7.4&#X2003;<span class="c004">break</span></h2><!--SEC END --><p>
<a id="hevea_default515"></a>
<a id="hevea_default516"></a></p><p>Sometimes you don&#X2019;t know it&#X2019;s time to end a loop until you get half
way through the body. In that case you can use the <span class="c004">break</span>
statement to jump out of the loop.</p><p>For example, suppose you want to take input from the user until they
type <span class="c004">done</span>. You could write:</p><pre class="verbatim">while True:
    line = input('&gt; ')
    if line == 'done':
        break
    print(line)

print('Done!')
</pre><p>
The loop condition is <span class="c004">True</span>, which is always true, so the
loop runs until it hits the break statement.</p><p>Each time through, it prompts the user with an angle bracket.
If the user types <span class="c004">done</span>, the <span class="c004">break</span> statement exits
the loop. Otherwise the program echoes whatever the user types
and goes back to the top of the loop. Here&#X2019;s a sample run:</p><pre class="verbatim">&gt; not done
not done
&gt; done
Done!
</pre><p>
This way of writing <span class="c004">while</span> loops is common because you
can check the condition anywhere in the loop (not just at the
top) and you can express the stop condition affirmatively
(&#X201C;stop when this happens&#X201D;) rather than negatively (&#X201C;keep going
until that happens&#X201D;).</p>
<!--TOC section id="sec86" Square roots-->
<h2 class="section" id="sec86">7.5&#X2003;Square roots</h2><!--SEC END --><p>
<a id="squareroot"></a>
<a id="hevea_default517"></a></p><p>Loops are often used in programs that compute
numerical results by starting with an approximate answer and
iteratively improving it.
<a id="hevea_default518"></a></p><p>For example, one way of computing square roots is Newton&#X2019;s method.
Suppose that you want to know the square root of <span class="c009">a</span>. If you start
with almost any estimate, <span class="c009">x</span>, you can compute a better
estimate with the following formula:</p><table class="display dcenter"><tr class="c017"><td class="dcell"><span class="c009">y</span>&#X2004;=&#X2004;</td><td class="dcell"><table class="display"><tr><td class="dcell c011"><span class="c009">x</span>&#X2004;+&#X2004;<span class="c009">a</span>/<span class="c009">x</span></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell c011">2</td></tr>
</table></td><td class="dcell">&#X2004;</td></tr>
</table><p>
For example, if <span class="c009">a</span> is 4 and <span class="c009">x</span> is 3:</p><pre class="verbatim">&gt;&gt;&gt; a = 4
&gt;&gt;&gt; x = 3
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.16666666667
</pre><p>
The result is closer to the correct answer (&#X221A;<span class="c016">4</span> = 2). If we
repeat the process with the new estimate, it gets even closer:</p><pre class="verbatim">&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.00641025641
</pre><p>
After a few more updates, the estimate is almost exact:
<a id="hevea_default519"></a></p><pre class="verbatim">&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.00001024003
&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.00000000003
</pre><p>
In general we don&#X2019;t know ahead of time how many steps it takes
to get to the right answer, but we know when we get there
because the estimate
stops changing:</p><pre class="verbatim">&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.0
&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.0
</pre><p>
When <span class="c004">y == x</span>, we can stop. Here is a loop that starts
with an initial estimate, <span class="c004">x</span>, and improves it until it
stops changing:</p><pre class="verbatim">while True:
    print(x)
    y = (x + a/x) / 2
    if y == x:
        break
    x = y
</pre><p>
For most values of <span class="c004">a</span> this works fine, but in general it is
dangerous to test <span class="c004">float</span> equality.
Floating-point values are only approximately right:
most rational numbers, like 1/3, and irrational numbers, like
&#X221A;<span class="c016">2</span>, can&#X2019;t be represented exactly with a <span class="c004">float</span>.
<a id="hevea_default520"></a>
<a id="hevea_default521"></a></p><p>Rather than checking whether <span class="c004">x</span> and <span class="c004">y</span> are exactly equal, it
is safer to use the built-in function <span class="c004">abs</span> to compute the
absolute value, or magnitude, of the difference between them:</p><pre class="verbatim">    if abs(y-x) &lt; epsilon:
        break
</pre><p>
Where <code class="verb">epsilon</code> has a value like <span class="c004">0.0000001</span> that
determines how close is close enough.</p>
<!--TOC section id="sec87" Algorithms-->
<h2 class="section" id="sec87">7.6&#X2003;Algorithms</h2><!--SEC END --><p>
<a id="hevea_default522"></a></p><p>Newton&#X2019;s method is an example of an <span class="c010">algorithm</span>: it is a
mechanical process for solving a category of problems (in this
case, computing square roots).</p><p>To understand what an algorithm is, it might help to start with
something that is not an algorithm. When you learned to multiply
single-digit numbers, you probably memorized the multiplication table.
In effect, you memorized 100 specific solutions. That kind of
knowledge is not algorithmic.</p><p>But if you were &#X201C;lazy&#X201D;, you might have learned a few
tricks. For example, to find the product of <span class="c009">n</span> and 9, you can
write <span class="c009">n</span>&#X2212;1 as the first digit and 10&#X2212;<span class="c009">n</span> as the second
digit. This trick is a general solution for multiplying any
single-digit number by 9. That&#X2019;s an algorithm!
<a id="hevea_default523"></a>
<a id="hevea_default524"></a>
<a id="hevea_default525"></a>
<a id="hevea_default526"></a></p><p>Similarly, the techniques you learned for addition with carrying,
subtraction with borrowing, and long division are all algorithms. One
of the characteristics of algorithms is that they do not require any
intelligence to carry out. They are mechanical processes where
each step follows from the last according to a simple set of rules.</p><p>Executing algorithms is boring, but designing them is interesting,
intellectually challenging, and a central part of computer science.</p><p>Some of the things that people do naturally, without difficulty or
conscious thought, are the hardest to express algorithmically.
Understanding natural language is a good example. We all do it, but
so far no one has been able to explain <em>how</em> we do it, at least
not in the form of an algorithm.</p>
<!--TOC section id="sec88" Debugging-->
<h2 class="section" id="sec88">7.7&#X2003;Debugging</h2><!--SEC END --><p>
<a id="bisectbug"></a></p><p>As you start writing bigger programs, you might find yourself
spending more time debugging. More code means more chances to
make an error and more places for bugs to hide.
<a id="hevea_default527"></a>
<a id="hevea_default528"></a></p><p>One way to cut your debugging time is &#X201C;debugging by bisection&#X201D;.
For example, if there are 100 lines in your program and you
check them one at a time, it would take 100 steps.</p><p>Instead, try to break the problem in half. Look at the middle
of the program, or near it, for an intermediate value you
can check. Add a <span class="c004">print</span> statement (or something else
that has a verifiable effect) and run the program.</p><p>If the mid-point check is incorrect, there must be a problem in the
first half of the program. If it is correct, the problem is
in the second half.</p><p>Every time you perform a check like this, you halve the number of
lines you have to search. After six steps (which is fewer than 100),
you would be down to one or two lines of code, at least in theory.</p><p>In practice it is not always clear what
the &#X201C;middle of the program&#X201D; is and not always possible to
check it. It doesn&#X2019;t make sense to count lines and find the
exact midpoint. Instead, think about places
in the program where there might be errors and places where it
is easy to put a check. Then choose a spot where you
think the chances are about the same that the bug is before
or after the check.</p>
<!--TOC section id="sec89" Glossary-->
<h2 class="section" id="sec89">7.8&#X2003;Glossary</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c010">reassignment:</span></dt><dd class="dd-description"> Assigning a new value to a variable that
already exists.
<a id="hevea_default529"></a></dd><dt class="dt-description"><span class="c010">update:</span></dt><dd class="dd-description"> An assignment where the new value of the variable
depends on the old.
<a id="hevea_default530"></a></dd><dt class="dt-description"><span class="c010">initialization:</span></dt><dd class="dd-description"> An assignment that gives an initial value to
a variable that will be updated.
<a id="hevea_default531"></a></dd><dt class="dt-description"><span class="c010">increment:</span></dt><dd class="dd-description"> An update that increases the value of a variable
(often by one).
<a id="hevea_default532"></a></dd><dt class="dt-description"><span class="c010">decrement:</span></dt><dd class="dd-description"> An update that decreases the value of a variable.
<a id="hevea_default533"></a></dd><dt class="dt-description"><span class="c010">iteration:</span></dt><dd class="dd-description"> Repeated execution of a set of statements using
either a recursive function call or a loop.
<a id="hevea_default534"></a></dd><dt class="dt-description"><span class="c010">infinite loop:</span></dt><dd class="dd-description"> A loop in which the terminating condition is
never satisfied.
<a id="hevea_default535"></a></dd><dt class="dt-description"><span class="c010">algorithm:</span></dt><dd class="dd-description"> A general process for solving a category of
problems.
<a id="hevea_default536"></a></dd></dl>
<!--TOC section id="sec90" Exercises-->
<h2 class="section" id="sec90">7.9&#X2003;Exercises</h2><!--SEC END --><div class="theorem"><span class="c010">Exercise&#XA0;1</span>&#X2003;
<a id="hevea_default537"></a><p><em>Copy the loop from Section&#XA0;</em><a href="#squareroot"><em>7.5</em></a><em>
and encapsulate it in a function called
</em><code class="verb"><em>mysqrt</em></code><em> that takes <span class="c004">a</span> as a parameter, chooses a
reasonable value of <span class="c004">x</span>, and returns an estimate of the square
root of <span class="c004">a</span>. </em><a id="hevea_default538"></a></p><p><em>To test it, write a function named </em><code class="verb"><em>test_square_root</em></code><em>
that prints a table like this:</em></p><pre class="verbatim"><em>a   mysqrt(a)     math.sqrt(a)  diff
-   ---------     ------------  ----
1.0 1.0           1.0           0.0
2.0 1.41421356237 1.41421356237 2.22044604925e-16
3.0 1.73205080757 1.73205080757 0.0
4.0 2.0           2.0           0.0
5.0 2.2360679775  2.2360679775  0.0
6.0 2.44948974278 2.44948974278 0.0
7.0 2.64575131106 2.64575131106 0.0
8.0 2.82842712475 2.82842712475 4.4408920985e-16
9.0 3.0           3.0           0.0
</em></pre><p><em>
The first column is a number, </em><span class="c009">a</span><em>; the second column is the square
root of </em><span class="c009">a</span><em> computed with </em><code class="verb"><em>mysqrt</em></code><em>; the third column is the
square root computed by <span class="c004">math.sqrt</span>; the fourth column is the
absolute value of the difference between the two estimates.
</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;2</span>&#X2003;
<a id="hevea_default539"></a>
<a id="hevea_default540"></a><p><em>The built-in function <span class="c004">eval</span> takes a string and evaluates
it using the Python interpreter. For example:</em></p><pre class="verbatim"><em>&gt;&gt;&gt; eval('1 + 2 * 3')
7
&gt;&gt;&gt; import math
&gt;&gt;&gt; eval('math.sqrt(5)')
2.2360679774997898
&gt;&gt;&gt; eval('type(math.pi)')
&lt;class 'float'&gt;
</em></pre><p><em>
Write a function called </em><code class="verb"><em>eval_loop</em></code><em> that iteratively
prompts the user, takes the resulting input and evaluates
it using <span class="c004">eval</span>, and prints the result.</em></p><p><em>It should continue until the user enters </em><code class="verb"><em>'done'</em></code><em>, and then
return the value of the last expression it evaluated.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;3</span>&#X2003;
<a id="hevea_default541"></a><p><em>The mathematician Srinivasa Ramanujan found an
infinite series
that can be used to generate a numerical
approximation of </em>1 / &#X3C0;<em>:
</em><a id="hevea_default542"></a></p><table class="display dcenter"><tr class="c017"><td class="dcell"><table class="display"><tr><td class="dcell c011">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell c011">&#X3C0;</td></tr>
</table></td><td class="dcell">&#X2004;=&#X2004;</td><td class="dcell"><table class="display"><tr><td class="dcell c011"><table class="display"><tr class="c017"><td class="dcell">2</td><td class="dcell"><span class="c008">&#X221A;</span></td><td class="dcell"><table class="c002 cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td class="c012">2</td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell c011">9801</td></tr>
</table></td><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell c011">&#X221E;</td></tr>
<tr><td class="dcell c011"><span style="font-size:xx-large">&#X2211;</span></td></tr>
<tr><td class="dcell c011"><span class="c009">k</span>=0</td></tr>
</table></td><td class="dcell">&#X2004;</td><td class="dcell"><table class="display"><tr><td class="dcell c011">(4<span class="c009">k</span>)!(1103+26390<span class="c009">k</span>)</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell c011">(<span class="c009">k</span>!)<sup>4</sup>&#X2004;396<sup>4<span class="c009">k</span></sup></td></tr>
</table></td><td class="dcell">&#X2004;</td></tr>
</table><p><em>Write a function called </em><code class="verb"><em>estimate_pi</em></code><em> that uses this formula
to compute and return an estimate of </em>&#X3C0;<em>. It should use a <span class="c004">while</span>
loop to compute terms of the summation until the last term is
smaller than <span class="c004">1e-15</span> (which is Python notation for </em>10<sup>&#X2212;15</sup><em>).
You can check the result by comparing it to <span class="c004">math.pi</span>.</em></p><p><em>Solution: </em><a href="https://thinkpython.com/code/pi.py"><em><span class="c004">https://thinkpython.com/code/pi.py</span></em></a><em>.</em></p></div>
<!--TOC chapter id="sec91" Strings-->
<h1 class="chapter" id="sec91">Chapter&#XA0;8&#X2003;Strings</h1><!--SEC END --><p>
<a id="strings"></a></p><p>Strings are not like integers, floats, and booleans. A string
is a <span class="c010">sequence</span>, which means it is
an ordered collection of other values. In this chapter you&#X2019;ll see
how to access the characters that make up a string, and you&#X2019;ll
learn about some of the methods strings provide.
<a id="hevea_default543"></a></p>
<!--TOC section id="sec92" A string is a sequence-->
<h2 class="section" id="sec92">8.1&#X2003;A string is a sequence</h2><!--SEC END --><p><a id="hevea_default544"></a>
<a id="hevea_default545"></a>
<a id="hevea_default546"></a>
<a id="hevea_default547"></a>
A string is a sequence of characters.
You can access the characters one at a time with the
bracket operator:</p><pre class="verbatim">&gt;&gt;&gt; fruit = 'banana'
&gt;&gt;&gt; letter = fruit[1]
</pre><p>
The second statement selects character number 1 from <span class="c004">fruit</span> and assigns it to <span class="c004">letter</span>.
<a id="hevea_default548"></a></p><p>The expression in brackets is called an <span class="c010">index</span>.
The index indicates which character in the sequence you
want (hence the name).</p><p>But you might not get what you expect:</p><pre class="verbatim">&gt;&gt;&gt; letter
'a'
</pre><p>
For most people, the first letter of <code class="verb">'banana'</code> is <span class="c004">b</span>, not
<span class="c004">a</span>. But for computer scientists, the index is an offset from the
beginning of the string, and the offset of the first letter is zero.</p><pre class="verbatim">&gt;&gt;&gt; letter = fruit[0]
&gt;&gt;&gt; letter
'b'
</pre><p>
So <span class="c004">b</span> is the 0th letter (&#X201C;zero-eth&#X201D;) of <code class="verb">'banana'</code>, <span class="c004">a</span> is the 1th letter (&#X201C;one-eth&#X201D;), and <span class="c004">n</span> is the 2th letter
(&#X201C;two-eth&#X201D;). <a id="hevea_default549"></a> <a id="hevea_default550"></a></p><p>As an index you can use an expression that contains variables and
operators:
<a id="hevea_default551"></a></p><pre class="verbatim">&gt;&gt;&gt; i = 1
&gt;&gt;&gt; fruit[i]
'a'
&gt;&gt;&gt; fruit[i+1]
'n'
</pre><p>But the value of the index has to be an integer. Otherwise you
get:
<a id="hevea_default552"></a>
<a id="hevea_default553"></a></p><pre class="verbatim">&gt;&gt;&gt; letter = fruit[1.5]
TypeError: string indices must be integers
</pre>
<!--TOC section id="sec93" <span class="c004">len</span>-->
<h2 class="section" id="sec93">8.2&#X2003;<span class="c004">len</span></h2><!--SEC END --><p>
<a id="hevea_default554"></a>
<a id="hevea_default555"></a></p><p><span class="c004">len</span> is a built-in function that returns the number of characters
in a string:</p><pre class="verbatim">&gt;&gt;&gt; fruit = 'banana'
&gt;&gt;&gt; len(fruit)
6
</pre><p>
To get the last letter of a string, you might be tempted to try something
like this:
<a id="hevea_default556"></a>
<a id="hevea_default557"></a></p><pre class="verbatim">&gt;&gt;&gt; length = len(fruit)
&gt;&gt;&gt; last = fruit[length]
IndexError: string index out of range
</pre><p>
The reason for the <span class="c004">IndexError</span> is that there is no letter in <span class="c004">&#X2019;banana&#X2019;</span> with the index 6. Since we started counting at zero, the
six letters are numbered 0 to 5. To get the last character, you have
to subtract 1 from <span class="c004">length</span>:</p><pre class="verbatim">&gt;&gt;&gt; last = fruit[length-1]
&gt;&gt;&gt; last
'a'
</pre><p>
Or you can use negative indices, which count backward from
the end of the string. The expression <span class="c004">fruit[-1]</span> yields the last
letter, <span class="c004">fruit[-2]</span> yields the second to last, and so on.
<a id="hevea_default558"></a>
<a id="hevea_default559"></a></p>
<!--TOC section id="sec94" Traversal with a <span class="c004">for</span> loop-->
<h2 class="section" id="sec94">8.3&#X2003;Traversal with a <span class="c004">for</span> loop</h2><!--SEC END --><p>
<a id="for"></a>
<a id="hevea_default560"></a>
<a id="hevea_default561"></a>
<a id="hevea_default562"></a>
<a id="hevea_default563"></a>
<a id="hevea_default564"></a>
<a id="hevea_default565"></a></p><p>A lot of computations involve processing a string one character at a
time. Often they start at the beginning, select each character in
turn, do something to it, and continue until the end. This pattern of
processing is called a <span class="c010">traversal</span>. One way to write a traversal
is with a <span class="c004">while</span> loop:</p><pre class="verbatim">index = 0
while index &lt; len(fruit):
    letter = fruit[index]
    print(letter)
    index = index + 1
</pre><p>
This loop traverses the string and displays each letter on a line by
itself. The loop condition is <span class="c004">index &lt; len(fruit)</span>, so
when <span class="c004">index</span> is equal to the length of the string, the
condition is false, and the body of the loop doesn&#X2019;t run. The
last character accessed is the one with the index <span class="c004">len(fruit)-1</span>,
which is the last character in the string.</p><p>As an exercise, write a function that takes a string as an argument
and displays the letters backward, one per line.</p><p>Another way to write a traversal is with a <span class="c004">for</span> loop:</p><pre class="verbatim">for letter in fruit:
    print(letter)
</pre><p>
Each time through the loop, the next character in the string is assigned
to the variable <span class="c004">letter</span>. The loop continues until no characters are
left.
<a id="hevea_default566"></a>
<a id="hevea_default567"></a>
<a id="hevea_default568"></a></p><p>The following example shows how to use concatenation (string addition)
and a <span class="c004">for</span> loop to generate an abecedarian series (that is, in
alphabetical order). In Robert McCloskey&#X2019;s book <em>Make
Way for Ducklings</em>, the names of the ducklings are Jack, Kack, Lack,
Mack, Nack, Ouack, Pack, and Quack. This loop outputs these names in
order:</p><pre class="verbatim">prefixes = 'JKLMNOPQ'
suffix = 'ack'

for letter in prefixes:
    print(letter + suffix)
</pre><p>
The output is:</p><pre class="verbatim">Jack
Kack
Lack
Mack
Nack
Oack
Pack
Qack
</pre><p>
Of course, that&#X2019;s not quite right because &#X201C;Ouack&#X201D; and &#X201C;Quack&#X201D; are
misspelled. As an exercise, modify the program to fix this error.</p>
<!--TOC section id="sec95" String slices-->
<h2 class="section" id="sec95">8.4&#X2003;String slices</h2><!--SEC END --><p>
<a id="slice"></a>
<a id="hevea_default569"></a> <a id="hevea_default570"></a> <a id="hevea_default571"></a>
<a id="hevea_default572"></a> <a id="hevea_default573"></a></p><p>A segment of a string is called a <span class="c010">slice</span>. Selecting a slice is
similar to selecting a character:</p><pre class="verbatim">&gt;&gt;&gt; s = 'Monty Python'
&gt;&gt;&gt; s[0:5]
'Monty'
&gt;&gt;&gt; s[6:12]
'Python'
</pre><p>
The operator <span class="c004">[n:m]</span> returns the part of the string from the
&#X201C;n-eth&#X201D; character to the &#X201C;m-eth&#X201D; character, including the first but
excluding the last. This behavior is counterintuitive, but it might
help to imagine the indices pointing <em>between</em> the
characters, as in Figure&#XA0;<a href="#fig.banana">8.1</a>.</p><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2009.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 8.1: Slice indices.</td></tr>
</table></div>
<a id="fig.banana"></a>
<div class="center"><hr class="floatrule"></div></blockquote><p>If you omit the first index (before the colon), the slice starts at
the beginning of the string. If you omit the second index, the slice
goes to the end of the string:</p><pre class="verbatim">&gt;&gt;&gt; fruit = 'banana'
&gt;&gt;&gt; fruit[:3]
'ban'
&gt;&gt;&gt; fruit[3:]
'ana'
</pre><p>
If the first index is greater than or equal to the second the result
is an <span class="c010">empty string</span>, represented by two quotation marks:
<a id="hevea_default574"></a></p><pre class="verbatim">&gt;&gt;&gt; fruit = 'banana'
&gt;&gt;&gt; fruit[3:3]
''
</pre><p>
An empty string contains no characters and has length 0, but other
than that, it is the same as any other string.</p><p>Continuing this example, what do you think
<span class="c004">fruit[:]</span> means? Try it and see.
<a id="hevea_default575"></a>
<a id="hevea_default576"></a></p>
<!--TOC section id="sec96" Strings are immutable-->
<h2 class="section" id="sec96">8.5&#X2003;Strings are immutable</h2><!--SEC END --><p>
<a id="hevea_default577"></a>
<a id="hevea_default578"></a>
<a id="hevea_default579"></a></p><p>It is tempting to use the <span class="c004">[]</span> operator on the left side of an
assignment, with the intention of changing a character in a string.
For example:
<a id="hevea_default580"></a>
<a id="hevea_default581"></a></p><pre class="verbatim">&gt;&gt;&gt; greeting = 'Hello, world!'
&gt;&gt;&gt; greeting[0] = 'J'
TypeError: 'str' object does not support item assignment
</pre><p>
The &#X201C;object&#X201D; in this case is the string and the &#X201C;item&#X201D; is
the character you tried to assign. For now, an object is
the same thing as a value, but we will refine that definition
later (Section&#XA0;<a href="#equivalence">10.10</a>).
<a id="hevea_default582"></a>
<a id="hevea_default583"></a>
<a id="hevea_default584"></a>
<a id="hevea_default585"></a>
<a id="hevea_default586"></a></p><p>The reason for the error is that
strings are <span class="c010">immutable</span>, which means you can&#X2019;t change an
existing string. The best you can do is create a new string
that is a variation on the original:</p><pre class="verbatim">&gt;&gt;&gt; greeting = 'Hello, world!'
&gt;&gt;&gt; new_greeting = 'J' + greeting[1:]
&gt;&gt;&gt; new_greeting
'Jello, world!'
</pre><p>
This example concatenates a new first letter onto
a slice of <span class="c004">greeting</span>. It has no effect on
the original string.
<a id="hevea_default587"></a></p>
<!--TOC section id="sec97" Searching-->
<h2 class="section" id="sec97">8.6&#X2003;Searching</h2><!--SEC END --><p>
<a id="find"></a></p><p>What does the following function do?
<a id="hevea_default588"></a>
<a id="hevea_default589"></a></p><pre class="verbatim">def find(word, letter):
    index = 0
    while index &lt; len(word):
        if word[index] == letter:
            return index
        index = index + 1
    return -1
</pre><p>
In a sense, <span class="c004">find</span> is the inverse of the <span class="c004">[]</span> operator.
Instead of taking an index and extracting the corresponding character,
it takes a character and finds the index where that character
appears. If the character is not found, the function returns <span class="c004">-1</span>.</p><p>This is the first example we have seen of a <span class="c004">return</span> statement
inside a loop. If <span class="c004">word[index] == letter</span>, the function breaks
out of the loop and returns immediately.</p><p>If the character doesn&#X2019;t appear in the string, the program
exits the loop normally and returns <span class="c004">-1</span>.</p><p>This pattern of computation&#X2014;traversing a sequence and returning
when we find what we are looking for&#X2014;is called a <span class="c010">search</span>.
<a id="hevea_default590"></a>
<a id="hevea_default591"></a>
<a id="hevea_default592"></a></p><p>As an exercise, modify <span class="c004">find</span> so that it has a
third parameter, the index in <span class="c004">word</span> where it should start
looking.</p>
<!--TOC section id="sec98" Looping and counting-->
<h2 class="section" id="sec98">8.7&#X2003;Looping and counting</h2><!--SEC END --><p>
<a id="counter"></a>
<a id="hevea_default593"></a>
<a id="hevea_default594"></a>
<a id="hevea_default595"></a>
<a id="hevea_default596"></a></p><p>The following program counts the number of times the letter <span class="c004">a</span>
appears in a string:</p><pre class="verbatim">word = 'banana'
count = 0
for letter in word:
    if letter == 'a':
        count = count + 1
print(count)
</pre><p>
This program demonstrates another pattern of computation called a <span class="c010">counter</span>. The variable <span class="c004">count</span> is initialized to 0 and then
incremented each time an <span class="c004">a</span> is found.
When the loop exits, <span class="c004">count</span>
contains the result&#X2014;the total number of <span class="c004">a</span>&#X2019;s.</p><p><a id="hevea_default597"></a>
As an exercise, encapsulate this code in a function named <span class="c004">count</span>, and generalize it so that it accepts the string and the
letter as arguments.</p><p>Then rewrite the function so that instead of
traversing the string, it uses the three-parameter version of <span class="c004">find</span> from the previous section.</p>
<!--TOC section id="sec99" String methods-->
<h2 class="section" id="sec99">8.8&#X2003;String methods</h2><!--SEC END --><p>
<a id="optional"></a></p><p>Strings provide methods that perform a variety of useful operations.
A method is similar to a function&#X2014;it takes arguments and
returns a value&#X2014;but the syntax is different. For example, the
method <span class="c004">upper</span> takes a string and returns a new string with
all uppercase letters.
<a id="hevea_default598"></a>
<a id="hevea_default599"></a></p><p>Instead of the function syntax <span class="c004">upper(word)</span>, it uses
the method syntax <span class="c004">word.upper()</span>.</p><pre class="verbatim">&gt;&gt;&gt; word = 'banana'
&gt;&gt;&gt; new_word = word.upper()
&gt;&gt;&gt; new_word
'BANANA'
</pre><p>
This form of dot notation specifies the name of the method, <span class="c004">upper</span>, and the name of the string to apply the method to, <span class="c004">word</span>. The empty parentheses indicate that this method takes no
arguments.
<a id="hevea_default600"></a>
<a id="hevea_default601"></a></p><p>A method call is called an <span class="c010">invocation</span>; in this case, we would
say that we are invoking <span class="c004">upper</span> on <span class="c004">word</span>.
<a id="hevea_default602"></a></p><p>As it turns out, there is a string method named <span class="c004">find</span> that
is remarkably similar to the function we wrote:</p><pre class="verbatim">&gt;&gt;&gt; word = 'banana'
&gt;&gt;&gt; index = word.find('a')
&gt;&gt;&gt; index
1
</pre><p>
In this example, we invoke <span class="c004">find</span> on <span class="c004">word</span> and pass
the letter we are looking for as a parameter.</p><p>Actually, the <span class="c004">find</span> method is more general than our function;
it can find substrings, not just characters:</p><pre class="verbatim">&gt;&gt;&gt; word.find('na')
2
</pre><p>
By default, <span class="c004">find</span> starts at the beginning of the string, but
it can take a second argument, the index where it should start:
<a id="hevea_default603"></a>
<a id="hevea_default604"></a></p><pre class="verbatim">&gt;&gt;&gt; word.find('na', 3)
4
</pre><p>
This is an example of an <span class="c010">optional argument</span>;
<span class="c004">find</span> can
also take a third argument, the index where it should stop:</p><pre class="verbatim">&gt;&gt;&gt; name = 'bob'
&gt;&gt;&gt; name.find('b', 1, 2)
-1
</pre><p>
This search fails because <span class="c004">b</span> does not
appear in the index range from <span class="c004">1</span> to <span class="c004">2</span>, not including <span class="c004">2</span>. Searching up to, but not including, the second index makes
<span class="c004">find</span> consistent with the slice operator.</p>
<!--TOC section id="sec100" The <span class="c004">in</span> operator-->
<h2 class="section" id="sec100">8.9&#X2003;The <span class="c004">in</span> operator</h2><!--SEC END --><p>
<a id="inboth"></a>
<a id="hevea_default605"></a>
<a id="hevea_default606"></a>
<a id="hevea_default607"></a>
<a id="hevea_default608"></a></p><p>The word <span class="c004">in</span> is a boolean operator that takes two strings and
returns <span class="c004">True</span> if the first appears as a substring in the second:</p><pre class="verbatim">&gt;&gt;&gt; 'a' in 'banana'
True
&gt;&gt;&gt; 'seed' in 'banana'
False
</pre><p>
For example, the following function prints all the
letters from <span class="c004">word1</span> that also appear in <span class="c004">word2</span>:</p><pre class="verbatim">def in_both(word1, word2):
    for letter in word1:
        if letter in word2:
            print(letter)
</pre><p>
With well-chosen variable names,
Python sometimes reads like English. You could read
this loop, &#X201C;for (each) letter in (the first) word, if (the) letter
(appears) in (the second) word, print (the) letter.&#X201D;</p><p>Here&#X2019;s what you get if you compare apples and oranges:</p><pre class="verbatim">&gt;&gt;&gt; in_both('apples', 'oranges')
a
e
s
</pre>
<!--TOC section id="sec101" String comparison-->
<h2 class="section" id="sec101">8.10&#X2003;String comparison</h2><!--SEC END --><p>
<a id="hevea_default609"></a>
<a id="hevea_default610"></a></p><p>The relational operators work on strings. To see if two strings are equal:</p><pre class="verbatim">if word == 'banana':
    print('All right, bananas.')
</pre><p>
Other relational operations are useful for putting words in alphabetical
order:</p><pre class="verbatim">if word &lt; 'banana':
    print('Your word, ' + word + ', comes before banana.')
elif word &gt; 'banana':
    print('Your word, ' + word + ', comes after banana.')
else:
    print('All right, bananas.')
</pre><p>
Python does not handle uppercase and lowercase letters the same way
people do. All the uppercase letters come before all the
lowercase letters, so:</p><pre class="verbatim">Your word, Pineapple, comes before banana.
</pre><p>
A common way to address this problem is to convert strings to a
standard format, such as all lowercase, before performing the
comparison. Keep that in mind in case you have to defend yourself
against a man armed with a Pineapple.</p>
<!--TOC section id="sec102" Debugging-->
<h2 class="section" id="sec102">8.11&#X2003;Debugging</h2><!--SEC END --><p>
<a id="hevea_default611"></a>
<a id="hevea_default612"></a></p><p>When you use indices to traverse the values in a sequence,
it is tricky to get the beginning and end of the traversal
right. Here is a function that is supposed to compare two
words and return <span class="c004">True</span> if one of the words is the reverse
of the other, but it contains two errors:</p><pre class="verbatim">def is_reverse(word1, word2):
    if len(word1) != len(word2):
        return False

    i = 0
    j = len(word2)

    while j &gt; 0:
        if word1[i] != word2[j]:
            return False
        i = i+1
        j = j-1

    return True
</pre><p>
The first <span class="c004">if</span> statement checks whether the words are the
same length. If not, we can return <span class="c004">False</span> immediately.
Otherwise, for the rest of the function, we can assume that the words
are the same length. This is an example of the guardian pattern
in Section&#XA0;<a href="#guardian">6.8</a>.
<a id="hevea_default613"></a>
<a id="hevea_default614"></a>
<a id="hevea_default615"></a></p><p><span class="c004">i</span> and <span class="c004">j</span> are indices: <span class="c004">i</span> traverses <span class="c004">word1</span>
forward while <span class="c004">j</span> traverses <span class="c004">word2</span> backward. If we find
two letters that don&#X2019;t match, we can return <span class="c004">False</span> immediately.
If we get through the whole loop and all the letters match, we
return <span class="c004">True</span>.</p><p>If we test this function with the words &#X201C;pots&#X201D; and &#X201C;stop&#X201D;, we
expect the return value <span class="c004">True</span>, but we get an IndexError:
<a id="hevea_default616"></a>
<a id="hevea_default617"></a></p><pre class="verbatim">&gt;&gt;&gt; is_reverse('pots', 'stop')
...
  File "reverse.py", line 15, in is_reverse
    if word1[i] != word2[j]:
IndexError: string index out of range
</pre><p>
For debugging this kind of error, my first move is to
print the values of the indices immediately before the line
where the error appears.</p><pre class="verbatim">    while j &gt; 0:
        print(i, j)        # print here

        if word1[i] != word2[j]:
            return False
        i = i+1
        j = j-1
</pre><p>
Now when I run the program again, I get more information:</p><pre class="verbatim">&gt;&gt;&gt; is_reverse('pots', 'stop')
0 4
...
IndexError: string index out of range
</pre><p>
The first time through the loop, the value of <span class="c004">j</span> is 4,
which is out of range for the string <code class="verb">'pots'</code>.
The index of the last character is 3, so the
initial value for <span class="c004">j</span> should be <span class="c004">len(word2)-1</span>.</p><p>If I fix that error and run the program again, I get:</p><pre class="verbatim">&gt;&gt;&gt; is_reverse('pots', 'stop')
0 3
1 2
2 1
True
</pre><p>
This time we get the right answer, but it looks like the loop only ran
three times, which is suspicious. To get a better idea of what is
happening, it is useful to draw a state diagram. During the first
iteration, the frame for <code class="verb">is_reverse</code> is shown in
Figure&#XA0;<a href="#fig.state4">8.2</a>. <a id="hevea_default618"></a> <a id="hevea_default619"></a></p><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2010.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 8.2: State diagram.</td></tr>
</table></div>
<a id="fig.state4"></a>
<div class="center"><hr class="floatrule"></div></blockquote><p>I took some license by arranging the variables in the frame
and adding dotted lines to show that the values of <span class="c004">i</span> and
<span class="c004">j</span> indicate characters in <span class="c004">word1</span> and <span class="c004">word2</span>.</p><p>Starting with this diagram, run the program on paper, changing the
values of <span class="c004">i</span> and <span class="c004">j</span> during each iteration. Find and fix the
second error in this function.
<a id="isreverse"></a></p>
<!--TOC section id="sec103" Glossary-->
<h2 class="section" id="sec103">8.12&#X2003;Glossary</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c010">object:</span></dt><dd class="dd-description"> Something a variable can refer to. For now,
you can use &#X201C;object&#X201D; and &#X201C;value&#X201D; interchangeably.
<a id="hevea_default620"></a></dd><dt class="dt-description"><span class="c010">sequence:</span></dt><dd class="dd-description"> An ordered collection of
values where each value is identified by an integer index.
<a id="hevea_default621"></a></dd><dt class="dt-description"><span class="c010">item:</span></dt><dd class="dd-description"> One of the values in a sequence.
<a id="hevea_default622"></a></dd><dt class="dt-description"><span class="c010">index:</span></dt><dd class="dd-description"> An integer value used to select an item in
a sequence, such as a character in a string. In Python
indices start from 0.
<a id="hevea_default623"></a></dd><dt class="dt-description"><span class="c010">slice:</span></dt><dd class="dd-description"> A part of a string specified by a range of indices.
<a id="hevea_default624"></a></dd><dt class="dt-description"><span class="c010">empty string:</span></dt><dd class="dd-description"> A string with no characters and length 0, represented
by two quotation marks.
<a id="hevea_default625"></a></dd><dt class="dt-description"><span class="c010">immutable:</span></dt><dd class="dd-description"> The property of a sequence whose items cannot
be changed.
<a id="hevea_default626"></a></dd><dt class="dt-description"><span class="c010">traverse:</span></dt><dd class="dd-description"> To iterate through the items in a sequence,
performing a similar operation on each.
<a id="hevea_default627"></a></dd><dt class="dt-description"><span class="c010">search:</span></dt><dd class="dd-description"> A pattern of traversal that stops
when it finds what it is looking for.
<a id="hevea_default628"></a>
<a id="hevea_default629"></a></dd><dt class="dt-description"><span class="c010">counter:</span></dt><dd class="dd-description"> A variable used to count something, usually initialized
to zero and then incremented.
<a id="hevea_default630"></a></dd><dt class="dt-description"><span class="c010">invocation:</span></dt><dd class="dd-description"> A statement that calls a method.
<a id="hevea_default631"></a></dd><dt class="dt-description"><span class="c010">optional argument:</span></dt><dd class="dd-description"> A function or method argument that is not
required.
<a id="hevea_default632"></a>
<a id="hevea_default633"></a></dd></dl>
<!--TOC section id="sec104" Exercises-->
<h2 class="section" id="sec104">8.13&#X2003;Exercises</h2><!--SEC END --><div class="theorem"><span class="c010">Exercise&#XA0;1</span>&#X2003;
<a id="hevea_default634"></a>
<a id="hevea_default635"></a><p><em>Read the documentation of the string methods at
</em><a href="http://docs.python.org/3/library/stdtypes.html#string-methods"><span class="c004"><em>http://docs.python.org/3/library/stdtypes.html#string-methods</em></span></a><em>.
You might want to experiment with some of them to make sure you
understand how they work. <span class="c004">strip</span> and <span class="c004">replace</span> are
particularly useful.</em></p><p><em>The documentation uses a syntax that might be confusing.
For example, in </em><code class="verb"><em>find(sub[, start[, end]])</em></code><em>, the brackets
indicate optional arguments. So <span class="c004">sub</span> is required, but
<span class="c004">start</span> is optional, and if you include <span class="c004">start</span>,
then <span class="c004">end</span> is optional.
</em><a id="hevea_default636"></a>
<a id="hevea_default637"></a></p></div><div class="theorem"><span class="c010">Exercise&#XA0;2</span>&#X2003;
<a id="hevea_default638"></a>
<a id="hevea_default639"></a><p><em>There is a string method called <span class="c004">count</span> that is similar
to the function in Section&#XA0;</em><a href="#counter"><em>8.7</em></a><em>. Read the documentation
of this method
and write an invocation that counts the number of <span class="c004">a</span>&#X2019;s
in </em><code class="verb"><em>'banana'</em></code><em>.
</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;3</span>&#X2003;
<a id="hevea_default640"></a>
<a id="hevea_default641"></a>
<a id="hevea_default642"></a><p><em>A string slice can take a third index that specifies the &#X201C;step
size&#X201D;; that is, the number of spaces between successive characters.
A step size of 2 means every other character; 3 means every third,
etc.</em></p><pre class="verbatim"><em>&gt;&gt;&gt; fruit = 'banana'
&gt;&gt;&gt; fruit[0:5:2]
'bnn'
</em></pre><p><em>A step size of -1 goes through the word backwards, so
the slice </em><code class="verb"><em>[::-1]</em></code><em> generates a reversed string.
</em><a id="hevea_default643"></a></p><p><em>Use this idiom to write a one-line version of </em><code class="verb"><em>is_palindrome</em></code><em>
from Exercise&#XA0;</em><a href="#palindrome"><em>3</em></a><em>.
</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;4</span>&#X2003;<p><em>The following functions are all </em>intended<em> to check whether a
string contains any lowercase letters, but at least some of them are
wrong. For each function, describe what the function actually does
(assuming that the parameter is a string).</em></p><pre class="verbatim"><em>def any_lowercase1(s):
    for c in s:
        if c.islower():
            return True
        else:
            return False

def any_lowercase2(s):
    for c in s:
        if 'c'.islower():
            return 'True'
        else:
            return 'False'

def any_lowercase3(s):
    for c in s:
        flag = c.islower()
    return flag

def any_lowercase4(s):
    flag = False
    for c in s:
        flag = flag or c.islower()
    return flag

def any_lowercase5(s):
    for c in s:
        if not c.islower():
            return False
    return True
</em></pre></div><div class="theorem"><span class="c010">Exercise&#XA0;5</span>&#X2003;
<a id="hevea_default644"></a>
<a id="hevea_default645"></a><p><a id="exrotate"></a><em>
A Caesar cypher is a weak form of encryption that involves &#X201C;rotating&#X201D; each
letter by a fixed number of places. To rotate a letter means
to shift it through the alphabet, wrapping around to the beginning if
necessary, so &#X2019;A&#X2019; rotated by 3 is &#X2019;D&#X2019; and &#X2019;Z&#X2019; rotated by 1 is &#X2019;A&#X2019;.</em></p><p><em>To rotate a word, rotate each letter by the same amount.
For example, &#X201C;cheer&#X201D; rotated by 7 is &#X201C;jolly&#X201D; and &#X201C;melon&#X201D; rotated
by -10 is &#X201C;cubed&#X201D;. In the movie </em>2001: A Space Odyssey<em>, the
ship computer is called HAL, which is IBM rotated by -1.</em></p><p><em>Write a function called </em><code class="verb"><em>rotate_word</em></code><em>
that takes a string and an integer as parameters, and returns
a new string that contains the letters from the original string
rotated by the given amount.</em></p><p><em>You might want to use the built-in function <span class="c004">ord</span>, which converts
a character to a numeric code, and <span class="c004">chr</span>, which converts numeric
codes to characters. Letters of the alphabet are encoded in alphabetical
order, so for example:</em></p><pre class="verbatim"><em>&gt;&gt;&gt; ord('c') - ord('a')
2
</em></pre><p><em>Because </em><code class="verb"><em>'c'</em></code><em> is the two-eth letter of the alphabet. But
beware: the numeric codes for upper case letters are different.</em></p><p><em>Potentially offensive jokes on the Internet are sometimes encoded in
ROT13, which is a Caesar cypher with rotation 13. If you are not
easily offended, find and decode some of them. Solution:
</em><a href="https://thinkpython.com/code/rotate.py"><em><span class="c004">https://thinkpython.com/code/rotate.py</span></em></a><em>.</em></p></div>
<!--TOC chapter id="sec105" Case study: word play-->
<h1 class="chapter" id="sec105">Chapter&#XA0;9&#X2003;Case study: word play</h1><!--SEC END --><p>
<a id="wordplay"></a></p><p>This chapter presents the second case study, which involves
solving word puzzles by searching for words that have certain
properties. For example, we&#X2019;ll find the longest palindromes
in English and search for words whose letters appear in
alphabetical order. And I will present another program development
plan: reduction to a previously solved problem.</p>
<!--TOC section id="sec106" Reading word lists-->
<h2 class="section" id="sec106">9.1&#X2003;Reading word lists</h2><!--SEC END --><p>
<a id="wordlist"></a></p><p>For the exercises in this chapter we need a list of English words.
There are lots of word lists available on the Web, but the one most
suitable for our purpose is one of the word lists collected and
contributed to the public domain by Grady Ward as part of the Moby
lexicon project (see <a href="http://wikipedia.org/wiki/Moby_Project"><span class="c004">http://wikipedia.org/wiki/Moby_Project</span></a>). It
is a list of 113,809 official crosswords; that is, words that are
considered valid in crossword puzzles and other word games. In the
Moby collection, the filename is <span class="c004">113809of.fic</span>; you can download
a copy, with the simpler name <span class="c004">words.txt</span>, from
<a href="https://thinkpython.com/code/words.txt"><span class="c004">https://thinkpython.com/code/words.txt</span></a>.
<a id="hevea_default646"></a>
<a id="hevea_default647"></a></p><p>This file is in plain text, so you can open it with a text
editor, but you can also read it from Python. The built-in
function <span class="c004">open</span> takes the name of the file as a parameter
and returns a <span class="c010">file object</span> you can use to read the file.
<a id="hevea_default648"></a>
<a id="hevea_default649"></a>
<a id="hevea_default650"></a>
<a id="hevea_default651"></a>
<a id="hevea_default652"></a>
<a id="hevea_default653"></a></p><pre class="verbatim">&gt;&gt;&gt; fin = open('words.txt')
</pre><p>
<span class="c004">fin</span> is a common name for a file object used for input. The file
object provides several methods for reading, including <span class="c004">readline</span>,
which reads characters from the file until it gets to a newline and
returns the result as a string: <a id="hevea_default654"></a>
<a id="hevea_default655"></a></p><pre class="verbatim">&gt;&gt;&gt; fin.readline()
'aa\n'
</pre><p>
The first word in this particular list is &#X201C;aa&#X201D;, which is a kind of
lava. The sequence <code class="verb">\n</code> represents the newline character that
separates this word from the next.</p><p>The file object keeps track of where it is in the file, so
if you call <span class="c004">readline</span> again, you get the next word:</p><pre class="verbatim">&gt;&gt;&gt; fin.readline()
'aah\n'
</pre><p>
The next word is &#X201C;aah&#X201D;, which is a perfectly legitimate
word, so stop looking at me like that.
Or, if it&#X2019;s the newline character that&#X2019;s bothering you,
we can get rid of it with the string method <span class="c004">strip</span>:
<a id="hevea_default656"></a>
<a id="hevea_default657"></a></p><pre class="verbatim">&gt;&gt;&gt; line = fin.readline()
&gt;&gt;&gt; word = line.strip()
&gt;&gt;&gt; word
'aahed'
</pre><p>
You can also use a file object as part of a <span class="c004">for</span> loop.
This program reads <span class="c004">words.txt</span> and prints each word, one
per line:
<a id="hevea_default658"></a>
<a id="hevea_default659"></a></p><pre class="verbatim">fin = open('words.txt')
for line in fin:
    word = line.strip()
    print(word)
</pre>
<!--TOC section id="sec107" Exercises-->
<h2 class="section" id="sec107">9.2&#X2003;Exercises</h2><!--SEC END --><p>There are solutions to these exercises in the next section.
You should at least attempt each one before you read the solutions.</p><div class="theorem"><span class="c010">Exercise&#XA0;1</span>&#X2003;<em>
Write a program that reads <span class="c004">words.txt</span> and prints only the
words with more than 20 characters (not counting whitespace).
</em><a id="hevea_default660"></a></div><div class="theorem"><span class="c010">Exercise&#XA0;2</span>&#X2003;<p><em>In 1939 Ernest Vincent Wright published a 50,000 word novel called
</em>Gadsby<em> that does not contain the letter &#X201C;e&#X201D;. Since &#X201C;e&#X201D; is
the most common letter in English, that&#X2019;s not easy to do.</em></p><p><em>In fact, it is difficult to construct a solitary thought without using
that most common symbol. It is slow going at first, but with caution
and hours of training you can gradually gain facility.</em></p><p><em>All right, I&#X2019;ll stop now.</em></p><p><em>Write a function called </em><code class="verb"><em>has_no_e</em></code><em> that returns <span class="c004">True</span> if
the given word doesn&#X2019;t have the letter &#X201C;e&#X201D; in it.</em></p><p><em>Write a program that reads <span class="c004">words.txt</span> and prints only the words
that have no &#X201C;e&#X201D;. Compute the percentage of words in the list
that have no &#X201C;e&#X201D;.
</em><a id="hevea_default661"></a></p></div><div class="theorem"><span class="c010">Exercise&#XA0;3</span>&#X2003;<p><em>Write a function named <span class="c004">avoids</span>
that takes a word and a string of forbidden letters, and
that returns <span class="c004">True</span> if the word doesn&#X2019;t use any of the forbidden
letters.</em></p><p><em>Write a program that prompts the user to enter a string
of forbidden letters and then prints the number of words that
don&#X2019;t contain any of them.
Can you find a combination of 5 forbidden letters that
excludes the smallest number of words?</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;4</span>&#X2003;<p><em>Write a function named </em><code class="verb"><em>uses_only</em></code><em> that takes a word and a
string of letters, and that returns <span class="c004">True</span> if the word contains
only letters in the list. Can you make a sentence using only the
letters <span class="c004">acefhlo</span>? Other than &#X201C;Hoe alfalfa&#X201D;?</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;5</span>&#X2003;<p><em>Write a function named </em><code class="verb"><em>uses_all</em></code><em> that takes a word and a
string of required letters, and that returns <span class="c004">True</span> if the word
uses all the required letters at least once. How many words are there
that use all the vowels <span class="c004">aeiou</span>? How about <span class="c004">aeiouy</span>?</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;6</span>&#X2003;<p><em>Write a function called </em><code class="verb"><em>is_abecedarian</em></code><em> that returns
<span class="c004">True</span> if the letters in a word appear in alphabetical order
(double letters are ok).
How many abecedarian words are there?</em></p><p><a id="hevea_default662"></a></p></div>
<!--TOC section id="sec108" Search-->
<h2 class="section" id="sec108">9.3&#X2003;Search</h2><!--SEC END --><p>
<a id="search"></a>
<a id="hevea_default663"></a>
<a id="hevea_default664"></a></p><p>All of the exercises in the previous section have something
in common; they can be solved with the search pattern we saw
in Section&#XA0;<a href="#find">8.6</a>. The simplest example is:</p><pre class="verbatim">def has_no_e(word):
    for letter in word:
        if letter == 'e':
            return False
    return True
</pre><p>
The <span class="c004">for</span> loop traverses the characters in <span class="c004">word</span>. If we find
the letter &#X201C;e&#X201D;, we can immediately return <span class="c004">False</span>; otherwise we
have to go to the next letter. If we exit the loop normally, that
means we didn&#X2019;t find an &#X201C;e&#X201D;, so we return <span class="c004">True</span>.
<a id="hevea_default665"></a></p><p><a id="hevea_default666"></a>
<a id="hevea_default667"></a>
You could write this function more concisely using the <span class="c004">in</span>
operator, but I started with this version because it
demonstrates the logic of the search pattern.</p><p><a id="hevea_default668"></a>
<span class="c004">avoids</span> is a more general version of <code class="verb">has_no_e</code> but it
has the same structure:</p><pre class="verbatim">def avoids(word, forbidden):
    for letter in word:
        if letter in forbidden:
            return False
    return True
</pre><p>
We can return <span class="c004">False</span> as soon as we find a forbidden letter;
if we get to the end of the loop, we return <span class="c004">True</span>.</p><p><code class="verb">uses_only</code> is similar except that the sense of the condition
is reversed:</p><pre class="verbatim">def uses_only(word, available):
    for letter in word:
        if letter not in available:
            return False
    return True
</pre><p>
Instead of a list of forbidden letters, we have a list of available
letters. If we find a letter in <span class="c004">word</span> that is not in
<span class="c004">available</span>, we can return <span class="c004">False</span>.</p><p><code class="verb">uses_all</code> is similar except that we reverse the role
of the word and the string of letters:</p><pre class="verbatim">def uses_all(word, required):
    for letter in required:
        if letter not in word:
            return False
    return True
</pre><p>
Instead of traversing the letters in <span class="c004">word</span>, the loop
traverses the required letters. If any of the required letters
do not appear in the word, we can return <span class="c004">False</span>.
<a id="hevea_default669"></a></p><p>If you were really thinking like a computer scientist, you would
have recognized that <code class="verb">uses_all</code> was an instance of a
previously solved problem, and you would have written:</p><pre class="verbatim">def uses_all(word, required):
    return uses_only(required, word)
</pre><p>
This is an example of a program development plan called <span class="c010">reduction to a previously solved problem</span>, which means that you
recognize the problem you are working on as an instance of a solved
problem and apply an existing solution. <a id="hevea_default670"></a> <a id="hevea_default671"></a></p>
<!--TOC section id="sec109" Looping with indices-->
<h2 class="section" id="sec109">9.4&#X2003;Looping with indices</h2><!--SEC END --><p>
<a id="hevea_default672"></a>
<a id="hevea_default673"></a></p><p>I wrote the functions in the previous section with <span class="c004">for</span>
loops because I only needed the characters in the strings; I didn&#X2019;t
have to do anything with the indices.</p><p>For <code class="verb">is_abecedarian</code> we have to compare adjacent letters,
which is a little tricky with a <span class="c004">for</span> loop:</p><pre class="verbatim">def is_abecedarian(word):
    previous = word[0]
    for c in word:
        if c &lt; previous:
            return False
        previous = c
    return True
</pre><p>An alternative is to use recursion:</p><pre class="verbatim">def is_abecedarian(word):
    if len(word) &lt;= 1:
        return True
    if word[0] &gt; word[1]:
        return False
    return is_abecedarian(word[1:])
</pre><p>Another option is to use a <span class="c004">while</span> loop:</p><pre class="verbatim">def is_abecedarian(word):
    i = 0
    while i &lt; len(word)-1:
        if word[i+1] &lt; word[i]:
            return False
        i = i+1
    return True
</pre><p>
The loop starts at <span class="c004">i=0</span> and ends when <span class="c004">i=len(word)-1</span>. Each
time through the loop, it compares the <span class="c009">i</span>th character (which you can
think of as the current character) to the <span class="c009">i</span>+1th character (which you
can think of as the next).</p><p>If the next character is less than (alphabetically before) the current
one, then we have discovered a break in the abecedarian trend, and
we return <span class="c004">False</span>.</p><p>If we get to the end of the loop without finding a fault, then the
word passes the test. To convince yourself that the loop ends
correctly, consider an example like <code class="verb">'flossy'</code>. The
length of the word is 6, so
the last time the loop runs is when <span class="c004">i</span> is 4, which is the
index of the second-to-last character. On the last iteration,
it compares the second-to-last character to the last, which is
what we want.
<a id="hevea_default674"></a></p><p>Here is a version of <code class="verb">is_palindrome</code> (see
Exercise&#XA0;<a href="#palindrome">3</a>) that uses two indices; one starts at the
beginning and goes up; the other starts at the end and goes down.</p><pre class="verbatim">def is_palindrome(word):
    i = 0
    j = len(word)-1

    while i&lt;j:
        if word[i] != word[j]:
            return False
        i = i+1
        j = j-1

    return True
</pre><p>Or we could reduce to a previously solved
problem and write:
<a id="hevea_default675"></a>
<a id="hevea_default676"></a></p><pre class="verbatim">def is_palindrome(word):
    return is_reverse(word, word)
</pre><p>
Using <code class="verb">is_reverse</code> from Section&#XA0;<a href="#isreverse">8.11</a>.</p>
<!--TOC section id="sec110" Debugging-->
<h2 class="section" id="sec110">9.5&#X2003;Debugging</h2><!--SEC END --><p>
<a id="hevea_default677"></a>
<a id="hevea_default678"></a>
<a id="hevea_default679"></a></p><p>Testing programs is hard. The functions in this chapter are
relatively easy to test because you can check the results by hand.
Even so, it is somewhere between difficult and impossible to choose a
set of words that test for all possible errors.</p><p>Taking <code class="verb">has_no_e</code> as an example, there are two obvious
cases to check: words that have an &#X2018;e&#X2019; should return <span class="c004">False</span>, and
words that don&#X2019;t should return <span class="c004">True</span>. You should have no
trouble coming up with one of each.</p><p>Within each case, there are some less obvious subcases. Among the
words that have an &#X201C;e&#X201D;, you should test words with an &#X201C;e&#X201D; at the
beginning, the end, and somewhere in the middle. You should test long
words, short words, and very short words, like the empty string. The
empty string is an example of a <span class="c010">special case</span>, which is one of
the non-obvious cases where errors often lurk.
<a id="hevea_default680"></a></p><p>In addition to the test cases you generate, you can also test
your program with a word list like <span class="c004">words.txt</span>. By scanning
the output, you might be able to catch errors, but be careful:
you might catch one kind of error (words that should not be
included, but are) and not another (words that should be included,
but aren&#X2019;t).</p><p>In general, testing can help you find bugs, but it is not easy to
generate a good set of test cases, and even if you do, you can&#X2019;t
be sure your program is correct.
According to a legendary computer scientist:
<a id="hevea_default681"></a></p><blockquote class="quote">
Program testing can be used to show the presence of bugs, but never to
show their absence!<p>&#X2014; Edsger W. Dijkstra
</p></blockquote><p>
<a id="hevea_default682"></a></p>
<!--TOC section id="sec111" Glossary-->
<h2 class="section" id="sec111">9.6&#X2003;Glossary</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c010">file object:</span></dt><dd class="dd-description"> A value that represents an open file.
<a id="hevea_default683"></a>
<a id="hevea_default684"></a></dd><dt class="dt-description"><span class="c010">reduction to a previously solved problem:</span></dt><dd class="dd-description"> A way of solving a
problem by expressing it as an instance of a previously solved
problem. <a id="hevea_default685"></a>
<a id="hevea_default686"></a></dd><dt class="dt-description"><span class="c010">special case:</span></dt><dd class="dd-description"> A test case that is atypical or non-obvious
(and less likely to be handled correctly).
<a id="hevea_default687"></a></dd></dl>
<!--TOC section id="sec112" Exercises-->
<h2 class="section" id="sec112">9.7&#X2003;Exercises</h2><!--SEC END --><div class="theorem"><span class="c010">Exercise&#XA0;7</span>&#X2003;
<a id="hevea_default688"></a>
<a id="hevea_default689"></a>
<a id="hevea_default690"></a><p><em>This question is based on a Puzzler that was broadcast on the radio
program </em>Car Talk<em>
(</em><a href="http://www.cartalk.com/content/puzzlers"><em><span class="c004">http://www.cartalk.com/content/puzzlers</span></em></a><em>):</em></p><blockquote class="quote"><em>
Give me a word with three consecutive double letters. I&#X2019;ll give you a
couple of words that almost qualify, but don&#X2019;t. For example, the word
committee, c-o-m-m-i-t-t-e-e. It would be great except for the &#X2018;i&#X2019; that
sneaks in there. Or Mississippi: M-i-s-s-i-s-s-i-p-p-i. If you could
take out those i&#X2019;s it would work. But there is a word that has three
consecutive pairs of letters and to the best of my knowledge this may
be the only word. Of course there are probably 500 more but I can only
think of one. What is the word?
</em></blockquote><p><em>Write a program to find it.
Solution: </em><a href="https://thinkpython.com/code/cartalk1.py"><em><span class="c004">https://thinkpython.com/code/cartalk1.py</span></em></a><em>.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;8</span>&#X2003;<em>
Here&#X2019;s another </em>Car Talk<em>
Puzzler (</em><a href="http://www.cartalk.com/content/puzzlers"><span class="c004"><em>http://www.cartalk.com/content/puzzlers</em></span></a><em>):
</em><a id="hevea_default691"></a>
<a id="hevea_default692"></a>
<a id="hevea_default693"></a>
<a id="hevea_default694"></a><blockquote class="quote"><em>
&#X201C;I was driving on the highway the other day and I happened to
notice my odometer. Like most odometers, it shows six digits,
in whole miles only. So, if my car had 300,000
miles, for example, I&#X2019;d see 3-0-0-0-0-0.</em><p><em>&#X201C;Now, what I saw that day was very interesting. I noticed that the
last 4 digits were palindromic; that is, they read the same forward as
backward. For example, 5-4-4-5 is a palindrome, so my odometer
could have read 3-1-5-4-4-5.</em></p><p><em>&#X201C;One mile later, the last 5 numbers were palindromic. For example, it
could have read 3-6-5-4-5-6. One mile after that, the middle 4 out of
6 numbers were palindromic. And you ready for this? One mile later,
all 6 were palindromic!</em></p><p><em>&#X201C;The question is, what was on the odometer when I first looked?&#X201D;
</em></p></blockquote><p><em>Write a Python program that tests all the six-digit numbers and prints
any numbers that satisfy these requirements.
Solution: </em><a href="https://thinkpython.com/code/cartalk2.py"><em><span class="c004">https://thinkpython.com/code/cartalk2.py</span></em></a><em>.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;9</span>&#X2003;<em>
Here&#X2019;s another </em>Car Talk<em> Puzzler you can solve with a
search (</em><a href="http://www.cartalk.com/content/puzzlers"><span class="c004"><em>http://www.cartalk.com/content/puzzlers</em></span></a><em>):
</em><a id="hevea_default695"></a>
<a id="hevea_default696"></a>
<a id="hevea_default697"></a><blockquote class="quote"><em>
&#X201C;Recently I had a visit with my mom and we realized that
the two digits that make up my age when reversed resulted in her
age. For example, if she&#X2019;s 73, I&#X2019;m 37. We wondered how often this has
happened over the years but we got sidetracked with other topics and
we never came up with an answer.</em><p><em>&#X201C;When I got home I figured out that the digits of our ages have been
reversible six times so far. I also figured out that if we&#X2019;re lucky it
would happen again in a few years, and if we&#X2019;re really lucky it would
happen one more time after that. In other words, it would have
happened 8 times over all. So the question is, how old am I now?&#X201D;</em></p></blockquote><p><em>Write a Python program that searches for solutions to this Puzzler.
Hint: you might find the string method <span class="c004">zfill</span> useful.</em></p><p><em>Solution: </em><a href="https://thinkpython.com/code/cartalk3.py"><em><span class="c004">https://thinkpython.com/code/cartalk3.py</span></em></a><em>.</em></p></div>
<!--TOC chapter id="sec113" Lists-->
<h1 class="chapter" id="sec113">Chapter&#XA0;10&#X2003;Lists</h1><!--SEC END --><p>This chapter presents one of Python&#X2019;s most useful built-in types, lists.
You will also learn more about objects and what can happen when you have
more than one name for the same object.</p>
<!--TOC section id="sec114" A list is a sequence-->
<h2 class="section" id="sec114">10.1&#X2003;A list is a sequence</h2><!--SEC END --><p>
<a id="sequence"></a></p><p>Like a string, a <span class="c010">list</span> is a sequence of values. In a string, the
values are characters; in a list, they can be any type. The values in
a list are called <span class="c010">elements</span> or sometimes <span class="c010">items</span>.
<a id="hevea_default698"></a>
<a id="hevea_default699"></a>
<a id="hevea_default700"></a>
<a id="hevea_default701"></a>
<a id="hevea_default702"></a></p><p>There are several ways to create a new list; the simplest is to
enclose the elements in square brackets (<code class="verb">[</code> and <code class="verb">]</code>):</p><pre class="verbatim">[10, 20, 30, 40]
['crunchy frog', 'ram bladder', 'lark vomit']
</pre><p>
The first example is a list of four integers. The second is a list of
three strings. The elements of a list don&#X2019;t have to be the same type.
The following list contains a string, a float, an integer, and
(lo!) another list:</p><pre class="verbatim">['spam', 2.0, 5, [10, 20]]
</pre><p>
A list within another list is <span class="c010">nested</span>.
<a id="hevea_default703"></a>
<a id="hevea_default704"></a></p><p>A list that contains no elements is
called an empty list; you can create one with empty
brackets, <code class="verb">[]</code>.
<a id="hevea_default705"></a>
<a id="hevea_default706"></a></p><p>As you might expect, you can assign list values to variables:</p><pre class="verbatim">&gt;&gt;&gt; cheeses = ['Cheddar', 'Edam', 'Gouda']
&gt;&gt;&gt; numbers = [42, 123]
&gt;&gt;&gt; empty = []
&gt;&gt;&gt; print(cheeses, numbers, empty)
['Cheddar', 'Edam', 'Gouda'] [42, 123] []
</pre><p>
<a id="hevea_default707"></a></p>
<!--TOC section id="sec115" Lists are mutable-->
<h2 class="section" id="sec115">10.2&#X2003;Lists are mutable</h2><!--SEC END --><p>
<a id="mutable"></a>
<a id="hevea_default708"></a>
<a id="hevea_default709"></a>
<a id="hevea_default710"></a>
<a id="hevea_default711"></a>
<a id="hevea_default712"></a></p><p>The syntax for accessing the elements of a list is the same as for
accessing the characters of a string&#X2014;the bracket operator. The
expression inside the brackets specifies the index. Remember that the
indices start at 0:</p><pre class="verbatim">&gt;&gt;&gt; cheeses[0]
'Cheddar'
</pre><p>
Unlike strings, lists are mutable. When the bracket operator appears
on the left side of an assignment, it identifies the element of the
list that will be assigned.
<a id="hevea_default713"></a></p><pre class="verbatim">&gt;&gt;&gt; numbers = [42, 123]
&gt;&gt;&gt; numbers[1] = 5
&gt;&gt;&gt; numbers
[42, 5]
</pre><p>
The one-eth element of <span class="c004">numbers</span>, which
used to be 123, is now 5.
<a id="hevea_default714"></a>
<a id="hevea_default715"></a></p><p>Figure&#XA0;<a href="#fig.liststate">10.1</a> shows
the state diagram for <span class="c004">cheeses</span>, <span class="c004">numbers</span> and <span class="c004">empty</span>.
<a id="hevea_default716"></a>
<a id="hevea_default717"></a></p><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2011.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 10.1: State diagram.</td></tr>
</table></div>
<a id="fig.liststate"></a>
<div class="center"><hr class="floatrule"></div></blockquote><p>Lists are represented by boxes with the word &#X201C;list&#X201D; outside
and the elements of the list inside. <span class="c004">cheeses</span> refers to
a list with three elements indexed 0, 1 and 2.
<span class="c004">numbers</span> contains two elements; the diagram shows that the
value of the second element has been reassigned from 123 to 5.
<span class="c004">empty</span> refers to a list with no elements.
<a id="hevea_default718"></a>
<a id="hevea_default719"></a>
<a id="hevea_default720"></a></p><p>List indices work the same way as string indices:</p><ul class="itemize"><li class="li-itemize">Any integer expression can be used as an index.</li><li class="li-itemize">If you try to read or write an element that does not exist, you
get an <span class="c004">IndexError</span>.
<a id="hevea_default721"></a>
<a id="hevea_default722"></a></li><li class="li-itemize">If an index has a negative value, it counts backward from the
end of the list.</li></ul><p>
<a id="hevea_default723"></a></p><p><a id="hevea_default724"></a>
<a id="hevea_default725"></a>
<a id="hevea_default726"></a>
<a id="hevea_default727"></a></p><p>The <span class="c004">in</span> operator also works on lists.</p><pre class="verbatim">&gt;&gt;&gt; cheeses = ['Cheddar', 'Edam', 'Gouda']
&gt;&gt;&gt; 'Edam' in cheeses
True
&gt;&gt;&gt; 'Brie' in cheeses
False
</pre>
<!--TOC section id="sec116" Traversing a list-->
<h2 class="section" id="sec116">10.3&#X2003;Traversing a list</h2><!--SEC END --><p>
<a id="hevea_default728"></a>
<a id="hevea_default729"></a>
<a id="hevea_default730"></a>
<a id="hevea_default731"></a>
<a id="hevea_default732"></a></p><p>The most common way to traverse the elements of a list is
with a <span class="c004">for</span> loop. The syntax is the same as for strings:</p><pre class="verbatim">for cheese in cheeses:
    print(cheese)
</pre><p>
This works well if you only need to read the elements of the
list. But if you want to write or update the elements, you
need the indices. A common way to do that is to combine
the built-in functions <span class="c004">range</span> and <span class="c004">len</span>:
<a id="hevea_default733"></a>
<a id="hevea_default734"></a></p><pre class="verbatim">for i in range(len(numbers)):
    numbers[i] = numbers[i] * 2
</pre><p>
This loop traverses the list and updates each element. <span class="c004">len</span>
returns the number of elements in the list. <span class="c004">range</span> returns
a list of indices from 0 to <span class="c009">n</span>&#X2212;1, where <span class="c009">n</span> is the length of
the list. Each time through the loop <span class="c004">i</span> gets the index
of the next element. The assignment statement in the body uses
<span class="c004">i</span> to read the old value of the element and to assign the
new value.
<a id="hevea_default735"></a>
<a id="hevea_default736"></a></p><p>A <span class="c004">for</span> loop over an empty list never runs the body:</p><pre class="verbatim">for x in []:
    print('This never happens.')
</pre><p>
Although a list can contain another list, the nested
list still counts as a single element. The length of this list is
four:
<a id="hevea_default737"></a>
<a id="hevea_default738"></a></p><pre class="verbatim">['spam', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]
</pre>
<!--TOC section id="sec117" List operations-->
<h2 class="section" id="sec117">10.4&#X2003;List operations</h2><!--SEC END --><p>
<a id="hevea_default739"></a></p><p>The <span class="c004">+</span> operator concatenates lists:
<a id="hevea_default740"></a>
<a id="hevea_default741"></a></p><pre class="verbatim">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [4, 5, 6]
&gt;&gt;&gt; c = a + b
&gt;&gt;&gt; c
[1, 2, 3, 4, 5, 6]
</pre><p>
The <span class="c004">*</span> operator repeats a list a given number of times:
<a id="hevea_default742"></a>
<a id="hevea_default743"></a></p><pre class="verbatim">&gt;&gt;&gt; [0] * 4
[0, 0, 0, 0]
&gt;&gt;&gt; [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
</pre><p>
The first example repeats <span class="c004">[0]</span> four times. The second example
repeats the list <span class="c004">[1, 2, 3]</span> three times.</p>
<!--TOC section id="sec118" List slices-->
<h2 class="section" id="sec118">10.5&#X2003;List slices</h2><!--SEC END --><p>
<a id="hevea_default744"></a>
<a id="hevea_default745"></a>
<a id="hevea_default746"></a>
<a id="hevea_default747"></a>
<a id="hevea_default748"></a></p><p>The slice operator also works on lists:</p><pre class="verbatim">&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; t[1:3]
['b', 'c']
&gt;&gt;&gt; t[:4]
['a', 'b', 'c', 'd']
&gt;&gt;&gt; t[3:]
['d', 'e', 'f']
</pre><p>
If you omit the first index, the slice starts at the beginning.
If you omit the second, the slice goes to the end. So if you
omit both, the slice is a copy of the whole list.
<a id="hevea_default749"></a>
<a id="hevea_default750"></a>
<a id="hevea_default751"></a></p><pre class="verbatim">&gt;&gt;&gt; t[:]
['a', 'b', 'c', 'd', 'e', 'f']
</pre><p>
Since lists are mutable, it is often useful to make a copy
before performing operations that modify lists.
<a id="hevea_default752"></a></p><p>A slice operator on the left side of an assignment
can update multiple elements:
<a id="hevea_default753"></a>
<a id="hevea_default754"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; t[1:3] = ['x', 'y']
&gt;&gt;&gt; t
['a', 'x', 'y', 'd', 'e', 'f']
</pre>
<!--TOC section id="sec119" List methods-->
<h2 class="section" id="sec119">10.6&#X2003;List methods</h2><!--SEC END --><p>
<a id="hevea_default755"></a>
<a id="hevea_default756"></a></p><p>Python provides methods that operate on lists. For example,
<span class="c004">append</span> adds a new element to the end of a list:
<a id="hevea_default757"></a>
<a id="hevea_default758"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; t.append('d')
&gt;&gt;&gt; t
['a', 'b', 'c', 'd']
</pre><p>
<span class="c004">extend</span> takes a list as an argument and appends all of
the elements:
<a id="hevea_default759"></a>
<a id="hevea_default760"></a></p><pre class="verbatim">&gt;&gt;&gt; t1 = ['a', 'b', 'c']
&gt;&gt;&gt; t2 = ['d', 'e']
&gt;&gt;&gt; t1.extend(t2)
&gt;&gt;&gt; t1
['a', 'b', 'c', 'd', 'e']
</pre><p>
This example leaves <span class="c004">t2</span> unmodified.</p><p><span class="c004">sort</span> arranges the elements of the list from low to high:
<a id="hevea_default761"></a>
<a id="hevea_default762"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ['d', 'c', 'e', 'b', 'a']
&gt;&gt;&gt; t.sort()
&gt;&gt;&gt; t
['a', 'b', 'c', 'd', 'e']
</pre><p>
Most list methods are void; they modify the list and return <span class="c004">None</span>.
If you accidentally write <span class="c004">t = t.sort()</span>, you will be disappointed
with the result.
<a id="hevea_default763"></a>
<a id="hevea_default764"></a>
<a id="hevea_default765"></a>
<a id="hevea_default766"></a></p>
<!--TOC section id="sec120" Map, filter and reduce-->
<h2 class="section" id="sec120">10.7&#X2003;Map, filter and reduce</h2><!--SEC END --><p>
<a id="filter"></a></p><p>To add up all the numbers in a list, you can use a loop like this:</p><pre class="verbatim">def add_all(t):
    total = 0
    for x in t:
        total += x
    return total
</pre><p>
<span class="c004">total</span> is initialized to 0. Each time through the loop,
<span class="c004">x</span> gets one element from the list. The <span class="c004">+=</span> operator
provides a short way to update a variable. This
<span class="c010">augmented assignment statement</span>,
<a id="hevea_default767"></a>
<a id="hevea_default768"></a>
<a id="hevea_default769"></a>
<a id="hevea_default770"></a></p><pre class="verbatim">    total += x
</pre><p>
is equivalent to</p><pre class="verbatim">    total = total + x
</pre><p>
As the loop runs, <span class="c004">total</span> accumulates the sum of the
elements; a variable used this way is sometimes called an
<span class="c010">accumulator</span>.
<a id="hevea_default771"></a></p><p>Adding up the elements of a list is such a common operation
that Python provides it as a built-in function, <span class="c004">sum</span>:</p><pre class="verbatim">&gt;&gt;&gt; t = [1, 2, 3]
&gt;&gt;&gt; sum(t)
6
</pre><p>
An operation like this that combines a sequence of elements into
a single value is sometimes called <span class="c010">reduce</span>.
<a id="hevea_default772"></a>
<a id="hevea_default773"></a>
<a id="hevea_default774"></a></p><p>Sometimes you want to traverse one list while building
another. For example, the following function takes a list of strings
and returns a new list that contains capitalized strings:</p><pre class="verbatim">def capitalize_all(t):
    res = []
    for s in t:
        res.append(s.capitalize())
    return res
</pre><p>
<span class="c004">res</span> is initialized with an empty list; each time through
the loop, we append the next element. So <span class="c004">res</span> is another
kind of accumulator.
<a id="hevea_default775"></a></p><p>An operation like <code class="verb">capitalize_all</code> is sometimes called a <span class="c010">map</span> because it &#X201C;maps&#X201D; a function (in this case the method <span class="c004">capitalize</span>) onto each of the elements in a sequence.
<a id="hevea_default776"></a>
<a id="hevea_default777"></a>
<a id="hevea_default778"></a>
<a id="hevea_default779"></a></p><p>Another common operation is to select some of the elements from
a list and return a sublist. For example, the following
function takes a list of strings and returns a list that contains
only the uppercase strings:</p><pre class="verbatim">def only_upper(t):
    res = []
    for s in t:
        if s.isupper():
            res.append(s)
    return res
</pre><p>
<span class="c004">isupper</span> is a string method that returns <span class="c004">True</span> if
the string contains only upper case letters.</p><p>An operation like <code class="verb">only_upper</code> is called a <span class="c010">filter</span> because
it selects some of the elements and filters out the others.</p><p>Most common list operations can be expressed as a combination
of map, filter and reduce.</p>
<!--TOC section id="sec121" Deleting elements-->
<h2 class="section" id="sec121">10.8&#X2003;Deleting elements</h2><!--SEC END --><p>
<a id="hevea_default780"></a>
<a id="hevea_default781"></a></p><p>There are several ways to delete elements from a list. If you
know the index of the element you want, you can use
<span class="c004">pop</span>:
<a id="hevea_default782"></a>
<a id="hevea_default783"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; x = t.pop(1)
&gt;&gt;&gt; t
['a', 'c']
&gt;&gt;&gt; x
'b'
</pre><p>
<span class="c004">pop</span> modifies the list and returns the element that was removed.
If you don&#X2019;t provide an index, it deletes and returns the
last element.</p><p>If you don&#X2019;t need the removed value, you can use the <span class="c004">del</span>
operator:
<a id="hevea_default784"></a>
<a id="hevea_default785"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; del t[1]
&gt;&gt;&gt; t
['a', 'c']
</pre><p>
If you know the element you want to remove (but not the index), you
can use <span class="c004">remove</span>:
<a id="hevea_default786"></a>
<a id="hevea_default787"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; t.remove('b')
&gt;&gt;&gt; t
['a', 'c']
</pre><p>
The return value from <span class="c004">remove</span> is <span class="c004">None</span>.
<a id="hevea_default788"></a>
<a id="hevea_default789"></a></p><p>To remove more than one element, you can use <span class="c004">del</span> with
a slice index:</p><pre class="verbatim">&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; del t[1:5]
&gt;&gt;&gt; t
['a', 'f']
</pre><p>
As usual, the slice selects all the elements up to but not
including the second index.</p>
<!--TOC section id="sec122" Lists and strings-->
<h2 class="section" id="sec122">10.9&#X2003;Lists and strings</h2><!--SEC END --><p>
<a id="hevea_default790"></a>
<a id="hevea_default791"></a>
<a id="hevea_default792"></a></p><p>A string is a sequence of characters and a list is a sequence
of values, but a list of characters is not the same as a
string. To convert from a string to a list of characters,
you can use <span class="c004">list</span>:
<a id="hevea_default793"></a>
<a id="hevea_default794"></a></p><pre class="verbatim">&gt;&gt;&gt; s = 'spam'
&gt;&gt;&gt; t = list(s)
&gt;&gt;&gt; t
['s', 'p', 'a', 'm']
</pre><p>
Because <span class="c004">list</span> is the name of a built-in function, you should
avoid using it as a variable name. I also avoid <span class="c004">l</span> because
it looks too much like <span class="c004">1</span>. So that&#X2019;s why I use <span class="c004">t</span>.</p><p>The <span class="c004">list</span> function breaks a string into individual letters. If
you want to break a string into words, you can use the <span class="c004">split</span>
method:
<a id="hevea_default795"></a>
<a id="hevea_default796"></a></p><pre class="verbatim">&gt;&gt;&gt; s = 'pining for the fjords'
&gt;&gt;&gt; t = s.split()
&gt;&gt;&gt; t
['pining', 'for', 'the', 'fjords']
</pre><p>
An optional argument called a <span class="c010">delimiter</span> specifies which
characters to use as word boundaries.
The following example
uses a hyphen as a delimiter:
<a id="hevea_default797"></a>
<a id="hevea_default798"></a>
<a id="hevea_default799"></a></p><pre class="verbatim">&gt;&gt;&gt; s = 'spam-spam-spam'
&gt;&gt;&gt; delimiter = '-'
&gt;&gt;&gt; t = s.split(delimiter)
&gt;&gt;&gt; t
['spam', 'spam', 'spam']
</pre><p>
<span class="c004">join</span> is the inverse of <span class="c004">split</span>. It
takes a list of strings and
concatenates the elements. <span class="c004">join</span> is a string method,
so you have to invoke it on the delimiter and pass the
list as a parameter:
<a id="hevea_default800"></a>
<a id="hevea_default801"></a>
<a id="hevea_default802"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ['pining', 'for', 'the', 'fjords']
&gt;&gt;&gt; delimiter = ' '
&gt;&gt;&gt; s = delimiter.join(t)
&gt;&gt;&gt; s
'pining for the fjords'
</pre><p>
In this case the delimiter is a space character, so
<span class="c004">join</span> puts a space between words. To concatenate
strings without spaces, you can use the empty string,
<code class="verb">''</code>, as a delimiter.
<a id="hevea_default803"></a>
<a id="hevea_default804"></a></p>
<!--TOC section id="sec123" Objects and values-->
<h2 class="section" id="sec123">10.10&#X2003;Objects and values</h2><!--SEC END --><p>
<a id="equivalence"></a>
<a id="hevea_default805"></a>
<a id="hevea_default806"></a></p><p>If we run these assignment statements:</p><pre class="verbatim">a = 'banana'
b = 'banana'
</pre><p>
We know that <span class="c004">a</span> and <span class="c004">b</span> both refer to a
string, but we don&#X2019;t
know whether they refer to the <em>same</em> string.
There are two possible states, shown in Figure&#XA0;<a href="#fig.list1">10.2</a>.
<a id="hevea_default807"></a></p><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2012.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 10.2: State diagram.</td></tr>
</table></div>
<a id="fig.list1"></a>
<div class="center"><hr class="floatrule"></div></blockquote><p>In one case, <span class="c004">a</span> and <span class="c004">b</span> refer to two different objects that
have the same value. In the second case, they refer to the same
object.
<a id="hevea_default808"></a>
<a id="hevea_default809"></a></p><p>To check whether two variables refer to the same object, you can
use the <span class="c004">is</span> operator.</p><pre class="verbatim">&gt;&gt;&gt; a = 'banana'
&gt;&gt;&gt; b = 'banana'
&gt;&gt;&gt; a is b
True
</pre><p>
In this example, Python only created one string object, and both <span class="c004">a</span> and <span class="c004">b</span> refer to it. But when you create two lists, you get
two objects:</p><pre class="verbatim">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [1, 2, 3]
&gt;&gt;&gt; a is b
False
</pre><p>
So the state diagram looks like Figure&#XA0;<a href="#fig.list2">10.3</a>.
<a id="hevea_default810"></a>
<a id="hevea_default811"></a></p><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2013.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 10.3: State diagram.</td></tr>
</table></div>
<a id="fig.list2"></a>
<div class="center"><hr class="floatrule"></div></blockquote><p>In this case we would say that the two lists are <span class="c010">equivalent</span>,
because they have the same elements, but not <span class="c010">identical</span>, because
they are not the same object. If two objects are identical, they are
also equivalent, but if they are equivalent, they are not necessarily
identical.
<a id="hevea_default812"></a>
<a id="hevea_default813"></a></p><p>Until now, we have been using &#X201C;object&#X201D; and &#X201C;value&#X201D;
interchangeably, but it is more precise to say that an object has a
value. If you evaluate <span class="c004">[1, 2, 3]</span>, you get a list
object whose value is a sequence of integers. If another
list has the same elements, we say it has the same value, but
it is not the same object.
<a id="hevea_default814"></a>
<a id="hevea_default815"></a></p>
<!--TOC section id="sec124" Aliasing-->
<h2 class="section" id="sec124">10.11&#X2003;Aliasing</h2><!--SEC END --><p>
<a id="hevea_default816"></a>
<a id="hevea_default817"></a></p><p>If <span class="c004">a</span> refers to an object and you assign <span class="c004">b = a</span>,
then both variables refer to the same object:</p><pre class="verbatim">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; b is a
True
</pre><p>
The state diagram looks like Figure&#XA0;<a href="#fig.list3">10.4</a>.
<a id="hevea_default818"></a>
<a id="hevea_default819"></a></p><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2014.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 10.4: State diagram.</td></tr>
</table></div>
<a id="fig.list3"></a>
<div class="center"><hr class="floatrule"></div></blockquote><p>The association of a variable with an object is called a <span class="c010">reference</span>. In this example, there are two references to the same
object.
<a id="hevea_default820"></a></p><p>An object with more than one reference has more
than one name, so we say that the object is <span class="c010">aliased</span>.
<a id="hevea_default821"></a></p><p>If the aliased object is mutable, changes made with one alias affect
the other:</p><pre class="verbatim">&gt;&gt;&gt; b[0] = 42
&gt;&gt;&gt; a
[42, 2, 3]
</pre><p>
Although this behavior can be useful, it is error-prone. In general,
it is safer to avoid aliasing when you are working with mutable
objects.
<a id="hevea_default822"></a></p><p>For immutable objects like strings, aliasing is not as much of a
problem. In this example:</p><pre class="verbatim">a = 'banana'
b = 'banana'
</pre><p>
It almost never makes a difference whether <span class="c004">a</span> and <span class="c004">b</span> refer
to the same string or not.</p>
<!--TOC section id="sec125" List arguments-->
<h2 class="section" id="sec125">10.12&#X2003;List arguments</h2><!--SEC END --><p>
<a id="list.arguments"></a>
<a id="hevea_default823"></a>
<a id="hevea_default824"></a>
<a id="hevea_default825"></a>
<a id="hevea_default826"></a>
<a id="hevea_default827"></a></p><p>When you pass a list to a function, the function gets a reference to
the list. If the function modifies the list, the caller sees
the change. For example, <code class="verb">delete_head</code> removes the first element
from a list:</p><pre class="verbatim">def delete_head(t):
    del t[0]
</pre><p>
Here&#X2019;s how it is used:</p><pre class="verbatim">&gt;&gt;&gt; letters = ['a', 'b', 'c']
&gt;&gt;&gt; delete_head(letters)
&gt;&gt;&gt; letters
['b', 'c']
</pre><p>
The parameter <span class="c004">t</span> and the variable <span class="c004">letters</span> are
aliases for the same object. The stack diagram looks like
Figure&#XA0;<a href="#fig.stack5">10.5</a>.
<a id="hevea_default828"></a>
<a id="hevea_default829"></a></p><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2015.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 10.5: Stack diagram.</td></tr>
</table></div>
<a id="fig.stack5"></a>
<div class="center"><hr class="floatrule"></div></blockquote><p>Since the list is shared by two frames, I drew
it between them.</p><p>It is important to distinguish between operations that
modify lists and operations that create new lists. For
example, the <span class="c004">append</span> method modifies a list, but the
<span class="c004">+</span> operator creates a new list.
<a id="hevea_default830"></a>
<a id="hevea_default831"></a>
<a id="hevea_default832"></a>
<a id="hevea_default833"></a></p><p>Here&#X2019;s an example using <span class="c004">append</span>:
</p><pre class="verbatim">&gt;&gt;&gt; t1 = [1, 2]
&gt;&gt;&gt; t2 = t1.append(3)
&gt;&gt;&gt; t1
[1, 2, 3]
&gt;&gt;&gt; t2
None
</pre><p>
The return value from <span class="c004">append</span> is <span class="c004">None</span>.</p><p>Here&#X2019;s an example using the <span class="c004">+</span> operator:
</p><pre class="verbatim">&gt;&gt;&gt; t3 = t1 + [4]
&gt;&gt;&gt; t1
[1, 2, 3]
&gt;&gt;&gt; t3
[1, 2, 3, 4]
</pre><p>
The result of the operator is a new list, and the original list is
unchanged.</p><p>This difference is important when you write functions that
are supposed to modify lists. For example, this function
<em>does not</em> delete the head of a list:
</p><pre class="verbatim">def bad_delete_head(t):
    t = t[1:]              # WRONG!
</pre><p>
The slice operator creates a new list and the assignment
makes <span class="c004">t</span> refer to it, but that doesn&#X2019;t affect the caller.
<a id="hevea_default834"></a>
<a id="hevea_default835"></a>
</p><pre class="verbatim">&gt;&gt;&gt; t4 = [1, 2, 3]
&gt;&gt;&gt; bad_delete_head(t4)
&gt;&gt;&gt; t4
[1, 2, 3]
</pre><p>
At the beginning of <code class="verb">bad_delete_head</code>, <span class="c004">t</span> and <span class="c004">t4</span>
refer to the same list. At the end, <span class="c004">t</span> refers to a new list,
but <span class="c004">t4</span> still refers to the original, unmodified list.</p><p>An alternative is to write a function that creates and
returns a new list. For
example, <span class="c004">tail</span> returns all but the first
element of a list:</p><pre class="verbatim">def tail(t):
    return t[1:]
</pre><p>
This function leaves the original list unmodified.
Here&#X2019;s how it is used:</p><pre class="verbatim">&gt;&gt;&gt; letters = ['a', 'b', 'c']
&gt;&gt;&gt; rest = tail(letters)
&gt;&gt;&gt; rest
['b', 'c']
</pre>
<!--TOC section id="sec126" Debugging-->
<h2 class="section" id="sec126">10.13&#X2003;Debugging</h2><!--SEC END --><p>
<a id="hevea_default836"></a></p><p>Careless use of lists (and other mutable objects)
can lead to long hours of debugging. Here are some common
pitfalls and ways to avoid them:</p><ol class="enumerate" type=1><li class="li-enumerate">Most list methods modify the argument and
return <span class="c004">None</span>. This is the opposite of the string methods,
which return a new string and leave the original alone.<p>If you are used to writing string code like this:</p><pre class="verbatim">word = word.strip()
</pre><p>It is tempting to write list code like this:</p><pre class="verbatim">t = t.sort()           # WRONG!
</pre><p>
<a id="hevea_default837"></a>
<a id="hevea_default838"></a></p><p>Because <span class="c004">sort</span> returns <span class="c004">None</span>, the
next operation you perform with <span class="c004">t</span> is likely to fail.</p><p>Before using list methods and operators, you should read the
documentation carefully and then test them in interactive mode.</p></li><li class="li-enumerate">Pick an idiom and stick with it.<p>Part of the problem with lists is that there are too many
ways to do things. For example, to remove an element from
a list, you can use <span class="c004">pop</span>, <span class="c004">remove</span>, <span class="c004">del</span>,
or even a slice assignment.</p><p>To add an element, you can use the <span class="c004">append</span> method or
the <span class="c004">+</span> operator. Assuming that <span class="c004">t</span> is a list and
<span class="c004">x</span> is a list element, these are correct:</p><pre class="verbatim">t.append(x)
t = t + [x]
t += [x]
</pre><p>And these are wrong:</p><pre class="verbatim">t.append([x])          # WRONG!
t = t.append(x)        # WRONG!
t + [x]                # WRONG!
t = t + x              # WRONG!
</pre><p>Try out each of these examples in interactive mode to make sure
you understand what they do. Notice that only the last
one causes a runtime error; the other three are legal, but they
do the wrong thing.</p></li><li class="li-enumerate">Make copies to avoid aliasing.
<a id="hevea_default839"></a>
<a id="hevea_default840"></a><p>If you want to use a method like <span class="c004">sort</span> that modifies
the argument, but you need to keep the original list as
well, you can make a copy.</p><pre class="verbatim">&gt;&gt;&gt; t = [3, 1, 2]
&gt;&gt;&gt; t2 = t[:]
&gt;&gt;&gt; t2.sort()
&gt;&gt;&gt; t
[3, 1, 2]
&gt;&gt;&gt; t2
[1, 2, 3]
</pre><p>In this example you could also use the built-in function <span class="c004">sorted</span>,
which returns a new, sorted list and leaves the original alone.
<a id="hevea_default841"></a>
<a id="hevea_default842"></a></p><pre class="verbatim">&gt;&gt;&gt; t2 = sorted(t)
&gt;&gt;&gt; t
[3, 1, 2]
&gt;&gt;&gt; t2
[1, 2, 3]
</pre></li></ol>
<!--TOC section id="sec127" Glossary-->
<h2 class="section" id="sec127">10.14&#X2003;Glossary</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c010">list:</span></dt><dd class="dd-description"> A sequence of values.
<a id="hevea_default843"></a></dd><dt class="dt-description"><span class="c010">element:</span></dt><dd class="dd-description"> One of the values in a list (or other sequence),
also called items.
<a id="hevea_default844"></a></dd><dt class="dt-description"><span class="c010">nested list:</span></dt><dd class="dd-description"> A list that is an element of another list.
<a id="hevea_default845"></a></dd><dt class="dt-description"><span class="c010">accumulator:</span></dt><dd class="dd-description"> A variable used in a loop to add up or
accumulate a result.
<a id="hevea_default846"></a></dd><dt class="dt-description"><span class="c010">augmented assignment:</span></dt><dd class="dd-description"> A statement that updates the value
of a variable using an operator like <code class="verb">+=</code>.
<a id="hevea_default847"></a>
<a id="hevea_default848"></a>
<a id="hevea_default849"></a></dd><dt class="dt-description"><span class="c010">reduce:</span></dt><dd class="dd-description"> A processing pattern that traverses a sequence
and accumulates the elements into a single result.
<a id="hevea_default850"></a>
<a id="hevea_default851"></a></dd><dt class="dt-description"><span class="c010">map:</span></dt><dd class="dd-description"> A processing pattern that traverses a sequence and
performs an operation on each element.
<a id="hevea_default852"></a>
<a id="hevea_default853"></a></dd><dt class="dt-description"><span class="c010">filter:</span></dt><dd class="dd-description"> A processing pattern that traverses a list and
selects the elements that satisfy some criterion.
<a id="hevea_default854"></a>
<a id="hevea_default855"></a></dd><dt class="dt-description"><span class="c010">object:</span></dt><dd class="dd-description"> Something a variable can refer to. An object
has a type and a value.
<a id="hevea_default856"></a></dd><dt class="dt-description"><span class="c010">equivalent:</span></dt><dd class="dd-description"> Having the same value.
<a id="hevea_default857"></a></dd><dt class="dt-description"><span class="c010">identical:</span></dt><dd class="dd-description"> Being the same object (which implies equivalence).
<a id="hevea_default858"></a></dd><dt class="dt-description"><span class="c010">reference:</span></dt><dd class="dd-description"> The association between a variable and its value.
<a id="hevea_default859"></a></dd><dt class="dt-description"><span class="c010">aliasing:</span></dt><dd class="dd-description"> A circumstance where two or more variables refer to the same
object.
<a id="hevea_default860"></a></dd><dt class="dt-description"><span class="c010">delimiter:</span></dt><dd class="dd-description"> A character or string used to indicate where a
string should be split.
<a id="hevea_default861"></a></dd></dl>
<!--TOC section id="sec128" Exercises-->
<h2 class="section" id="sec128">10.15&#X2003;Exercises</h2><!--SEC END --><p>You can download solutions to these exercises from
<a href="https://thinkpython.com/code/list_exercises.py"><span class="c004">https://thinkpython.com/code/list_exercises.py</span></a>.</p><div class="theorem"><span class="c010">Exercise&#XA0;1</span>&#X2003;<p><em>Write a function called </em><code class="verb"><em>nested_sum</em></code><em> that takes a list of lists
of integers and adds up the elements from all of the nested lists.
For example:</em></p><pre class="verbatim"><em>&gt;&gt;&gt; t = [[1, 2], [3], [4, 5, 6]]
&gt;&gt;&gt; nested_sum(t)
21
</em></pre></div><div class="theorem"><span class="c010">Exercise&#XA0;2</span>&#X2003;
<a id="cumulative"></a>
<a id="hevea_default862"></a><p><em>Write a function called <span class="c004">cumsum</span> that takes a list of numbers and
returns the cumulative sum; that is, a new list where the </em><span class="c009">i</span><em>th
element is the sum of the first </em><span class="c009">i</span>+1<em> elements from the original list.
For example:</em></p><pre class="verbatim"><em>&gt;&gt;&gt; t = [1, 2, 3]
&gt;&gt;&gt; cumsum(t)
[1, 3, 6]
</em></pre></div><div class="theorem"><span class="c010">Exercise&#XA0;3</span>&#X2003;<p><em>Write a function called </em><code class="verb"><em>middle</em></code><em> that takes a list and
returns a new list that contains all but the first and last
elements. For example:</em></p><pre class="verbatim"><em>&gt;&gt;&gt; t = [1, 2, 3, 4]
&gt;&gt;&gt; middle(t)
[2, 3]
</em></pre></div><div class="theorem"><span class="c010">Exercise&#XA0;4</span>&#X2003;<p><em>Write a function called </em><code class="verb"><em>chop</em></code><em> that takes a list, modifies it
by removing the first and last elements, and returns <span class="c004">None</span>.
For example:</em></p><pre class="verbatim"><em>&gt;&gt;&gt; t = [1, 2, 3, 4]
&gt;&gt;&gt; chop(t)
&gt;&gt;&gt; t
[2, 3]
</em></pre></div><div class="theorem"><span class="c010">Exercise&#XA0;5</span>&#X2003;<em>
Write a function called </em><code class="verb"><em>is_sorted</em></code><em> that takes a list as a
parameter and returns <span class="c004">True</span> if the list is sorted in ascending
order and <span class="c004">False</span> otherwise. For example:</em><pre class="verbatim"><em>&gt;&gt;&gt; is_sorted([1, 2, 2])
True
&gt;&gt;&gt; is_sorted(['b', 'a'])
False
</em></pre></div><div class="theorem"><span class="c010">Exercise&#XA0;6</span>&#X2003;
<a id="anagram"></a>
<a id="hevea_default863"></a><p><em>Two words are anagrams if you can rearrange the letters from one
to spell the other. Write a function called </em><code class="verb"><em>is_anagram</em></code><em>
that takes two strings and returns <span class="c004">True</span> if they are anagrams.
</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;7</span>&#X2003;
<a id="duplicate"></a>
<a id="hevea_default864"></a>
<a id="hevea_default865"></a><p><em>Write a function called </em><code class="verb"><em>has_duplicates</em></code><em> that takes
a list and returns <span class="c004">True</span> if there is any element that
appears more than once. It should not modify the original
list.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;8</span>&#X2003;<p><em>This exercise pertains to the so-called Birthday Paradox, which you
can read about at </em><a href="http://en.wikipedia.org/wiki/Birthday_paradox"><em><span class="c004">http://en.wikipedia.org/wiki/Birthday_paradox</span></em></a><em>.
</em><a id="hevea_default866"></a></p><p><em>If there are 23 students in your class, what are the chances
that two of them have the same birthday? You can estimate this
probability by generating random samples of 23 birthdays
and checking for matches. Hint: you can generate random birthdays
with the <span class="c004">randint</span> function in the <span class="c004">random</span> module.
</em><a id="hevea_default867"></a>
<a id="hevea_default868"></a>
<a id="hevea_default869"></a>
<a id="hevea_default870"></a></p><p><em>You can download my
solution from </em><a href="https://thinkpython.com/code/birthday.py"><em><span class="c004">https://thinkpython.com/code/birthday.py</span></em></a><em>.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;9</span>&#X2003;
<a id="hevea_default871"></a>
<a id="hevea_default872"></a>
<a id="hevea_default873"></a>
<a id="hevea_default874"></a><p><em>Write a function that reads the file <span class="c004">words.txt</span> and builds
a list with one element per word. Write two versions of
this function, one using the <span class="c004">append</span> method and the
other using the idiom <span class="c004">t = t + [x]</span>. Which one takes
longer to run? Why?</em></p><p><em>Solution: </em><a href="https://thinkpython.com/code/wordlist.py"><span class="c004"><em>https://thinkpython.com/code/wordlist.py</em></span></a><em>.
</em><a id="hevea_default875"></a>
<a id="hevea_default876"></a></p></div><div class="theorem"><span class="c010">Exercise&#XA0;10</span>&#X2003;
<a id="wordlist1"></a>
<a id="bisection"></a>
<a id="hevea_default877"></a>
<a id="hevea_default878"></a>
<a id="hevea_default879"></a>
<a id="hevea_default880"></a>
<a id="hevea_default881"></a>
<a id="hevea_default882"></a><p><em>To check whether a word is in the word list, you could use
the <span class="c004">in</span> operator, but it would be slow because it searches
through the words in order.</em></p><p><em>Because the words are in alphabetical order, we can speed things up
with a bisection search (also known as binary search), which is
similar to what you do when you look a word up in the dictionary (the book, not the data structure). You
start in the middle and check to see whether the word you are looking
for comes before the word in the middle of the list. If so, you
search the first half of the list the same way. Otherwise you search
the second half.</em></p><p><em>Either way, you cut the remaining search space in half. If the
word list has 113,809 words, it will take about 17 steps to
find the word or conclude that it&#X2019;s not there.</em></p><p><em>Write a function called </em><code class="verb"><em>in_bisect</em></code><em> that takes a sorted list
and a target value and returns <span class="c004">True</span> if the word is
in the list and <span class="c004">False</span> if it&#X2019;s not.
</em><a id="hevea_default883"></a>
<a id="hevea_default884"></a></p><p><em>Or you could read the documentation of the <span class="c004">bisect</span> module
and use that! Solution: </em><a href="https://thinkpython.com/code/inlist.py"><span class="c004"><em>https://thinkpython.com/code/inlist.py</em></span></a><em>.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;11</span>&#X2003;
<a id="hevea_default885"></a><p><em>Two words are a &#X201C;reverse pair&#X201D; if each is the reverse of the
other. Write a program that finds all the reverse pairs in the
word list. Solution: </em><a href="https://thinkpython.com/code/reverse_pair.py"><em><span class="c004">https://thinkpython.com/code/reverse_pair.py</span></em></a><em>.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;12</span>&#X2003;
<a id="hevea_default886"></a><p><em>Two words &#X201C;interlock&#X201D; if taking alternating letters from each forms
a new word. For example, &#X201C;shoe&#X201D; and &#X201C;cold&#X201D;
interlock to form &#X201C;schooled&#X201D;.
Solution: </em><a href="https://thinkpython.com/code/interlock.py"><em><span class="c004">https://thinkpython.com/code/interlock.py</span></em></a><em>.
Credit: This exercise is inspired by an example at </em><a href="http://puzzlers.org"><em><span class="c004">http://puzzlers.org</span></em></a><em>.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Write a program that finds all pairs of words that interlock.
Hint: don&#X2019;t enumerate all pairs!</em></li><li class="li-enumerate"><em>Can you find any words that are three-way interlocked; that is,
every third letter forms a word, starting from the first, second or
third?</em></li></ol></div>
<!--TOC chapter id="sec129" Dictionaries-->
<h1 class="chapter" id="sec129">Chapter&#XA0;11&#X2003;Dictionaries</h1><!--SEC END --><p>This chapter presents another built-in type called a dictionary.
Dictionaries are one of Python&#X2019;s best features; they are the
building blocks of many efficient and elegant algorithms.</p>
<!--TOC section id="sec130" A dictionary is a mapping-->
<h2 class="section" id="sec130">11.1&#X2003;A dictionary is a mapping</h2><!--SEC END --><p><a id="hevea_default887"></a>
<a id="hevea_default888"></a>
<a id="hevea_default889"></a>
<a id="hevea_default890"></a>
<a id="hevea_default891"></a>
<a id="hevea_default892"></a>
A <span class="c010">dictionary</span> is like a list, but more general. In a list,
the indices have to be integers; in a dictionary they can
be (almost) any type.</p><p>A dictionary contains a collection of indices, which are called <span class="c010">keys</span>, and a collection of values. Each key is associated with a
single value. The association of a key and a value is called a <span class="c010">key-value pair</span> or sometimes an <span class="c010">item</span>. <a id="hevea_default893"></a></p><p>In mathematical language, a dictionary represents a <span class="c010">mapping</span>
from keys to values, so you can also say that each key
&#X201C;maps to&#X201D; a value.
As an example, we&#X2019;ll build a dictionary that maps from English
to Spanish words, so the keys and the values are all strings.</p><p>The function <span class="c004">dict</span> creates a new dictionary with no items.
Because <span class="c004">dict</span> is the name of a built-in function, you
should avoid using it as a variable name.
<a id="hevea_default894"></a>
<a id="hevea_default895"></a></p><pre class="verbatim">&gt;&gt;&gt; eng2sp = dict()
&gt;&gt;&gt; eng2sp
{}
</pre><p>The squiggly-brackets, <code class="verb">{}</code>, represent an empty dictionary.
To add items to the dictionary, you can use square brackets:
<a id="hevea_default896"></a>
<a id="hevea_default897"></a></p><pre class="verbatim">&gt;&gt;&gt; eng2sp['one'] = 'uno'
</pre><p>
This line creates an item that maps from the key
<code class="verb">'one'</code> to the value <code class="verb">'uno'</code>. If we print the
dictionary again, we see a key-value pair with a colon
between the key and value:</p><pre class="verbatim">&gt;&gt;&gt; eng2sp
{'one': 'uno'}
</pre><p>
This output format is also an input format. For example,
you can create a new dictionary with three items:</p><pre class="verbatim">&gt;&gt;&gt; eng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'}
</pre><p>
But if you print <span class="c004">eng2sp</span>, you might be surprised:</p><pre class="verbatim">&gt;&gt;&gt; eng2sp
{'one': 'uno', 'three': 'tres', 'two': 'dos'}
</pre><p>
The order of the key-value pairs might not be the same. If
you type the same example on your computer, you might get a
different result. In general, the order of items in
a dictionary is unpredictable.</p><p>But that&#X2019;s not a problem because
the elements of a dictionary are never indexed with integer indices.
Instead, you use the keys to look up the corresponding values:</p><pre class="verbatim">&gt;&gt;&gt; eng2sp['two']
'dos'
</pre><p>
The key <code class="verb">'two'</code> always maps to the value <code class="verb">'dos'</code> so the order
of the items doesn&#X2019;t matter.</p><p>If the key isn&#X2019;t in the dictionary, you get an exception:
<a id="hevea_default898"></a>
<a id="hevea_default899"></a></p><pre class="verbatim">&gt;&gt;&gt; eng2sp['four']
KeyError: 'four'
</pre><p>
The <span class="c004">len</span> function works on dictionaries; it returns the
number of key-value pairs:
<a id="hevea_default900"></a>
<a id="hevea_default901"></a></p><pre class="verbatim">&gt;&gt;&gt; len(eng2sp)
3
</pre><p>
The <span class="c004">in</span> operator works on dictionaries, too; it tells you whether
something appears as a <em>key</em> in the dictionary (appearing
as a value is not good enough).
<a id="hevea_default902"></a>
<a id="hevea_default903"></a>
<a id="hevea_default904"></a></p><pre class="verbatim">&gt;&gt;&gt; 'one' in eng2sp
True
&gt;&gt;&gt; 'uno' in eng2sp
False
</pre><p>
To see whether something appears as a value in a dictionary, you
can use the method <span class="c004">values</span>, which returns a collection of
values, and then use the <span class="c004">in</span> operator:
<a id="hevea_default905"></a>
<a id="hevea_default906"></a></p><pre class="verbatim">&gt;&gt;&gt; vals = eng2sp.values()
&gt;&gt;&gt; 'uno' in vals
True
</pre><p>
The <span class="c004">in</span> operator uses different algorithms for lists and
dictionaries. For lists, it searches the elements of the list in
order, as in Section&#XA0;<a href="#find">8.6</a>. As the list gets longer, the search
time gets longer in direct proportion.</p><p>Python dictionaries use a data structure
called a <span class="c010">hashtable</span> that has a remarkable property: the
<span class="c004">in</span> operator takes about the same amount of time no matter how
many items are in the dictionary. I explain how that&#X2019;s possible
in Section&#XA0;<a href="#hashtable">B.4</a>, but the explanation might not make
sense until you&#X2019;ve read a few more chapters.</p>
<!--TOC section id="sec131" Dictionary as a collection of counters-->
<h2 class="section" id="sec131">11.2&#X2003;Dictionary as a collection of counters</h2><!--SEC END --><p>
<a id="histogram"></a>
<a id="hevea_default907"></a></p><p>Suppose you are given a string and you want to count how many
times each letter appears. There are several ways you could do it:</p><ol class="enumerate" type=1><li class="li-enumerate">You could create 26 variables, one for each letter of the
alphabet. Then you could traverse the string and, for each
character, increment the corresponding counter, probably using
a chained conditional.</li><li class="li-enumerate">You could create a list with 26 elements. Then you could
convert each character to a number (using the built-in function
<span class="c004">ord</span>), use the number as an index into the list, and increment
the appropriate counter.</li><li class="li-enumerate">You could create a dictionary with characters as keys
and counters as the corresponding values. The first time you
see a character, you would add an item to the dictionary. After
that you would increment the value of an existing item.</li></ol><p>Each of these options performs the same computation, but each
of them implements that computation in a different way.
<a id="hevea_default908"></a></p><p>An <span class="c010">implementation</span> is a way of performing a computation;
some implementations are better than others. For example,
an advantage of the dictionary implementation is that we don&#X2019;t
have to know ahead of time which letters appear in the string
and we only have to make room for the letters that do appear.</p><p>Here is what the code might look like:</p><pre class="verbatim">def histogram(s):
    d = dict()
    for c in s:
        if c not in d:
            d[c] = 1
        else:
            d[c] += 1
    return d
</pre><p>
The name of the function is <span class="c004">histogram</span>, which is a statistical
term for a collection of counters (or frequencies).
<a id="hevea_default909"></a>
<a id="hevea_default910"></a>
<a id="hevea_default911"></a></p><p>The first line of the
function creates an empty dictionary. The <span class="c004">for</span> loop traverses
the string. Each time through the loop, if the character <span class="c004">c</span> is
not in the dictionary, we create a new item with key <span class="c004">c</span> and the
initial value 1 (since we have seen this letter once). If <span class="c004">c</span> is
already in the dictionary we increment <span class="c004">d[c]</span>.
<a id="hevea_default912"></a></p><p>Here&#X2019;s how it works:</p><pre class="verbatim">&gt;&gt;&gt; h = histogram('brontosaurus')
&gt;&gt;&gt; h
{'a': 1, 'b': 1, 'o': 2, 'n': 1, 's': 2, 'r': 2, 'u': 2, 't': 1}
</pre><p>
The histogram indicates that the letters <code class="verb">'a'</code> and <code class="verb">'b'</code>
appear once; <code class="verb">'o'</code> appears twice, and so on.</p><p><a id="hevea_default913"></a>
<a id="hevea_default914"></a>
Dictionaries have a method called <span class="c004">get</span> that takes a key
and a default value. If the key appears in the dictionary,
<span class="c004">get</span> returns the corresponding value; otherwise it returns
the default value. For example:</p><pre class="verbatim">&gt;&gt;&gt; h = histogram('a')
&gt;&gt;&gt; h
{'a': 1}
&gt;&gt;&gt; h.get('a', 0)
1
&gt;&gt;&gt; h.get('c', 0)
0
</pre><p>
As an exercise, use <span class="c004">get</span> to write <span class="c004">histogram</span> more concisely. You
should be able to eliminate the <span class="c004">if</span> statement.</p>
<!--TOC section id="sec132" Looping and dictionaries-->
<h2 class="section" id="sec132">11.3&#X2003;Looping and dictionaries</h2><!--SEC END --><p>
<a id="hevea_default915"></a>
<a id="hevea_default916"></a>
<a id="hevea_default917"></a></p><p>If you use a dictionary in a <span class="c004">for</span> statement, it traverses
the keys of the dictionary. For example, <code class="verb">print_hist</code>
prints each key and the corresponding value:</p><pre class="verbatim">def print_hist(h):
    for c in h:
        print(c, h[c])
</pre><p>
Here&#X2019;s what the output looks like:</p><pre class="verbatim">&gt;&gt;&gt; h = histogram('parrot')
&gt;&gt;&gt; print_hist(h)
a 1
p 1
r 2
t 1
o 1
</pre><p>
Again, the keys are in no particular order. To traverse the keys
in sorted order, you can use the built-in function <span class="c004">sorted</span>:
<a id="hevea_default918"></a>
<a id="hevea_default919"></a></p><pre class="verbatim">&gt;&gt;&gt; for key in sorted(h):
...     print(key, h[key])
a 1
o 1
p 1
r 2
t 1
</pre>
<!--TOC section id="sec133" Reverse lookup-->
<h2 class="section" id="sec133">11.4&#X2003;Reverse lookup</h2><!--SEC END --><p>
<a id="raise"></a>
<a id="hevea_default920"></a>
<a id="hevea_default921"></a>
<a id="hevea_default922"></a>
<a id="hevea_default923"></a></p><p>Given a dictionary <span class="c004">d</span> and a key <span class="c004">k</span>, it is easy to
find the corresponding value <span class="c004">v = d[k]</span>. This operation
is called a <span class="c010">lookup</span>.</p><p>But what if you have <span class="c004">v</span> and you want to find <span class="c004">k</span>?
You have two problems: first, there might be more than one
key that maps to the value <span class="c004">v</span>. Depending on the application,
you might be able to pick one, or you might have to make
a list that contains all of them. Second, there is no
simple syntax to do a <span class="c010">reverse lookup</span>; you have to search.</p><p>Here is a function that takes a value and returns the first
key that maps to that value:</p><pre class="verbatim">def reverse_lookup(d, v):
    for k in d:
        if d[k] == v:
            return k
    raise LookupError()
</pre><p>
This function is yet another example of the search pattern, but it
uses a feature we haven&#X2019;t seen before, <span class="c004">raise</span>. The
<span class="c010">raise statement</span> causes an exception; in this case it causes a
<span class="c004">LookupError</span>, which is a built-in exception used to indicate
that a lookup operation failed.
<a id="hevea_default924"></a>
<a id="hevea_default925"></a> <a id="hevea_default926"></a> <a id="hevea_default927"></a>
<a id="hevea_default928"></a> <a id="hevea_default929"></a></p><p>If we get to the end of the loop, that means <span class="c004">v</span>
doesn&#X2019;t appear in the dictionary as a value, so we raise an
exception.</p><p>Here is an example of a successful reverse lookup:</p><pre class="verbatim">&gt;&gt;&gt; h = histogram('parrot')
&gt;&gt;&gt; key = reverse_lookup(h, 2)
&gt;&gt;&gt; key
'r'
</pre><p>
And an unsuccessful one:</p><pre class="verbatim">&gt;&gt;&gt; key = reverse_lookup(h, 3)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 5, in reverse_lookup
LookupError
</pre><p>
The effect when you raise an exception is the same as when
Python raises one: it prints a traceback and an error message.
<a id="hevea_default930"></a>
<a id="hevea_default931"></a>
<a id="hevea_default932"></a></p><p>When you raise an exception, you can provide a detailed error message as an optional argument. For example:</p><pre class="verbatim">&gt;&gt;&gt; raise LookupError('value does not appear in the dictionary')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
LookupError: value does not appear in the dictionary
</pre><p>
A reverse lookup is much slower than a forward lookup; if you
have to do it often, or if the dictionary gets big, the performance
of your program will suffer.</p>
<!--TOC section id="sec134" Dictionaries and lists-->
<h2 class="section" id="sec134">11.5&#X2003;Dictionaries and lists</h2><!--SEC END --><p>
<a id="invert"></a></p><p>Lists can appear as values in a dictionary. For example, if you
are given a dictionary that maps from letters to frequencies, you
might want to invert it; that is, create a dictionary that maps
from frequencies to letters. Since there might be several letters
with the same frequency, each value in the inverted dictionary
should be a list of letters.
<a id="hevea_default933"></a>
<a id="hevea_default934"></a></p><p>Here is a function that inverts a dictionary:</p><pre class="verbatim">def invert_dict(d):
    inverse = dict()
    for key in d:
        val = d[key]
        if val not in inverse:
            inverse[val] = [key]
        else:
            inverse[val].append(key)
    return inverse
</pre><p>
Each time through the loop, <span class="c004">key</span> gets a key from <span class="c004">d</span> and
<span class="c004">val</span> gets the corresponding value. If <span class="c004">val</span> is not in <span class="c004">inverse</span>, that means we haven&#X2019;t seen it before, so we create a new
item and initialize it with a <span class="c010">singleton</span> (a list that contains a
single element). Otherwise we have seen this value before, so we
append the corresponding key to the list. <a id="hevea_default935"></a></p><p>Here is an example:</p><pre class="verbatim">&gt;&gt;&gt; hist = histogram('parrot')
&gt;&gt;&gt; hist
{'a': 1, 'p': 1, 'r': 2, 't': 1, 'o': 1}
&gt;&gt;&gt; inverse = invert_dict(hist)
&gt;&gt;&gt; inverse
{1: ['a', 'p', 't', 'o'], 2: ['r']}
</pre><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2016.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 11.1: State diagram.</td></tr>
</table></div>
<a id="fig.dict1"></a>
<div class="center"><hr class="floatrule"></div></blockquote><p>Figure&#XA0;<a href="#fig.dict1">11.1</a> is a state diagram showing <span class="c004">hist</span> and <span class="c004">inverse</span>.
A dictionary is represented as a box with the type <span class="c004">dict</span> above it
and the key-value pairs inside. If the values are integers, floats or
strings, I draw them inside the box, but I usually draw lists
outside the box, just to keep the diagram simple.
<a id="hevea_default936"></a>
<a id="hevea_default937"></a></p><p>Lists can be values in a dictionary, as this example shows, but they
cannot be keys. Here&#X2019;s what happens if you try:
<a id="hevea_default938"></a>
<a id="hevea_default939"></a></p><pre class="verbatim">&gt;&gt;&gt; t = [1, 2, 3]
&gt;&gt;&gt; d = dict()
&gt;&gt;&gt; d[t] = 'oops'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: list objects are unhashable
</pre><p>
I mentioned earlier that a dictionary is implemented using
a hashtable and that means that the keys have to be <span class="c010">hashable</span>.
<a id="hevea_default940"></a>
<a id="hevea_default941"></a></p><p>A <span class="c010">hash</span> is a function that takes a value (of any kind)
and returns an integer. Dictionaries use these integers,
called hash values, to store and look up key-value pairs.
<a id="hevea_default942"></a></p><p>This system works fine if the keys are immutable. But if the
keys are mutable, like lists, bad things happen. For example,
when you create a key-value pair, Python hashes the key and
stores it in the corresponding location. If you modify the
key and then hash it again, it would go to a different location.
In that case you might have two entries for the same key,
or you might not be able to find a key. Either way, the
dictionary wouldn&#X2019;t work correctly.</p><p>That&#X2019;s why keys have to be hashable, and why mutable types like
lists aren&#X2019;t. The simplest way to get around this limitation is to
use tuples, which we will see in the next chapter.</p><p>Since dictionaries are mutable, they can&#X2019;t be used as keys,
but they <em>can</em> be used as values.</p>
<!--TOC section id="sec135" Memos-->
<h2 class="section" id="sec135">11.6&#X2003;Memos</h2><!--SEC END --><p>
<a id="memoize"></a></p><p>If you played with the <span class="c004">fibonacci</span> function from
Section&#XA0;<a href="#one.more.example">6.7</a>, you might have noticed that the bigger
the argument you provide, the longer the function takes to run.
Furthermore, the run time increases quickly.
<a id="hevea_default943"></a>
<a id="hevea_default944"></a></p><p>To understand why, consider Figure&#XA0;<a href="#fig.fibonacci">11.2</a>, which shows
the <span class="c010">call graph</span> for <span class="c004">fibonacci</span> with <span class="c004">n=4</span>:</p><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2017.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 11.2: Call graph.</td></tr>
</table></div>
<a id="fig.fibonacci"></a>
<div class="center"><hr class="floatrule"></div></blockquote><p>A call graph shows a set of function frames, with lines connecting each
frame to the frames of the functions it calls. At the top of the
graph, <span class="c004">fibonacci</span> with <span class="c004">n=4</span> calls <span class="c004">fibonacci</span> with <span class="c004">n=3</span> and <span class="c004">n=2</span>. In turn, <span class="c004">fibonacci</span> with <span class="c004">n=3</span> calls
<span class="c004">fibonacci</span> with <span class="c004">n=2</span> and <span class="c004">n=1</span>. And so on.
<a id="hevea_default945"></a>
<a id="hevea_default946"></a>
<a id="hevea_default947"></a></p><p>Count how many times <span class="c004">fibonacci(0)</span> and <span class="c004">fibonacci(1)</span> are
called. This is an inefficient solution to the problem, and it gets
worse as the argument gets bigger.
<a id="hevea_default948"></a></p><p>One solution is to keep track of values that have already been
computed by storing them in a dictionary. A previously computed value
that is stored for later use is called a <span class="c010">memo</span>. Here is a
&#X201C;memoized&#X201D; version of <span class="c004">fibonacci</span>:</p><pre class="verbatim">known = {0:0, 1:1}

def fibonacci(n):
    if n in known:
        return known[n]

    res = fibonacci(n-1) + fibonacci(n-2)
    known[n] = res
    return res
</pre><p>
<span class="c004">known</span> is a dictionary that keeps track of the Fibonacci
numbers we already know. It starts with
two items: 0 maps to 0 and 1 maps to 1.</p><p>Whenever <span class="c004">fibonacci</span> is called, it checks <span class="c004">known</span>.
If the result is already there, it can return
immediately. Otherwise it has to
compute the new value, add it to the dictionary, and return it.</p><p>If you run this version of <span class="c004">fibonacci</span> and compare it with
the original, you will find that it is much faster.</p>
<!--TOC section id="sec136" Global variables-->
<h2 class="section" id="sec136">11.7&#X2003;Global variables</h2><!--SEC END --><p>
<a id="hevea_default949"></a>
<a id="hevea_default950"></a></p><p>In the previous example, <span class="c004">known</span> is created outside the function,
so it belongs to the special frame called <code class="verb">__main__</code>.
Variables in <code class="verb">__main__</code> are sometimes called <span class="c010">global</span>
because they can be accessed from any function. Unlike local
variables, which disappear when their function ends, global variables
persist from one function call to the next.
<a id="hevea_default951"></a>
<a id="hevea_default952"></a></p><p>It is common to use global variables for <span class="c010">flags</span>; that is,
boolean variables that indicate (&#X201C;flag&#X201D;) whether a condition
is true. For example, some programs use
a flag named <span class="c004">verbose</span> to control the level of detail in the
output:</p><pre class="verbatim">verbose = True

def example1():
    if verbose:
        print('Running example1')
</pre><p>
If you try to reassign a global variable, you might be surprised.
The following example is supposed to keep track of whether the
function has been called:
<a id="hevea_default953"></a></p><pre class="verbatim">been_called = False

def example2():
    been_called = True         # WRONG
</pre><p>
But if you run it you will see that the value of <code class="verb">been_called</code>
doesn&#X2019;t change. The problem is that <span class="c004">example2</span> creates a new local
variable named <code class="verb">been_called</code>. The local variable goes away when
the function ends, and has no effect on the global variable.
<a id="hevea_default954"></a>
<a id="hevea_default955"></a>
<a id="hevea_default956"></a></p><p>To reassign a global variable inside a function you have to
<span class="c010">declare</span> the global variable before you use it:</p><pre class="verbatim">been_called = False

def example2():
    global been_called
    been_called = True
</pre><p>
The <span class="c010">global statement</span> tells the interpreter
something like, &#X201C;In this function, when I say <code class="verb">been_called</code>, I
mean the global variable; don&#X2019;t create a local one.&#X201D;
<a id="hevea_default957"></a>
<a id="hevea_default958"></a></p><p>Here&#X2019;s an example that tries to update a global variable:</p><pre class="verbatim">count = 0

def example3():
    count = count + 1          # WRONG
</pre><p>
If you run it you get:
<a id="hevea_default959"></a>
<a id="hevea_default960"></a></p><pre class="verbatim">UnboundLocalError: local variable 'count' referenced before assignment
</pre><p>
Python assumes that <span class="c004">count</span> is local, and under that assumption
you are reading it before writing it. The solution, again,
is to declare <span class="c004">count</span> global.
<a id="hevea_default961"></a></p><pre class="verbatim">def example3():
    global count
    count += 1
</pre><p>
If a global variable refers to a mutable value, you can modify
the value without declaring the variable:
<a id="hevea_default962"></a></p><pre class="verbatim">known = {0:0, 1:1}

def example4():
    known[2] = 1
</pre><p>
So you can add, remove and replace elements of a global list or
dictionary, but if you want to reassign the variable, you
have to declare it:</p><pre class="verbatim">def example5():
    global known
    known = dict()
</pre><p>
Global variables can be useful, but if you have a lot of them,
and you modify them frequently, they can make programs
hard to debug.</p>
<!--TOC section id="sec137" Debugging-->
<h2 class="section" id="sec137">11.8&#X2003;Debugging</h2><!--SEC END --><p>
<a id="hevea_default963"></a></p><p>As you work with bigger datasets it can become unwieldy to
debug by printing and checking the output by hand. Here are some
suggestions for debugging large datasets:</p><dl class="description"><dt class="dt-description"><span class="c010">Scale down the input:</span></dt><dd class="dd-description"> If possible, reduce the size of the
dataset. For example if the program reads a text file, start with
just the first 10 lines, or with the smallest example you can find.
You can either edit the files themselves, or (better) modify the
program so it reads only the first <span class="c004">n</span> lines.<p>If there is an error, you can reduce <span class="c004">n</span> to the smallest
value that manifests the error, and then increase it gradually
as you find and correct errors.</p></dd><dt class="dt-description"><span class="c010">Check summaries and types:</span></dt><dd class="dd-description"> Instead of printing and checking the
entire dataset, consider printing summaries of the data: for example,
the number of items in a dictionary or the total of a list of numbers.<p>A common cause of runtime errors is a value that is not the right
type. For debugging this kind of error, it is often enough to print
the type of a value.</p></dd><dt class="dt-description"><span class="c010">Write self-checks:</span></dt><dd class="dd-description"> Sometimes you can write code to check
for errors automatically. For example, if you are computing the
average of a list of numbers, you could check that the result is
not greater than the largest element in the list or less than
the smallest. This is called a &#X201C;sanity check&#X201D; because it detects
results that are &#X201C;insane&#X201D;.
<a id="hevea_default964"></a>
<a id="hevea_default965"></a><p>Another kind of check compares the results of two different
computations to see if they are consistent. This is called a
&#X201C;consistency check&#X201D;.</p></dd><dt class="dt-description"><span class="c010">Format the output:</span></dt><dd class="dd-description"> Formatting debugging output
can make it easier to spot an error. We saw an example in
Section&#XA0;<a href="#factdebug">6.9</a>. Another tool you might find useful is the <span class="c004">pprint</span> module, which provides
a <span class="c004">pprint</span> function that displays built-in types in
a more human-readable format (<span class="c004">pprint</span> stands for
&#X201C;pretty print&#X201D;).
<a id="hevea_default966"></a>
<a id="hevea_default967"></a>
<a id="hevea_default968"></a></dd></dl><p>Again, time you spend building scaffolding can reduce
the time you spend debugging.
<a id="hevea_default969"></a></p>
<!--TOC section id="sec138" Glossary-->
<h2 class="section" id="sec138">11.9&#X2003;Glossary</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c010">mapping:</span></dt><dd class="dd-description"> A relationship in which each element of one set
corresponds to an element of another set.
<a id="hevea_default970"></a></dd><dt class="dt-description"><span class="c010">dictionary:</span></dt><dd class="dd-description"> A mapping from keys to their
corresponding values.
<a id="hevea_default971"></a></dd><dt class="dt-description"><span class="c010">key-value pair:</span></dt><dd class="dd-description"> The representation of the mapping from
a key to a value.
<a id="hevea_default972"></a></dd><dt class="dt-description"><span class="c010">item:</span></dt><dd class="dd-description"> In a dictionary, another name for a key-value
pair.
<a id="hevea_default973"></a></dd><dt class="dt-description"><span class="c010">key:</span></dt><dd class="dd-description"> An object that appears in a dictionary as the
first part of a key-value pair.
<a id="hevea_default974"></a></dd><dt class="dt-description"><span class="c010">value:</span></dt><dd class="dd-description"> An object that appears in a dictionary as the
second part of a key-value pair. This is more specific than
our previous use of the word &#X201C;value&#X201D;.
<a id="hevea_default975"></a></dd><dt class="dt-description"><span class="c010">implementation:</span></dt><dd class="dd-description"> A way of performing a computation.
<a id="hevea_default976"></a></dd><dt class="dt-description"><span class="c010">hashtable:</span></dt><dd class="dd-description"> The algorithm used to implement Python
dictionaries.
<a id="hevea_default977"></a></dd><dt class="dt-description"><span class="c010">hash function:</span></dt><dd class="dd-description"> A function used by a hashtable to compute the
location for a key.
<a id="hevea_default978"></a></dd><dt class="dt-description"><span class="c010">hashable:</span></dt><dd class="dd-description"> A type that has a hash function. Immutable
types like integers,
floats and strings are hashable; mutable types like lists and
dictionaries are not.
<a id="hevea_default979"></a></dd><dt class="dt-description"><span class="c010">lookup:</span></dt><dd class="dd-description"> A dictionary operation that takes a key and finds
the corresponding value.
<a id="hevea_default980"></a></dd><dt class="dt-description"><span class="c010">reverse lookup:</span></dt><dd class="dd-description"> A dictionary operation that takes a value and finds
one or more keys that map to it.
<a id="hevea_default981"></a></dd><dt class="dt-description"><span class="c010">raise statement:</span></dt><dd class="dd-description"> A statement that (deliberately) raises an exception.
<a id="hevea_default982"></a>
<a id="hevea_default983"></a></dd><dt class="dt-description"><span class="c010">singleton:</span></dt><dd class="dd-description"> A list (or other sequence) with a single element.
<a id="hevea_default984"></a></dd><dt class="dt-description"><span class="c010">call graph:</span></dt><dd class="dd-description"> A diagram that shows every frame created during
the execution of a program, with an arrow from each caller to
each callee.
<a id="hevea_default985"></a>
<a id="hevea_default986"></a></dd><dt class="dt-description"><span class="c010">memo:</span></dt><dd class="dd-description"> A computed value stored to avoid unnecessary future
computation.
<a id="hevea_default987"></a></dd><dt class="dt-description"><span class="c010">global variable:</span></dt><dd class="dd-description"> A variable defined outside a function. Global
variables can be accessed from any function.
<a id="hevea_default988"></a></dd><dt class="dt-description"><span class="c010">global statement:</span></dt><dd class="dd-description"> A statement that declares a variable name
global.
<a id="hevea_default989"></a>
<a id="hevea_default990"></a></dd><dt class="dt-description"><span class="c010">flag:</span></dt><dd class="dd-description"> A boolean variable used to indicate whether a condition
is true.
<a id="hevea_default991"></a></dd><dt class="dt-description"><span class="c010">declaration:</span></dt><dd class="dd-description"> A statement like <span class="c004">global</span> that tells the
interpreter something about a variable.
<a id="hevea_default992"></a></dd></dl>
<!--TOC section id="sec139" Exercises-->
<h2 class="section" id="sec139">11.10&#X2003;Exercises</h2><!--SEC END --><div class="theorem"><span class="c010">Exercise&#XA0;1</span>&#X2003;
<a id="wordlist2"></a>
<a id="hevea_default993"></a>
<a id="hevea_default994"></a><p><em>Write a function that reads the words in <span class="c004">words.txt</span> and
stores them as keys in a dictionary. It doesn&#X2019;t matter what the
values are. Then you can use the <span class="c004">in</span> operator
as a fast way to check whether a string is in
the dictionary.</em></p><p><em>If you did Exercise&#XA0;</em><a href="#wordlist1"><em>10</em></a><em>, you can compare the speed
of this implementation with the list <span class="c004">in</span> operator and the
bisection search.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;2</span>&#X2003;
<a id="setdefault"></a><p><em>Read the documentation of the dictionary method <span class="c004">setdefault</span>
and use it to write a more concise version of </em><code class="verb"><em>invert_dict</em></code><em>.
Solution: </em><a href="https://thinkpython.com/code/invert_dict.py"><span class="c004"><em>https://thinkpython.com/code/invert_dict.py</em></span></a><em>.
</em><a id="hevea_default995"></a>
<a id="hevea_default996"></a></p></div><div class="theorem"><span class="c010">Exercise&#XA0;3</span>&#X2003;<em>
Memoize the Ackermann function from Exercise&#XA0;</em><a href="#ackermann"><em>2</em></a><em> and see if
memoization makes it possible to evaluate the function with bigger
arguments. Hint: no.
Solution: </em><a href="https://thinkpython.com/code/ackermann_memo.py"><span class="c004"><em>https://thinkpython.com/code/ackermann_memo.py</em></span></a><em>.
</em><a id="hevea_default997"></a>
<a id="hevea_default998"></a></div><div class="theorem"><span class="c010">Exercise&#XA0;4</span>&#X2003;
<a id="hevea_default999"></a><p><em>If you did Exercise&#XA0;</em><a href="#duplicate"><em>7</em></a><em>, you already have
a function named </em><code class="verb"><em>has_duplicates</em></code><em> that takes a list
as a parameter and returns <span class="c004">True</span> if there is any object
that appears more than once in the list.</em></p><p><em>Use a dictionary to write a faster, simpler version of
</em><code class="verb"><em>has_duplicates</em></code><em>.
Solution: </em><a href="https://thinkpython.com/code/has_duplicates.py"><em><span class="c004">https://thinkpython.com/code/has_duplicates.py</span></em></a><em>.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;5</span>&#X2003;
<a id="exrotatepairs"></a>
<a id="hevea_default1000"></a>
<a id="hevea_default1001"></a><p><em>Two words are &#X201C;rotate pairs&#X201D; if you can rotate one of them
and get the other (see </em><code class="verb"><em>rotate_word</em></code><em> in Exercise&#XA0;</em><a href="#exrotate"><em>5</em></a><em>).</em></p><p><em>Write a program that reads a wordlist and finds all the rotate
pairs. Solution: </em><a href="https://thinkpython.com/code/rotate_pairs.py"><em><span class="c004">https://thinkpython.com/code/rotate_pairs.py</span></em></a><em>.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;6</span>&#X2003;
<a id="hevea_default1002"></a>
<a id="hevea_default1003"></a><p><em>Here&#X2019;s another Puzzler from </em>Car Talk<em>
(</em><a href="http://www.cartalk.com/content/puzzlers"><em><span class="c004">http://www.cartalk.com/content/puzzlers</span></em></a><em>):</em></p><blockquote class="quote"><em>
This was sent in by a fellow named Dan O&#X2019;Leary. He came upon a common
one-syllable, five-letter word recently that has the following unique
property. When you remove the first letter, the remaining letters form
a homophone of the original word, that is a word that sounds exactly
the same. Replace the first letter, that is, put it back and remove
the second letter and the result is yet another homophone of the
original word. And the question is, what&#X2019;s the word?</em><p><em>Now I&#X2019;m going to give you an example that doesn&#X2019;t work. Let&#X2019;s look at
the five-letter word, &#X2018;wrack.&#X2019; W-R-A-C-K, you know like to &#X2018;wrack with
pain.&#X2019; If I remove the first letter, I am left with a four-letter
word, &#X2019;R-A-C-K.&#X2019; As in, &#X2018;Holy cow, did you see the rack on that buck!
It must have been a nine-pointer!&#X2019; It&#X2019;s a perfect homophone. If you
put the &#X2018;w&#X2019; back, and remove the &#X2018;r,&#X2019; instead, you&#X2019;re left with the
word, &#X2018;wack,&#X2019; which is a real word, it&#X2019;s just not a homophone of the
other two words.</em></p><p><em>But there is, however, at least one word that Dan and we know of,
which will yield two homophones if you remove either of the first two
letters to make two, new four-letter words. The question is, what&#X2019;s
the word?
</em></p></blockquote><p>
<a id="hevea_default1004"></a>
<a id="hevea_default1005"></a>
<a id="hevea_default1006"></a></p><p><em>You can use the dictionary from Exercise&#XA0;</em><a href="#wordlist2"><em>1</em></a><em> to check
whether a string is in the word list.</em></p><p><em>To check whether two words are homophones, you can use the CMU
Pronouncing Dictionary. You can download it from
</em><a href="http://www.speech.cs.cmu.edu/cgi-bin/cmudict"><em><span class="c004">http://www.speech.cs.cmu.edu/cgi-bin/cmudict</span></em></a><em> or from
</em><a href="https://thinkpython.com/code/c06d"><em><span class="c004">https://thinkpython.com/code/c06d</span></em></a><em> and you can also download
</em><a href="https://thinkpython.com/code/pronounce.py"><em><span class="c004">https://thinkpython.com/code/pronounce.py</span></em></a><em>, which provides a function
named </em><code class="verb"><em>read_dictionary</em></code><em> that reads the pronouncing dictionary and
returns a Python dictionary that maps from each word to a string that
describes its primary pronunciation.</em></p><p><em>Write a program that lists all the words that solve the Puzzler.
Solution: </em><a href="https://thinkpython.com/code/homophone.py"><em><span class="c004">https://thinkpython.com/code/homophone.py</span></em></a><em>.</em></p></div>
<!--TOC chapter id="sec140" Tuples-->
<h1 class="chapter" id="sec140">Chapter&#XA0;12&#X2003;Tuples</h1><!--SEC END --><p>
<a id="tuplechap"></a></p><p>This chapter presents one more built-in type, the tuple, and then
shows how lists, dictionaries, and tuples work together.
I also present a useful feature for variable-length argument lists,
the gather and scatter operators.</p><p>One note: there is no consensus on how to pronounce &#X201C;tuple&#X201D;.
Some people say &#X201C;tuh-ple&#X201D;, which rhymes with &#X201C;supple&#X201D;. But
in the context of programming, most people say &#X201C;too-ple&#X201D;, which
rhymes with &#X201C;quadruple&#X201D;.</p>
<!--TOC section id="sec141" Tuples are immutable-->
<h2 class="section" id="sec141">12.1&#X2003;Tuples are immutable</h2><!--SEC END --><p>
<a id="hevea_default1007"></a>
<a id="hevea_default1008"></a>
<a id="hevea_default1009"></a></p><p>A tuple is a sequence of values. The values can be any type, and
they are indexed by integers, so in that respect tuples are a lot
like lists. The important difference is that tuples are immutable.
<a id="hevea_default1010"></a>
<a id="hevea_default1011"></a></p><p>Syntactically, a tuple is a comma-separated list of values:</p><pre class="verbatim">&gt;&gt;&gt; t = 'a', 'b', 'c', 'd', 'e'
</pre><p>
Although it is not necessary, it is common to enclose tuples in
parentheses:
<a id="hevea_default1012"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ('a', 'b', 'c', 'd', 'e')
</pre><p>
To create a tuple with a single element, you have to include a final
comma:
<a id="hevea_default1013"></a>
<a id="hevea_default1014"></a></p><pre class="verbatim">&gt;&gt;&gt; t1 = 'a',
&gt;&gt;&gt; type(t1)
&lt;class 'tuple'&gt;
</pre><p>
A value in parentheses is not a tuple:</p><pre class="verbatim">&gt;&gt;&gt; t2 = ('a')
&gt;&gt;&gt; type(t2)
&lt;class 'str'&gt;
</pre><p>
Another way to create a tuple is the built-in function <span class="c004">tuple</span>.
With no argument, it creates an empty tuple:
<a id="hevea_default1015"></a>
<a id="hevea_default1016"></a></p><pre class="verbatim">&gt;&gt;&gt; t = tuple()
&gt;&gt;&gt; t
()
</pre><p>
If the argument is a sequence (string, list or tuple), the result
is a tuple with the elements of the sequence:</p><pre class="verbatim">&gt;&gt;&gt; t = tuple('lupins')
&gt;&gt;&gt; t
('l', 'u', 'p', 'i', 'n', 's')
</pre><p>
Because <span class="c004">tuple</span> is the name of a built-in function, you should
avoid using it as a variable name.</p><p>Most list operators also work on tuples. The bracket operator
indexes an element:
<a id="hevea_default1017"></a>
<a id="hevea_default1018"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ('a', 'b', 'c', 'd', 'e')
&gt;&gt;&gt; t[0]
'a'
</pre><p>
And the slice operator selects a range of elements.
<a id="hevea_default1019"></a>
<a id="hevea_default1020"></a>
<a id="hevea_default1021"></a>
<a id="hevea_default1022"></a></p><pre class="verbatim">&gt;&gt;&gt; t[1:3]
('b', 'c')
</pre><p>
But if you try to modify one of the elements of the tuple, you get
an error:
<a id="hevea_default1023"></a>
<a id="hevea_default1024"></a>
<a id="hevea_default1025"></a>
<a id="hevea_default1026"></a></p><pre class="verbatim">&gt;&gt;&gt; t[0] = 'A'
TypeError: object doesn't support item assignment
</pre><p>
Because tuples are immutable, you can&#X2019;t modify the elements. But you
can replace one tuple with another:</p><pre class="verbatim">&gt;&gt;&gt; t = ('A',) + t[1:]
&gt;&gt;&gt; t
('A', 'b', 'c', 'd', 'e')
</pre><p>
This statement makes a new tuple and then makes <span class="c004">t</span> refer to it.</p><p>The relational operators work with tuples and other sequences;
Python starts by comparing the first element from each
sequence. If they are equal, it goes on to the next elements,
and so on, until it finds elements that differ. Subsequent
elements are not considered (even if they are really big).
<a id="hevea_default1027"></a>
<a id="hevea_default1028"></a></p><pre class="verbatim">&gt;&gt;&gt; (0, 1, 2) &lt; (0, 3, 4)
True
&gt;&gt;&gt; (0, 1, 2000000) &lt; (0, 3, 4)
True
</pre>
<!--TOC section id="sec142" Tuple assignment-->
<h2 class="section" id="sec142">12.2&#X2003;Tuple assignment</h2><!--SEC END --><p>
<a id="tuple.assignment"></a>
<a id="hevea_default1029"></a>
<a id="hevea_default1030"></a>
<a id="hevea_default1031"></a>
<a id="hevea_default1032"></a></p><p>It is often useful to swap the values of two variables.
With conventional assignments, you have to use a temporary
variable. For example, to swap <span class="c004">a</span> and <span class="c004">b</span>:</p><pre class="verbatim">&gt;&gt;&gt; temp = a
&gt;&gt;&gt; a = b
&gt;&gt;&gt; b = temp
</pre><p>
This solution is cumbersome; <span class="c010">tuple assignment</span> is more elegant:</p><pre class="verbatim">&gt;&gt;&gt; a, b = b, a
</pre><p>
The left side is a tuple of variables; the right side is a tuple of
expressions. Each value is assigned to its respective variable.
All the expressions on the right side are evaluated before any
of the assignments.</p><p>The number of variables on the left and the number of
values on the right have to be the same:
<a id="hevea_default1033"></a>
<a id="hevea_default1034"></a></p><pre class="verbatim">&gt;&gt;&gt; a, b = 1, 2, 3
ValueError: too many values to unpack
</pre><p>
More generally, the right side can be any kind of sequence
(string, list or tuple). For example, to split an email address
into a user name and a domain, you could write:
<a id="hevea_default1035"></a>
<a id="hevea_default1036"></a>
<a id="hevea_default1037"></a></p><pre class="verbatim">&gt;&gt;&gt; addr = 'monty@python.org'
&gt;&gt;&gt; uname, domain = addr.split('@')
</pre><p>
The return value from <span class="c004">split</span> is a list with two elements;
the first element is assigned to <span class="c004">uname</span>, the second to
<span class="c004">domain</span>.</p><pre class="verbatim">&gt;&gt;&gt; uname
'monty'
&gt;&gt;&gt; domain
'python.org'
</pre>
<!--TOC section id="sec143" Tuples as return values-->
<h2 class="section" id="sec143">12.3&#X2003;Tuples as return values</h2><!--SEC END --><p>
<a id="hevea_default1038"></a>
<a id="hevea_default1039"></a>
<a id="hevea_default1040"></a>
<a id="hevea_default1041"></a></p><p>Strictly speaking, a function can only return one value, but
if the value is a tuple, the effect is the same as returning
multiple values. For example, if you want to divide two integers
and compute the quotient and remainder, it is inefficient to
compute <span class="c004">x//y</span> and then <span class="c004">x%y</span>. It is better to compute
them both at the same time.
<a id="hevea_default1042"></a></p><p>The built-in function <span class="c004">divmod</span> takes two arguments and
returns a tuple of two values, the quotient and remainder.
You can store the result as a tuple:</p><pre class="verbatim">&gt;&gt;&gt; t = divmod(7, 3)
&gt;&gt;&gt; t
(2, 1)
</pre><p>
Or use tuple assignment to store the elements separately:
<a id="hevea_default1043"></a>
<a id="hevea_default1044"></a></p><pre class="verbatim">&gt;&gt;&gt; quot, rem = divmod(7, 3)
&gt;&gt;&gt; quot
2
&gt;&gt;&gt; rem
1
</pre><p>
Here is an example of a function that returns a tuple:</p><pre class="verbatim">def min_max(t):
    return min(t), max(t)
</pre><p>
<span class="c004">max</span> and <span class="c004">min</span> are built-in functions that find
the largest and smallest elements of a sequence. <code class="verb">min_max</code>
computes both and returns a tuple of two values.
<a id="hevea_default1045"></a>
<a id="hevea_default1046"></a>
<a id="hevea_default1047"></a>
<a id="hevea_default1048"></a></p>
<!--TOC section id="sec144" Variable-length argument tuples-->
<h2 class="section" id="sec144">12.4&#X2003;Variable-length argument tuples</h2><!--SEC END --><p>
<a id="gather"></a>
<a id="hevea_default1049"></a>
<a id="hevea_default1050"></a>
<a id="hevea_default1051"></a>
<a id="hevea_default1052"></a>
<a id="hevea_default1053"></a></p><p>Functions can take a variable number of arguments. A parameter
name that begins with <span class="c004">*</span> <span class="c010">gathers</span> arguments into
a tuple. For example, <span class="c004">printall</span>
takes any number of arguments and prints them:</p><pre class="verbatim">def printall(*args):
    print(args)
</pre><p>
The gather parameter can have any name you like, but <span class="c004">args</span> is
conventional. Here&#X2019;s how the function works:</p><pre class="verbatim">&gt;&gt;&gt; printall(1, 2.0, '3')
(1, 2.0, '3')
</pre><p>
The complement of gather is <span class="c010">scatter</span>. If you have a
sequence of values and you want to pass it to a function
as multiple arguments, you can use the <span class="c004">*</span> operator.
For example, <span class="c004">divmod</span> takes exactly two arguments; it
doesn&#X2019;t work with a tuple:
<a id="hevea_default1054"></a>
<a id="hevea_default1055"></a>
<a id="hevea_default1056"></a>
<a id="hevea_default1057"></a></p><pre class="verbatim">&gt;&gt;&gt; t = (7, 3)
&gt;&gt;&gt; divmod(t)
TypeError: divmod expected 2 arguments, got 1
</pre><p>
But if you scatter the tuple, it works:</p><pre class="verbatim">&gt;&gt;&gt; divmod(*t)
(2, 1)
</pre><p>
Many of the built-in functions use
variable-length argument tuples. For example, <span class="c004">max</span>
and <span class="c004">min</span> can take any number of arguments:
<a id="hevea_default1058"></a>
<a id="hevea_default1059"></a>
<a id="hevea_default1060"></a>
<a id="hevea_default1061"></a></p><pre class="verbatim">&gt;&gt;&gt; max(1, 2, 3)
3
</pre><p>
But <span class="c004">sum</span> does not.
<a id="hevea_default1062"></a>
<a id="hevea_default1063"></a></p><pre class="verbatim">&gt;&gt;&gt; sum(1, 2, 3)
TypeError: sum expected at most 2 arguments, got 3
</pre><p>
As an exercise, write a function called <code class="verb">sum_all</code> that takes any number
of arguments and returns their sum.</p>
<!--TOC section id="sec145" Lists and tuples-->
<h2 class="section" id="sec145">12.5&#X2003;Lists and tuples</h2><!--SEC END --><p>
<a id="hevea_default1064"></a>
<a id="hevea_default1065"></a></p><p><span class="c004">zip</span> is a built-in function that takes two or more sequences and
interleaves them. The name of the function refers to
a zipper, which interleaves two rows of teeth.</p><p>This example zips a string and a list:</p><pre class="verbatim">&gt;&gt;&gt; s = 'abc'
&gt;&gt;&gt; t = [0, 1, 2]
&gt;&gt;&gt; zip(s, t)
&lt;zip object at 0x7f7d0a9e7c48&gt;
</pre><p>
The result is a <span class="c010">zip object</span> that knows how to iterate through
the pairs. The most common use of <span class="c004">zip</span> is in a <span class="c004">for</span> loop:</p><pre class="verbatim">&gt;&gt;&gt; for pair in zip(s, t):
...     print(pair)
...
('a', 0)
('b', 1)
('c', 2)
</pre><p>
A zip object is a kind of <span class="c010">iterator</span>, which is any object
that iterates through a sequence. Iterators are similar to lists in some
ways, but unlike lists, you can&#X2019;t use an index to select an element from
an iterator.
<a id="hevea_default1066"></a></p><p>If you want to use list operators and methods, you can
use a zip object to make a list:</p><pre class="verbatim">&gt;&gt;&gt; list(zip(s, t))
[('a', 0), ('b', 1), ('c', 2)]
</pre><p>
The result is a list of tuples; in this example, each tuple contains
a character from the string and the corresponding element from
the list.
<a id="hevea_default1067"></a></p><p>If the sequences are not the same length, the result has the
length of the shorter one.</p><pre class="verbatim">&gt;&gt;&gt; list(zip('Anne', 'Elk'))
[('A', 'E'), ('n', 'l'), ('n', 'k')]
</pre><p>
You can use tuple assignment in a <span class="c004">for</span> loop to traverse a list of
tuples:
<a id="hevea_default1068"></a>
<a id="hevea_default1069"></a>
<a id="hevea_default1070"></a></p><pre class="verbatim">t = [('a', 0), ('b', 1), ('c', 2)]
for letter, number in t:
    print(number, letter)
</pre><p>
Each time through the loop, Python selects the next tuple in
the list and assigns the elements to <span class="c004">letter</span> and
<span class="c004">number</span>. The output of this loop is:
<a id="hevea_default1071"></a></p><pre class="verbatim">0 a
1 b
2 c
</pre><p>
If you combine <span class="c004">zip</span>, <span class="c004">for</span> and tuple assignment, you get a
useful idiom for traversing two (or more) sequences at the same
time. For example, <code class="verb">has_match</code> takes two sequences, <span class="c004">t1</span> and
<span class="c004">t2</span>, and returns <span class="c004">True</span> if there is an index <span class="c004">i</span>
such that <span class="c004">t1[i] == t2[i]</span>:
<a id="hevea_default1072"></a></p><pre class="verbatim">def has_match(t1, t2):
    for x, y in zip(t1, t2):
        if x == y:
            return True
    return False
</pre><p>
If you need to traverse the elements of a sequence and their
indices, you can use the built-in function <span class="c004">enumerate</span>:
<a id="hevea_default1073"></a>
<a id="hevea_default1074"></a>
<a id="hevea_default1075"></a></p><pre class="verbatim">for index, element in enumerate('abc'):
    print(index, element)
</pre><p>
The result from <span class="c004">enumerate</span> is an enumerate object, which
iterates a sequence of pairs; each pair contains an index (starting
from 0) and an element from the given sequence.
In this example, the output is</p><pre class="verbatim">0 a
1 b
2 c
</pre><p>
Again.
<a id="hevea_default1076"></a>
<a id="hevea_default1077"></a>
<a id="hevea_default1078"></a></p>
<!--TOC section id="sec146" Dictionaries and tuples-->
<h2 class="section" id="sec146">12.6&#X2003;Dictionaries and tuples</h2><!--SEC END --><p>
<a id="dictuple"></a>
<a id="hevea_default1079"></a>
<a id="hevea_default1080"></a>
<a id="hevea_default1081"></a>
<a id="hevea_default1082"></a></p><p>Dictionaries have a method called <span class="c004">items</span> that returns a sequence of
tuples, where each tuple is a key-value pair.</p><pre class="verbatim">&gt;&gt;&gt; d = {'a':0, 'b':1, 'c':2}
&gt;&gt;&gt; t = d.items()
&gt;&gt;&gt; t
dict_items([('c', 2), ('a', 0), ('b', 1)])
</pre><p>
The result is a <code class="verb">dict_items</code> object, which is an iterator that
iterates the key-value pairs. You can use it in a <span class="c004">for</span> loop
like this:
<a id="hevea_default1083"></a></p><pre class="verbatim">&gt;&gt;&gt; for key, value in d.items():
...     print(key, value)
...
c 2
a 0
b 1
</pre><p>
As you should expect from a dictionary, the items are in no
particular order.</p><p>Going in the other direction, you can use a list of tuples to
initialize a new dictionary: <a id="hevea_default1084"></a></p><pre class="verbatim">&gt;&gt;&gt; t = [('a', 0), ('c', 2), ('b', 1)]
&gt;&gt;&gt; d = dict(t)
&gt;&gt;&gt; d
{'a': 0, 'c': 2, 'b': 1}
</pre><p>Combining <span class="c004">dict</span> with <span class="c004">zip</span> yields a concise way
to create a dictionary:
<a id="hevea_default1085"></a></p><pre class="verbatim">&gt;&gt;&gt; d = dict(zip('abc', range(3)))
&gt;&gt;&gt; d
{'a': 0, 'c': 2, 'b': 1}
</pre><p>
The dictionary method <span class="c004">update</span> also takes a list of tuples
and adds them, as key-value pairs, to an existing dictionary.
<a id="hevea_default1086"></a>
<a id="hevea_default1087"></a>
<a id="hevea_default1088"></a>
<a id="hevea_default1089"></a></p><p>It is common to use tuples as keys in dictionaries (primarily because
you can&#X2019;t use lists). For example, a telephone directory might map
from last-name, first-name pairs to telephone numbers. Assuming
that we have defined <span class="c004">last</span>, <span class="c004">first</span> and <span class="c004">number</span>, we
could write:
<a id="hevea_default1090"></a>
<a id="hevea_default1091"></a></p><pre class="verbatim">directory[last, first] = number
</pre><p>
The expression in brackets is a tuple. We could use tuple
assignment to traverse this dictionary.
<a id="hevea_default1092"></a></p><pre class="verbatim">for last, first in directory:
    print(first, last, directory[last,first])
</pre><p>
This loop traverses the keys in <span class="c004">directory</span>, which are tuples. It
assigns the elements of each tuple to <span class="c004">last</span> and <span class="c004">first</span>, then
prints the name and corresponding telephone number.</p><p>There are two ways to represent tuples in a state diagram. The more
detailed version shows the indices and elements just as they appear in
a list. For example, the tuple <code class="verb">('Cleese', 'John')</code> would appear
as in Figure&#XA0;<a href="#fig.tuple1">12.1</a>.
<a id="hevea_default1093"></a>
<a id="hevea_default1094"></a></p><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2018.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 12.1: State diagram.</td></tr>
</table></div>
<a id="fig.tuple1"></a>
<div class="center"><hr class="floatrule"></div></blockquote><p>But in a larger diagram you might want to leave out the
details. For example, a diagram of the telephone directory might
appear as in Figure&#XA0;<a href="#fig.dict2">12.2</a>.</p><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2019.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 12.2: State diagram.</td></tr>
</table></div>
<a id="fig.dict2"></a>
<div class="center"><hr class="floatrule"></div></blockquote><p>Here the tuples are shown using Python syntax as a graphical
shorthand. The telephone number in the diagram is the complaints line
for the BBC, so please don&#X2019;t call it.</p>
<!--TOC section id="sec147" Sequences of sequences-->
<h2 class="section" id="sec147">12.7&#X2003;Sequences of sequences</h2><!--SEC END --><p>
<a id="hevea_default1095"></a></p><p>I have focused on lists of tuples, but almost all of the examples in
this chapter also work with lists of lists, tuples of tuples, and
tuples of lists. To avoid enumerating the possible combinations, it
is sometimes easier to talk about sequences of sequences.</p><p>In many contexts, the different kinds of sequences (strings, lists and
tuples) can be used interchangeably. So how should you choose one
over the others?
<a id="hevea_default1096"></a>
<a id="hevea_default1097"></a>
<a id="hevea_default1098"></a>
<a id="hevea_default1099"></a>
<a id="hevea_default1100"></a></p><p>To start with the obvious, strings are more limited than other
sequences because the elements have to be characters. They are
also immutable. If you need the ability to change the characters
in a string (as opposed to creating a new string), you might
want to use a list of characters instead.</p><p>Lists are more common than tuples, mostly because they are mutable.
But there are a few cases where you might prefer tuples:</p><ol class="enumerate" type=1><li class="li-enumerate">In some contexts, like a <span class="c004">return</span> statement, it is
syntactically simpler to create a tuple than a list.</li><li class="li-enumerate">If you want to use a sequence as a dictionary key, you
have to use an immutable type like a tuple or string.</li><li class="li-enumerate">If you are passing a sequence as an argument to a function,
using tuples reduces the potential for unexpected behavior
due to aliasing.</li></ol><p>Because tuples are immutable, they don&#X2019;t provide methods like <span class="c004">sort</span> and <span class="c004">reverse</span>, which modify existing lists. But Python
provides the built-in function <span class="c004">sorted</span>, which takes any sequence
and returns a new list with the same elements in sorted order, and
<span class="c004">reversed</span>, which takes a sequence and returns an iterator that
traverses the list in reverse order.
<a id="hevea_default1101"></a>
<a id="hevea_default1102"></a> <a id="hevea_default1103"></a>
<a id="hevea_default1104"></a>
<a id="hevea_default1105"></a></p>
<!--TOC section id="sec148" Debugging-->
<h2 class="section" id="sec148">12.8&#X2003;Debugging</h2><!--SEC END --><p>
<a id="hevea_default1106"></a>
<a id="hevea_default1107"></a>
<a id="hevea_default1108"></a>
<a id="hevea_default1109"></a></p><p>Lists, dictionaries and tuples are examples of <span class="c010">data
structures</span>; in this chapter we are starting to see compound data
structures, like lists of tuples, or dictionaries that contain tuples
as keys and lists as values. Compound data structures are useful, but
they are prone to what I call <span class="c010">shape errors</span>; that is, errors
caused when a data structure has the wrong type, size, or structure.
For example, if you are expecting a list with one integer and I
give you a plain old integer (not in a list), it won&#X2019;t work.
<a id="hevea_default1110"></a>
<a id="hevea_default1111"></a></p><p>To help debug these kinds of errors, I have written a module
called <span class="c004">structshape</span> that provides a function, also called
<span class="c004">structshape</span>, that takes any kind of data structure as
an argument and returns a string that summarizes its shape.
You can download it from <a href="https://thinkpython.com/code/structshape.py"><span class="c004">https://thinkpython.com/code/structshape.py</span></a></p><p>Here&#X2019;s the result for a simple list:</p><pre class="verbatim">&gt;&gt;&gt; from structshape import structshape
&gt;&gt;&gt; t = [1, 2, 3]
&gt;&gt;&gt; structshape(t)
'list of 3 int'
</pre><p>
A fancier program might write &#X201C;list of 3 int<em>s</em>&#X201D;, but it
was easier not to deal with plurals. Here&#X2019;s a list of lists:</p><pre class="verbatim">&gt;&gt;&gt; t2 = [[1,2], [3,4], [5,6]]
&gt;&gt;&gt; structshape(t2)
'list of 3 list of 2 int'
</pre><p>
If the elements of the list are not the same type,
<span class="c004">structshape</span> groups them, in order, by type:</p><pre class="verbatim">&gt;&gt;&gt; t3 = [1, 2, 3, 4.0, '5', '6', [7], [8], 9]
&gt;&gt;&gt; structshape(t3)
'list of (3 int, float, 2 str, 2 list of int, int)'
</pre><p>
Here&#X2019;s a list of tuples:</p><pre class="verbatim">&gt;&gt;&gt; s = 'abc'
&gt;&gt;&gt; lt = list(zip(t, s))
&gt;&gt;&gt; structshape(lt)
'list of 3 tuple of (int, str)'
</pre><p>
And here&#X2019;s a dictionary with 3 items that map integers to strings.</p><pre class="verbatim">&gt;&gt;&gt; d = dict(lt)
&gt;&gt;&gt; structshape(d)
'dict of 3 int-&gt;str'
</pre><p>
If you are having trouble keeping track of your data structures,
<span class="c004">structshape</span> can help.</p>
<!--TOC section id="sec149" Glossary-->
<h2 class="section" id="sec149">12.9&#X2003;Glossary</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c010">tuple:</span></dt><dd class="dd-description"> An immutable sequence of elements.
<a id="hevea_default1112"></a></dd><dt class="dt-description"><span class="c010">tuple assignment:</span></dt><dd class="dd-description"> An assignment with a sequence on the
right side and a tuple of variables on the left. The right
side is evaluated and then its elements are assigned to the
variables on the left.
<a id="hevea_default1113"></a>
<a id="hevea_default1114"></a></dd><dt class="dt-description"><span class="c010">gather:</span></dt><dd class="dd-description"> An operation that collects multiple arguments into a tuple.
<a id="hevea_default1115"></a></dd><dt class="dt-description"><span class="c010">scatter:</span></dt><dd class="dd-description"> An operation that makes a sequence behave like multiple arguments.
<a id="hevea_default1116"></a></dd><dt class="dt-description"><span class="c010">zip object:</span></dt><dd class="dd-description"> The result of calling a built-in function <span class="c004">zip</span>;
an object that iterates through a sequence of tuples.
<a id="hevea_default1117"></a>
<a id="hevea_default1118"></a></dd><dt class="dt-description"><span class="c010">iterator:</span></dt><dd class="dd-description"> An object that can iterate through a sequence, but
which does not provide list operators and methods.
<a id="hevea_default1119"></a></dd><dt class="dt-description"><span class="c010">data structure:</span></dt><dd class="dd-description"> A collection of related values, often
organized in lists, dictionaries, tuples, etc.
<a id="hevea_default1120"></a></dd><dt class="dt-description"><span class="c010">shape error:</span></dt><dd class="dd-description"> An error caused because a value has the
wrong shape; that is, the wrong type or size.
<a id="hevea_default1121"></a></dd></dl>
<!--TOC section id="sec150" Exercises-->
<h2 class="section" id="sec150">12.10&#X2003;Exercises</h2><!--SEC END --><div class="theorem"><span class="c010">Exercise&#XA0;1</span>&#X2003;<p><em>Write a function called </em><code class="verb"><em>most_frequent</em></code><em> that takes a string and
prints the letters in decreasing order of frequency. Find text
samples from several different languages and see how letter frequency
varies between languages. Compare your results with the tables at
</em><a href="http://en.wikipedia.org/wiki/Letter_frequencies"><span class="c004"><em>http://en.wikipedia.org/wiki/Letter_frequencies</em></span></a><em>. Solution:
</em><a href="https://thinkpython.com/code/most_frequent.py"><span class="c004"><em>https://thinkpython.com/code/most_frequent.py</em></span></a><em>. </em><a id="hevea_default1122"></a> <a id="hevea_default1123"></a></p></div><div class="theorem"><span class="c010">Exercise&#XA0;2</span>&#X2003;
<a id="anagrams"></a>
<a id="hevea_default1124"></a>
<a id="hevea_default1125"></a><p><em>More anagrams!</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Write a program
that reads a word list from a file (see Section&#XA0;</em><a href="#wordlist"><em>9.1</em></a><em>) and
prints all the sets of words that are anagrams.</em><p><em>Here is an example of what the output might look like:</em></p><pre class="verbatim"><em>['deltas', 'desalt', 'lasted', 'salted', 'slated', 'staled']
['retainers', 'ternaries']
['generating', 'greatening']
['resmelts', 'smelters', 'termless']
</em></pre><p><em>
Hint: you might want to build a dictionary that maps from a
collection of letters to a list of words that can be spelled with those
letters. The question is, how can you represent the collection of
letters in a way that can be used as a key?</em></p></li><li class="li-enumerate"><em>Modify the previous program so that it prints the longest list
of anagrams first, followed by the second longest, and so on.
</em><a id="hevea_default1126"></a>
<a id="hevea_default1127"></a></li><li class="li-enumerate"><em>In Scrabble a &#X201C;bingo&#X201D; is when you play all seven tiles in
your rack, along with a letter on the board, to form an eight-letter
word. What collection of 8 letters forms the most possible bingos?</em><p><em>Solution: </em><a href="https://thinkpython.com/code/anagram_sets.py"><span class="c004"><em>https://thinkpython.com/code/anagram_sets.py</em></span></a><em>.</em></p></li></ol></div><div class="theorem"><span class="c010">Exercise&#XA0;3</span>&#X2003;
<a id="hevea_default1128"></a><p><em>Two words form a &#X201C;metathesis pair&#X201D; if you can transform one into the
other by swapping two letters; for example, &#X201C;converse&#X201D; and
&#X201C;conserve&#X201D;. Write a program that finds all of the metathesis pairs
in the dictionary. Hint: don&#X2019;t test all pairs of words, and don&#X2019;t
test all possible swaps. Solution:
</em><a href="https://thinkpython.com/code/metathesis.py"><em><span class="c004">https://thinkpython.com/code/metathesis.py</span></em></a><em>. Credit: This
exercise is inspired by an example at </em><a href="http://puzzlers.org"><em><span class="c004">http://puzzlers.org</span></em></a><em>.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;4</span>&#X2003;
<a id="hevea_default1129"></a>
<a id="hevea_default1130"></a><p><em>Here&#X2019;s another Car Talk Puzzler
(</em><a href="http://www.cartalk.com/content/puzzlers"><em><span class="c004">http://www.cartalk.com/content/puzzlers</span></em></a><em>):</em></p><blockquote class="quote"><em>
What is the longest English word, that remains a valid English word,
as you remove its letters one at a time?</em><p><em>Now, letters can be removed from either end, or the middle, but you
can&#X2019;t rearrange any of the letters. Every time you drop a letter, you
wind up with another English word. If you do that, you&#X2019;re eventually
going to wind up with one letter and that too is going to be an
English word&#X2014;one that&#X2019;s found in the dictionary. I want to know
what&#X2019;s the longest word and how many letters does it
have?</em></p><p><em>I&#X2019;m going to give you a little modest example: Sprite. Ok? You start
off with sprite, you take a letter off, one from the interior of the
word, take the r away, and we&#X2019;re left with the word spite, then we
take the e off the end, we&#X2019;re left with spit, we take the s off, we&#X2019;re
left with pit, it, and I.
</em></p></blockquote><p>
<a id="hevea_default1131"></a>
<a id="hevea_default1132"></a></p><p><em>Write a program to find all words that can be reduced in this way,
and then find the longest one.</em></p><p><em>This exercise is a little more challenging than most, so here are
some suggestions:</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>You might want to write a function that takes a word and
computes a list of all the words that can be formed by removing one
letter. These are the &#X201C;children&#X201D; of the word.
</em><a id="hevea_default1133"></a>
<a id="hevea_default1134"></a></li><li class="li-enumerate"><em>Recursively, a word is reducible if any of its children
are reducible. As a base case, you can consider the empty
string reducible.</em></li><li class="li-enumerate"><em>The wordlist I provided, <span class="c004">words.txt</span>, doesn&#X2019;t
contain single letter words. So you might want to add
&#X201C;I&#X201D;, &#X201C;a&#X201D;, and the empty string.</em></li><li class="li-enumerate"><em>To improve the performance of your program, you might want
to memoize the words that are known to be reducible.</em></li></ol><p><em>Solution: </em><a href="https://thinkpython.com/code/reducible.py"><em><span class="c004">https://thinkpython.com/code/reducible.py</span></em></a><em>.</em></p></div>
<!--TOC chapter id="sec151" Case study: data structure selection-->
<h1 class="chapter" id="sec151">Chapter&#XA0;13&#X2003;Case study: data structure selection</h1><!--SEC END --><p>At this point you have learned about Python&#X2019;s core data structures,
and you have seen some of the algorithms that use them.
If you would like to know more about algorithms, this might be a good
time to read Chapter&#XA0;<a href="#algorithms">B</a>.
But you don&#X2019;t have to read it before you go on; you can read
it whenever you are interested.</p><p>This chapter presents a case study with exercises that let
you think about choosing data structures and practice using them.</p>
<!--TOC section id="sec152" Word frequency analysis-->
<h2 class="section" id="sec152">13.1&#X2003;Word frequency analysis</h2><!--SEC END --><p>
<a id="analysis"></a></p><p>As usual, you should at least attempt the exercises
before you read my solutions.</p><div class="theorem"><span class="c010">Exercise&#XA0;1</span>&#X2003;<p><em>Write a program that reads a file, breaks each line into
words, strips whitespace and punctuation from the words, and
converts them to lowercase.
</em><a id="hevea_default1135"></a>
<a id="hevea_default1136"></a></p><p><em>Hint: The <span class="c004">string</span> module provides a string named <span class="c004">whitespace</span>,
which contains space, tab, newline, etc., and <span class="c004">punctuation</span> which contains the punctuation characters. Let&#X2019;s see
if we can make Python swear:</em></p><pre class="verbatim"><em>&gt;&gt;&gt; import string
&gt;&gt;&gt; string.punctuation
'!"#$%&amp;\'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~'
</em></pre><p><em>
Also, you might consider using the string methods <span class="c004">strip</span>,
<span class="c004">replace</span> and <span class="c004">translate</span>.
</em><a id="hevea_default1137"></a>
<a id="hevea_default1138"></a>
<a id="hevea_default1139"></a>
<a id="hevea_default1140"></a>
<a id="hevea_default1141"></a>
<a id="hevea_default1142"></a></p></div><div class="theorem"><span class="c010">Exercise&#XA0;2</span>&#X2003;
<a id="hevea_default1143"></a><p><em>Go to Project Gutenberg (</em><a href="http://gutenberg.org"><span class="c004"><em>http://gutenberg.org</em></span></a><em>) and download
your favorite out-of-copyright book in plain text format.
</em><a id="hevea_default1144"></a>
<a id="hevea_default1145"></a></p><p><em>Modify your program from the previous exercise to read the book
you downloaded, skip over the header information at the beginning
of the file, and process the rest of the words as before.</em></p><p><em>Then modify the program to count the total number of words in
the book, and the number of times each word is used.
</em><a id="hevea_default1146"></a>
<a id="hevea_default1147"></a></p><p><em>Print the number of different words used in the book. Compare
different books by different authors, written in different eras.
Which author uses the most extensive vocabulary?
</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;3</span>&#X2003;<p><em>Modify the program from the previous exercise to print the
20 most frequently used words in the book.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;4</span>&#X2003;<p><em>Modify the previous program to read a word list (see
Section&#XA0;</em><a href="#wordlist"><em>9.1</em></a><em>) and then print all the words in the book that
are not in the word list. How many of them are typos? How many of
them are common words that </em>should<em> be in the word list, and how
many of them are really obscure?</em></p></div>
<!--TOC section id="sec153" Random numbers-->
<h2 class="section" id="sec153">13.2&#X2003;Random numbers</h2><!--SEC END --><p>
<a id="hevea_default1148"></a>
<a id="hevea_default1149"></a>
<a id="hevea_default1150"></a>
<a id="hevea_default1151"></a></p><p>Given the same inputs, most computer programs generate the same
outputs every time, so they are said to be <span class="c010">deterministic</span>.
Determinism is usually a good thing, since we expect the same
calculation to yield the same result. For some applications, though,
we want the computer to be unpredictable. Games are an obvious
example, but there are more.</p><p>Making a program truly nondeterministic turns out to be difficult,
but there are ways to make it at least seem nondeterministic. One of
them is to use algorithms that generate <span class="c010">pseudorandom</span> numbers.
Pseudorandom numbers are not truly random because they are generated
by a deterministic computation, but just by looking at the numbers it
is all but impossible to distinguish them from random.
<a id="hevea_default1152"></a>
<a id="hevea_default1153"></a></p><p>The <span class="c004">random</span> module provides functions that generate
pseudorandom numbers (which I will simply call &#X201C;random&#X201D; from
here on).
<a id="hevea_default1154"></a>
<a id="hevea_default1155"></a></p><p>The function <span class="c004">random</span> returns a random float
between 0.0 and 1.0 (including 0.0 but not 1.0). Each time you
call <span class="c004">random</span>, you get the next number in a long series. To see a
sample, run this loop:</p><pre class="verbatim">import random

for i in range(10):
    x = random.random()
    print(x)
</pre><p>
The function <span class="c004">randint</span> takes parameters <span class="c004">low</span> and
<span class="c004">high</span> and returns an integer between <span class="c004">low</span> and
<span class="c004">high</span> (including both).
<a id="hevea_default1156"></a>
<a id="hevea_default1157"></a></p><pre class="verbatim">&gt;&gt;&gt; random.randint(5, 10)
5
&gt;&gt;&gt; random.randint(5, 10)
9
</pre><p>
To choose an element from a sequence at random, you can use
<span class="c004">choice</span>:
<a id="hevea_default1158"></a>
<a id="hevea_default1159"></a></p><pre class="verbatim">&gt;&gt;&gt; t = [1, 2, 3]
&gt;&gt;&gt; random.choice(t)
2
&gt;&gt;&gt; random.choice(t)
3
</pre><p>
The <span class="c004">random</span> module also provides functions to generate
random values from continuous distributions including
Gaussian, exponential, gamma, and a few more.</p><div class="theorem"><span class="c010">Exercise&#XA0;5</span>&#X2003;
<a id="hevea_default1160"></a><p><em>Write a function named </em><code class="verb"><em>choose_from_hist</em></code><em> that takes
a histogram as defined in Section&#XA0;</em><a href="#histogram"><em>11.2</em></a><em> and returns a
random value from the histogram, chosen with probability
in proportion to frequency. For example, for this histogram:</em></p><pre class="verbatim"><em>&gt;&gt;&gt; t = ['a', 'a', 'b']
&gt;&gt;&gt; hist = histogram(t)
&gt;&gt;&gt; hist
{'a': 2, 'b': 1}
</em></pre><p><em>
your function should return </em><code class="verb"><em>'a'</em></code><em> with probability </em>2/3<em> and </em><code class="verb"><em>'b'</em></code><em>
with probability </em>1/3<em>.
</em></p></div>
<!--TOC section id="sec154" Word histogram-->
<h2 class="section" id="sec154">13.3&#X2003;Word histogram</h2><!--SEC END --><p>You should attempt the previous exercises before you go on.
You can download my solution from
<a href="https://thinkpython.com/code/analyze_book1.py"><span class="c004">https://thinkpython.com/code/analyze_book1.py</span></a>. You will
also need <a href="https://thinkpython.com/code/emma.txt"><span class="c004">https://thinkpython.com/code/emma.txt</span></a>.</p><p>Here is a program that reads a file and builds a histogram of the
words in the file:
<a id="hevea_default1161"></a></p><pre class="verbatim">import string

def process_file(filename):
    hist = dict()
    fp = open(filename)
    for line in fp:
        process_line(line, hist)
    return hist

def process_line(line, hist):
    line = line.replace('-', ' ')

    for word in line.split():
        word = word.strip(string.punctuation + string.whitespace)
        word = word.lower()
        hist[word] = hist.get(word, 0) + 1

hist = process_file('emma.txt')
</pre><p>
This program reads <span class="c004">emma.txt</span>, which contains the text of <em>Emma</em> by Jane Austen.
<a id="hevea_default1162"></a></p><p><code class="verb">process_file</code> loops through the lines of the file,
passing them one at a time to <code class="verb">process_line</code>. The histogram
<span class="c004">hist</span> is being used as an accumulator.
<a id="hevea_default1163"></a>
<a id="hevea_default1164"></a></p><p><code class="verb">process_line</code> uses the string method <span class="c004">replace</span> to replace
hyphens with spaces before using <span class="c004">split</span> to break the line into a
list of strings. It traverses the list of words and uses <span class="c004">strip</span>
and <span class="c004">lower</span> to remove punctuation and convert to lower case. (It
is a shorthand to say that strings are &#X201C;converted&#X201D;; remember that
strings are immutable, so methods like <span class="c004">strip</span> and <span class="c004">lower</span>
return new strings.)</p><p>Finally, <code class="verb">process_line</code> updates the histogram by creating a new
item or incrementing an existing one.
<a id="hevea_default1165"></a></p><p>To count the total number of words in the file, we can add up
the frequencies in the histogram:</p><pre class="verbatim">def total_words(hist):
    return sum(hist.values())
</pre><p>
The number of different words is just the number of items in
the dictionary:</p><pre class="verbatim">def different_words(hist):
    return len(hist)
</pre><p>
Here is some code to print the results:</p><pre class="verbatim">print('Total number of words:', total_words(hist))
print('Number of different words:', different_words(hist))
</pre><p>
And the results:</p><pre class="verbatim">Total number of words: 161080
Number of different words: 7214
</pre>
<!--TOC section id="sec155" Most common words-->
<h2 class="section" id="sec155">13.4&#X2003;Most common words</h2><!--SEC END --><p>To find the most common words, we can make a list of tuples,
where each tuple contains a word and its frequency,
and sort it.</p><p>The following function takes a histogram and returns a list of
word-frequency tuples:</p><pre class="verbatim">def most_common(hist):
    t = []
    for key, value in hist.items():
        t.append((value, key))

    t.sort(reverse=True)
    return t
</pre><p>In each tuple, the frequency appears first, so the resulting list is
sorted by frequency. Here is a loop that prints the ten most common
words:</p><pre class="verbatim">t = most_common(hist)
print('The most common words are:')
for freq, word in t[:10]:
    print(word, freq, sep='\t')
</pre><p>
I use the keyword argument <span class="c004">sep</span> to tell <span class="c004">print</span> to use a tab
character as a &#X201C;separator&#X201D;, rather than a space, so the second
column is lined up. Here are the results from <em>Emma</em>:</p><pre class="verbatim">The most common words are:
to      5242
the     5205
and     4897
of      4295
i       3191
a       3130
it      2529
her     2483
was     2400
she     2364
</pre><p>
This code can be simplified using the <span class="c004">key</span> parameter of
the <span class="c004">sort</span> function. If you are curious, you can read about it
at <a href="https://wiki.python.org/moin/HowTo/Sorting"><span class="c004">https://wiki.python.org/moin/HowTo/Sorting</span></a>.</p>
<!--TOC section id="sec156" Optional parameters-->
<h2 class="section" id="sec156">13.5&#X2003;Optional parameters</h2><!--SEC END --><p>
<a id="hevea_default1166"></a>
<a id="hevea_default1167"></a></p><p>We have seen built-in functions and methods that take optional
arguments. It is possible to write programmer-defined functions
with optional arguments, too. For example, here is a function that
prints the most common words in a histogram
<a id="hevea_default1168"></a>
<a id="hevea_default1169"></a></p><pre class="verbatim">def print_most_common(hist, num=10):
    t = most_common(hist)
    print('The most common words are:')
    for freq, word in t[:num]:
        print(word, freq, sep='\t')
</pre><p>The first parameter is required; the second is optional.
The <span class="c010">default value</span> of <span class="c004">num</span> is 10.
<a id="hevea_default1170"></a>
<a id="hevea_default1171"></a></p><p>If you only provide one argument:</p><pre class="verbatim">print_most_common(hist)
</pre><p><span class="c004">num</span> gets the default value. If you provide two arguments:</p><pre class="verbatim">print_most_common(hist, 20)
</pre><p><span class="c004">num</span> gets the value of the argument instead. In other
words, the optional argument <span class="c010">overrides</span> the default value.
<a id="hevea_default1172"></a></p><p>If a function has both required and optional parameters, all
the required parameters have to come first, followed by the
optional ones.</p>
<!--TOC section id="sec157" Dictionary subtraction-->
<h2 class="section" id="sec157">13.6&#X2003;Dictionary subtraction</h2><!--SEC END --><p>
<a id="dictsub"></a>
<a id="hevea_default1173"></a>
<a id="hevea_default1174"></a></p><p>Finding the words from the book that are not in the word list
from <span class="c004">words.txt</span> is a problem you might recognize as set
subtraction; that is, we want to find all the words from one
set (the words in the book) that are not in the other (the
words in the list).</p><p><span class="c004">subtract</span> takes dictionaries <span class="c004">d1</span> and <span class="c004">d2</span> and returns a
new dictionary that contains all the keys from <span class="c004">d1</span> that are not
in <span class="c004">d2</span>. Since we don&#X2019;t really care about the values, we
set them all to None.</p><pre class="verbatim">def subtract(d1, d2):
    res = dict()
    for key in d1:
        if key not in d2:
            res[key] = None
    return res
</pre><p>
To find the words in the book that are not in <span class="c004">words.txt</span>,
we can use <code class="verb">process_file</code> to build a histogram for
<span class="c004">words.txt</span>, and then subtract:</p><pre class="verbatim">words = process_file('words.txt')
diff = subtract(hist, words)

print("Words in the book that aren't in the word list:")
for word in diff:
    print(word, end=' ')
</pre><p>
Here are some of the results from <em>Emma</em>:</p><pre class="verbatim">Words in the book that aren't in the word list:
rencontre jane's blanche woodhouses disingenuousness
friend's venice apartment ...
</pre><p>
Some of these words are names and possessives. Others, like
&#X201C;rencontre&#X201D;, are no longer in common use. But a few are common
words that should really be in the list!</p><div class="theorem"><span class="c010">Exercise&#XA0;6</span>&#X2003;
<a id="hevea_default1175"></a>
<a id="hevea_default1176"></a><p><em>Python provides a data structure called <span class="c004">set</span> that provides many
common set operations. You can read about them in Section&#XA0;</em><a href="#sets"><em>19.5</em></a><em>,
or read the documentation at
</em><a href="http://docs.python.org/3/library/stdtypes.html#types-set"><span class="c004"><em>http://docs.python.org/3/library/stdtypes.html#types-set</em></span></a><em>.</em></p><p><em>Write a program that uses set subtraction to find words in the book
that are not in the word list. Solution:
</em><a href="https://thinkpython.com/code/analyze_book2.py"><em><span class="c004">https://thinkpython.com/code/analyze_book2.py</span></em></a><em>.</em></p></div>
<!--TOC section id="sec158" Random words-->
<h2 class="section" id="sec158">13.7&#X2003;Random words</h2><!--SEC END --><p>
<a id="randomwords"></a>
<a id="hevea_default1177"></a></p><p>To choose a random word from the histogram, the simplest algorithm
is to build a list with multiple copies of each word, according
to the observed frequency, and then choose from the list:</p><pre class="verbatim">def random_word(h):
    t = []
    for word, freq in h.items():
        t.extend([word] * freq)

    return random.choice(t)
</pre><p>
The expression <span class="c004">[word] * freq</span> creates a list with <span class="c004">freq</span>
copies of the string <span class="c004">word</span>. The <span class="c004">extend</span>
method is similar to <span class="c004">append</span> except that the argument is
a sequence.</p><p>This algorithm works, but it is not very efficient; each time you
choose a random word, it rebuilds the list, which is as big as
the original book. An obvious improvement is to build the list
once and then make multiple selections, but the list is still big.</p><p>An alternative is:</p><ol class="enumerate" type=1><li class="li-enumerate">Use <span class="c004">keys</span> to get a list of the words in the book.</li><li class="li-enumerate">Build a list that contains the cumulative sum of the word
frequencies (see Exercise&#XA0;<a href="#cumulative">2</a>). The last item
in this list is the total number of words in the book, <span class="c009">n</span>.</li><li class="li-enumerate">Choose a random number from 1 to <span class="c009">n</span>. Use a bisection search
(See Exercise&#XA0;<a href="#bisection">10</a>) to find the index where the random
number would be inserted in the cumulative sum.</li><li class="li-enumerate">Use the index to find the corresponding word in the word list.</li></ol><div class="theorem"><span class="c010">Exercise&#XA0;7</span>&#X2003;
<a id="randhist"></a>
<a id="hevea_default1178"></a><p><em>Write a program that uses this algorithm to choose a random word from
the book. Solution:
</em><a href="https://thinkpython.com/code/analyze_book3.py"><em><span class="c004">https://thinkpython.com/code/analyze_book3.py</span></em></a><em>.</em></p></div>
<!--TOC section id="sec159" Markov analysis-->
<h2 class="section" id="sec159">13.8&#X2003;Markov analysis</h2><!--SEC END --><p>
<a id="markov"></a>
<a id="hevea_default1179"></a></p><p>If you choose words from the book at random, you can get a
sense of the vocabulary, but you probably won&#X2019;t get a sentence:</p><pre class="verbatim">this the small regard harriet which knightley's it most things
</pre><p>
A series of random words seldom makes sense because there
is no relationship between successive words. For example, in
a real sentence you would expect an article like &#X201C;the&#X201D; to
be followed by an adjective or a noun, and probably not a verb
or adverb.</p><p>One way to measure these kinds of relationships is Markov
analysis, which
characterizes, for a given sequence of words, the probability of the
words that might come next. For example, the song <em>Eric, the Half a
Bee</em> begins:</p><blockquote class="quote">
Half a bee, philosophically, <br>
Must, ipso facto, half not be. <br>
But half the bee has got to be <br>
Vis a vis, its entity. D&#X2019;you see? <br>
<br>
But can a bee be said to be <br>
Or not to be an entire bee <br>
When half the bee is not a bee <br>
Due to some ancient injury? <br>
</blockquote><p>
In this text,
the phrase &#X201C;half the&#X201D; is always followed by the word &#X201C;bee&#X201D;,
but the phrase &#X201C;the bee&#X201D; might be followed by either
&#X201C;has&#X201D; or &#X201C;is&#X201D;.
<a id="hevea_default1180"></a>
<a id="hevea_default1181"></a>
<a id="hevea_default1182"></a></p><p>The result of Markov analysis is a mapping from each prefix
(like &#X201C;half the&#X201D; and &#X201C;the bee&#X201D;) to all possible suffixes
(like &#X201C;has&#X201D; and &#X201C;is&#X201D;).
<a id="hevea_default1183"></a>
<a id="hevea_default1184"></a></p><p>Given this mapping, you can generate a random text by
starting with any prefix and choosing at random from the
possible suffixes. Next, you can combine the end of the
prefix and the new suffix to form the next prefix, and repeat.</p><p>For example, if you start with the prefix &#X201C;Half a&#X201D;, then the
next word has to be &#X201C;bee&#X201D;, because the prefix only appears
once in the text. The next prefix is &#X201C;a bee&#X201D;, so the
next suffix might be &#X201C;philosophically&#X201D;, &#X201C;be&#X201D; or &#X201C;due&#X201D;.</p><p>In this example the length of the prefix is always two, but
you can do Markov analysis with any prefix length.</p><div class="theorem"><span class="c010">Exercise&#XA0;8</span>&#X2003;<p><em>Markov analysis:</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Write a program to read a text from a file and perform Markov
analysis. The result should be a dictionary that maps from
prefixes to a collection of possible suffixes. The collection
might be a list, tuple, or dictionary; it is up to you to make
an appropriate choice. You can test your program with prefix
length two, but you should write the program in a way that makes
it easy to try other lengths.</em></li><li class="li-enumerate"><em>Add a function to the previous program to generate random text
based on the Markov analysis. Here is an example from </em>Emma<em>
with prefix length 2:</em><blockquote class="quote"><em>
He was very clever, be it sweetness or be angry, ashamed or only
amused, at such a stroke. She had never thought of Hannah till you
were never meant for me?" "I cannot make speeches, Emma:" he soon cut
it all himself.
</em></blockquote><p><em>For this example, I left the punctuation attached to the words.
The result is almost syntactically correct, but not quite.
Semantically, it almost makes sense, but not quite.</em></p><p><em>What happens if you increase the prefix length? Does the random
text make more sense?</em></p></li><li class="li-enumerate"><em>Once your program is working, you might want to try a mash-up:
if you combine text from two or more books, the random
text you generate will blend the vocabulary and phrases from
the sources in interesting ways.
</em><a id="hevea_default1185"></a></li></ol><p><em>Credit: This case study is based on an example from Kernighan and
Pike, </em>The Practice of Programming<em>, Addison-Wesley, 1999.</em></p></div><p>You should attempt this exercise before you go on; then you can
download my solution from <a href="https://thinkpython.com/code/markov.py"><span class="c004">https://thinkpython.com/code/markov.py</span></a>.
You will also need <a href="https://thinkpython.com/code/emma.txt"><span class="c004">https://thinkpython.com/code/emma.txt</span></a>.</p>
<!--TOC section id="sec160" Data structures-->
<h2 class="section" id="sec160">13.9&#X2003;Data structures</h2><!--SEC END --><p>
<a id="hevea_default1186"></a></p><p>Using Markov analysis to generate random text is fun, but there is
also a point to this exercise: data structure selection. In your
solution to the previous exercises, you had to choose:</p><ul class="itemize"><li class="li-itemize">How to represent the prefixes.</li><li class="li-itemize">How to represent the collection of possible suffixes.</li><li class="li-itemize">How to represent the mapping from each prefix to
the collection of possible suffixes.</li></ul><p>The last one is easy: a dictionary is the obvious choice
for a mapping from keys to corresponding values.</p><p>For the prefixes, the most obvious options are string,
list of strings, or tuple of strings.</p><p>For the suffixes,
one option is a list; another is a histogram (dictionary).
<a id="hevea_default1187"></a></p><p>How should you choose? The first step is to think about
the operations you will need to implement for each data structure.
For the prefixes, we need to be able to remove words from
the beginning and add to the end. For example, if the current
prefix is &#X201C;Half a&#X201D;, and the next word is &#X201C;bee&#X201D;, you need
to be able to form the next prefix, &#X201C;a bee&#X201D;.
<a id="hevea_default1188"></a></p><p>Your first choice might be a list, since it is easy to add
and remove elements, but we also need to be able to use the
prefixes as keys in a dictionary, so that rules out lists.
With tuples, you can&#X2019;t append or remove, but you can use
the addition operator to form a new tuple:</p><pre class="verbatim">def shift(prefix, word):
    return prefix[1:] + (word,)
</pre><p>
<span class="c004">shift</span> takes a tuple of words, <span class="c004">prefix</span>, and a string,
<span class="c004">word</span>, and forms a new tuple that has all the words
in <span class="c004">prefix</span> except the first, and <span class="c004">word</span> added to
the end.</p><p>For the collection of suffixes, the operations we need to
perform include adding a new suffix (or increasing the frequency
of an existing one), and choosing a random suffix.</p><p>Adding a new suffix is equally easy for the list implementation
or the histogram. Choosing a random element from a list
is easy; choosing from a histogram is harder to do
efficiently (see Exercise&#XA0;<a href="#randhist">7</a>).</p><p>So far we have been talking mostly about ease of implementation,
but there are other factors to consider in choosing data structures.
One is run time. Sometimes there is a theoretical reason to expect
one data structure to be faster than other; for example, I mentioned
that the <span class="c004">in</span> operator is faster for dictionaries than for lists,
at least when the number of elements is large.</p><p>But often you don&#X2019;t know ahead of time which implementation will
be faster. One option is to implement both of them and see which
is better. This approach is called <span class="c010">benchmarking</span>. A practical
alternative is to choose the data structure that is
easiest to implement, and then see if it is fast enough for the
intended application. If so, there is no need to go on. If not,
there are tools, like the <span class="c004">profile</span> module, that can identify
the places in a program that take the most time.
<a id="hevea_default1189"></a>
<a id="hevea_default1190"></a>
<a id="hevea_default1191"></a></p><p>The other factor to consider is storage space. For example, using a
histogram for the collection of suffixes might take less space because
you only have to store each word once, no matter how many times it
appears in the text. In some cases, saving space can also make your
program run faster, and in the extreme, your program might not run at
all if you run out of memory. But for many applications, space is a
secondary consideration after run time.</p><p>One final thought: in this discussion, I have implied that
we should use one data structure for both analysis and generation. But
since these are separate phases, it would also be possible to use one
structure for analysis and then convert to another structure for
generation. This would be a net win if the time saved during
generation exceeded the time spent in conversion.</p>
<!--TOC section id="sec161" Debugging-->
<h2 class="section" id="sec161">13.10&#X2003;Debugging</h2><!--SEC END --><p>
<a id="hevea_default1192"></a></p><p>When you are debugging a program, and especially if you are
working on a hard bug, there are five things to try:</p><dl class="description"><dt class="dt-description"><span class="c010">Reading:</span></dt><dd class="dd-description"> Examine your code, read it back to yourself, and
check that it says what you meant to say.</dd><dt class="dt-description"><span class="c010">Running:</span></dt><dd class="dd-description"> Experiment by making changes and running different
versions. Often if you display the right thing at the right place
in the program, the problem becomes obvious, but sometimes you have to
build scaffolding.</dd><dt class="dt-description"><span class="c010">Ruminating:</span></dt><dd class="dd-description"> Take some time to think! What kind of error
is it: syntax, runtime, or semantic? What information can you get from
the error messages, or from the output of the program? What kind of
error could cause the problem you&#X2019;re seeing? What did you change
last, before the problem appeared?</dd><dt class="dt-description"><span class="c010">Rubberducking:</span></dt><dd class="dd-description"> If you explain the problem to someone else, you
sometimes find the answer before you finish asking the question.
Often you don&#X2019;t need the other person; you could just talk to a rubber
duck. And that&#X2019;s the origin of the well-known strategy called <span class="c010">rubber duck debugging</span>. I am not making this up; see
<a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging"><span class="c004">https://en.wikipedia.org/wiki/Rubber_duck_debugging</span></a>.</dd><dt class="dt-description"><span class="c010">Retreating:</span></dt><dd class="dd-description"> At some point, the best thing to do is back
off, undoing recent changes, until you get back to a program that
works and that you understand. Then you can start rebuilding.</dd></dl><p>Beginning programmers sometimes get stuck on one of these activities
and forget the others. Each activity comes with its own failure
mode.
<a id="hevea_default1193"></a></p><p>For example, reading your code might help if the problem is a
typographical error, but not if the problem is a conceptual
misunderstanding. If you don&#X2019;t understand what your program does, you
can read it 100 times and never see the error, because the error is in
your head.
<a id="hevea_default1194"></a></p><p>Running experiments can help, especially if you run small, simple
tests. But if you run experiments without thinking or reading your
code, you might fall into a pattern I call &#X201C;random walk programming&#X201D;,
which is the process of making random changes until the program
does the right thing. Needless to say, random walk programming
can take a long time.
<a id="hevea_default1195"></a>
<a id="hevea_default1196"></a></p><p>You have to take time to think. Debugging is like an
experimental science. You should have at least one hypothesis about
what the problem is. If there are two or more possibilities, try to
think of a test that would eliminate one of them.</p><p>But even the best debugging techniques will fail if there are too many
errors, or if the code you are trying to fix is too big and
complicated. Sometimes the best option is to retreat, simplifying the
program until you get to something that works and that you
understand.</p><p>Beginning programmers are often reluctant to retreat because
they can&#X2019;t stand to delete a line of code (even if it&#X2019;s wrong).
If it makes you feel better, copy your program into another file
before you start stripping it down. Then you can copy the pieces
back one at a time.</p><p>Finding a hard bug requires reading, running, ruminating, and
sometimes retreating. If you get stuck on one of these activities,
try the others.</p>
<!--TOC section id="sec162" Glossary-->
<h2 class="section" id="sec162">13.11&#X2003;Glossary</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c010">deterministic:</span></dt><dd class="dd-description"> Pertaining to a program that does the same
thing each time it runs, given the same inputs.
<a id="hevea_default1197"></a></dd><dt class="dt-description"><span class="c010">pseudorandom:</span></dt><dd class="dd-description"> Pertaining to a sequence of numbers that appears
to be random, but is generated by a deterministic program.
<a id="hevea_default1198"></a></dd><dt class="dt-description"><span class="c010">default value:</span></dt><dd class="dd-description"> The value given to an optional parameter if no
argument is provided.
<a id="hevea_default1199"></a></dd><dt class="dt-description"><span class="c010">override:</span></dt><dd class="dd-description"> To replace a default value with an argument.
<a id="hevea_default1200"></a></dd><dt class="dt-description"><span class="c010">benchmarking:</span></dt><dd class="dd-description"> The process of choosing between data structures
by implementing alternatives and testing them on a sample of the
possible inputs.
<a id="hevea_default1201"></a></dd><dt class="dt-description"><span class="c010">rubber duck debugging:</span></dt><dd class="dd-description"> Debugging by explaining your problem
to an inanimate object such as a rubber duck. Articulating the
problem can help you solve it, even if the rubber duck doesn&#X2019;t know
Python.
<a id="hevea_default1202"></a>
<a id="hevea_default1203"></a></dd></dl>
<!--TOC section id="sec163" Exercises-->
<h2 class="section" id="sec163">13.12&#X2003;Exercises</h2><!--SEC END --><div class="theorem"><span class="c010">Exercise&#XA0;9</span>&#X2003;
<a id="hevea_default1204"></a>
<a id="hevea_default1205"></a>
<a id="hevea_default1206"></a><p><em>The &#X201C;rank&#X201D; of a word is its position in a list of words
sorted by frequency: the most common word has rank 1, the
second most common has rank 2, etc.</em></p><p><em>Zipf&#X2019;s law describes a relationship between the ranks and frequencies
of words in natural languages
(</em><a href="http://en.wikipedia.org/wiki/Zipf's_law"><em><span class="c004">http://en.wikipedia.org/wiki/Zipf's_law</span></em></a><em>). Specifically, it
predicts that the frequency, </em><span class="c009">f</span><em>, of the word with rank </em><span class="c009">r</span><em> is:</em></p><table class="display dcenter"><tr class="c017"><td class="dcell"><span class="c009">f</span>&#X2004;=&#X2004;<span class="c009">c</span>&#X2004;<span class="c009">r</span><sup>&#X2212;<span class="c009">s</span></sup>&#X2004;</td></tr>
</table><p><em>
where </em><span class="c009">s</span><em> and </em><span class="c009">c</span><em> are parameters that depend on the language and the
text. If you take the logarithm of both sides of this equation, you
get:
</em><a id="hevea_default1207"></a></p><table class="display dcenter"><tr class="c017"><td class="dcell">log<span class="c009">f</span>&#X2004;=&#X2004;log<span class="c009">c</span>&#X2004;&#X2212;&#X2004;<span class="c009">s</span>&#X2004;log<span class="c009">r</span>&#X2004;</td></tr>
</table><p><em>
So if you plot log </em><span class="c009">f</span><em> versus log </em><span class="c009">r</span><em>, you should get
a straight line with slope </em>&#X2212;<span class="c009">s</span><em> and intercept log </em><span class="c009">c</span><em>.</em></p><p><em>Write a program that reads a text from a file, counts
word frequencies, and prints one line
for each word, in descending order of frequency, with
log </em><span class="c009">f</span><em> and log </em><span class="c009">r</span><em>. Use the graphing program of your
choice to plot the results and check whether they form
a straight line. Can you estimate the value of </em><span class="c009">s</span><em>?</em></p><p><em>Solution: </em><a href="https://thinkpython.com/code/zipf.py"><span class="c004"><em>https://thinkpython.com/code/zipf.py</em></span></a><em>.
To run my solution, you need the plotting module <span class="c004">matplotlib</span>.
If you installed Anaconda, you already have <span class="c004">matplotlib</span>;
otherwise you might have to install it.
</em><a id="hevea_default1208"></a></p></div>
<!--TOC chapter id="sec164" Files-->
<h1 class="chapter" id="sec164">Chapter&#XA0;14&#X2003;Files</h1><!--SEC END --><p>This chapter introduces the idea of &#X201C;persistent&#X201D; programs that
keep data in permanent storage, and shows how to use different
kinds of permanent storage, like files and databases.</p>
<!--TOC section id="sec165" Persistence-->
<h2 class="section" id="sec165">14.1&#X2003;Persistence</h2><!--SEC END --><p>
<a id="hevea_default1209"></a>
<a id="hevea_default1210"></a>
<a id="hevea_default1211"></a></p><p>Most of the programs we have seen so far are transient in the
sense that they run for a short time and produce some output,
but when they end, their data disappears. If you run the program
again, it starts with a clean slate.</p><p>Other programs are <span class="c010">persistent</span>: they run for a long time
(or all the time); they keep at least some of their data
in permanent storage (a hard drive, for example); and
if they shut down and restart, they pick up where they left off.</p><p>Examples of persistent programs are operating systems, which
run pretty much whenever a computer is on, and web servers,
which run all the time, waiting for requests to come in on
the network.</p><p>One of the simplest ways for programs to maintain their data
is by reading and writing text files. We have already seen
programs that read text files; in this chapter we will see programs
that write them.</p><p>An alternative is to store the state of the program in a database.
In this chapter I will present a simple database and a module,
<span class="c004">pickle</span>, that makes it easy to store program data.
<a id="hevea_default1212"></a>
<a id="hevea_default1213"></a></p>
<!--TOC section id="sec166" Reading and writing-->
<h2 class="section" id="sec166">14.2&#X2003;Reading and writing</h2><!--SEC END --><p>
<a id="hevea_default1214"></a></p><p>A text file is a sequence of characters stored on a permanent
medium like a hard drive, flash memory, or CD-ROM. We saw how
to open and read a file in Section&#XA0;<a href="#wordlist">9.1</a>.
<a id="hevea_default1215"></a>
<a id="hevea_default1216"></a></p><p>To write a file, you have to open it with mode <code class="verb">'w'</code> as a second
parameter:</p><pre class="verbatim">&gt;&gt;&gt; fout = open('output.txt', 'w')
</pre><p>
If the file already exists, opening it in write mode clears out
the old data and starts fresh, so be careful!
If the file doesn&#X2019;t exist, a new one is created.</p><p><span class="c004">open</span> returns a file object that provides methods for working
with the file.
The <span class="c004">write</span> method puts data into the file.</p><pre class="verbatim">&gt;&gt;&gt; line1 = "This here's the wattle,\n"
&gt;&gt;&gt; fout.write(line1)
24
</pre><p>
The return value is the number of characters that were written.
The file object keeps track of where it is, so if
you call <span class="c004">write</span> again, it adds the new data to the end of
the file.</p><pre class="verbatim">&gt;&gt;&gt; line2 = "the emblem of our land.\n"
&gt;&gt;&gt; fout.write(line2)
24
</pre><p>
When you are done writing, you should close the file.</p><pre class="verbatim">&gt;&gt;&gt; fout.close()
</pre><p>
<a id="hevea_default1217"></a>
<a id="hevea_default1218"></a>
If you don&#X2019;t close the file, it gets closed for you when the
program ends.</p>
<!--TOC section id="sec167" Format operator-->
<h2 class="section" id="sec167">14.3&#X2003;Format operator</h2><!--SEC END --><p>
<a id="hevea_default1219"></a>
<a id="hevea_default1220"></a></p><p>The argument of <span class="c004">write</span> has to be a string, so if we want
to put other values in a file, we have to convert them to
strings. The easiest way to do that is with <span class="c004">str</span>:</p><pre class="verbatim">&gt;&gt;&gt; x = 52
&gt;&gt;&gt; fout.write(str(x))
</pre><p>
An alternative is to use the <span class="c010">format operator</span>, <span class="c004">%</span>. When
applied to integers, <span class="c004">%</span> is the modulus operator. But
when the first operand is a string, <span class="c004">%</span> is the format operator.
<a id="hevea_default1221"></a></p><p>The first operand is the <span class="c010">format string</span>, which contains
one or more <span class="c010">format sequences</span>, which
specify how
the second operand is formatted. The result is a string.
<a id="hevea_default1222"></a></p><p>For example, the format sequence <code class="verb">'%d'</code> means that
the second operand should be formatted as a decimal
integer:</p><pre class="verbatim">&gt;&gt;&gt; camels = 42
&gt;&gt;&gt; '%d' % camels
'42'
</pre><p>
The result is the string <code class="verb">'42'</code>, which is not to be confused
with the integer value <span class="c004">42</span>.</p><p>A format sequence can appear anywhere in the string,
so you can embed a value in a sentence:</p><pre class="verbatim">&gt;&gt;&gt; 'I have spotted %d camels.' % camels
'I have spotted 42 camels.'
</pre><p>
If there is more than one format sequence in the string,
the second argument has to be a tuple. Each format sequence is
matched with an element of the tuple, in order.</p><p>The following example uses <code class="verb">'%d'</code> to format an integer,
<code class="verb">'%g'</code> to format a floating-point number, and
<code class="verb">'%s'</code> to format a string:</p><pre class="verbatim">&gt;&gt;&gt; 'In %d years I have spotted %g %s.' % (3, 0.1, 'camels')
'In 3 years I have spotted 0.1 camels.'
</pre><p>
The number of elements in the tuple has to match the number
of format sequences in the string. Also, the types of the
elements have to match the format sequences:
<a id="hevea_default1223"></a>
<a id="hevea_default1224"></a></p><pre class="verbatim">&gt;&gt;&gt; '%d %d %d' % (1, 2)
TypeError: not enough arguments for format string
&gt;&gt;&gt; '%d' % 'dollars'
TypeError: %d format: a number is required, not str
</pre><p>
In the first example, there aren&#X2019;t enough elements; in the
second, the element is the wrong type.</p><p>For more information on the format operator, see
<a href="https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting"><span class="c004">https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting</span></a>. A more powerful alternative is the string
format method, which you can read about at
<a href="https://docs.python.org/3/library/stdtypes.html#str.format"><span class="c004">https://docs.python.org/3/library/stdtypes.html#str.format</span></a>.</p>
<!--TOC section id="sec168" Filenames and paths-->
<h2 class="section" id="sec168">14.4&#X2003;Filenames and paths</h2><!--SEC END --><p>
<a id="paths"></a>
<a id="hevea_default1225"></a>
<a id="hevea_default1226"></a>
<a id="hevea_default1227"></a>
<a id="hevea_default1228"></a></p><p>Files are organized into <span class="c010">directories</span> (also called &#X201C;folders&#X201D;).
Every running program has a &#X201C;current directory&#X201D;, which is the
default directory for most operations.
For example, when you open a file for reading, Python looks for it in the
current directory.
<a id="hevea_default1229"></a>
<a id="hevea_default1230"></a></p><p>The <span class="c004">os</span> module provides functions for working with files and
directories (&#X201C;os&#X201D; stands for &#X201C;operating system&#X201D;). <span class="c004">os.getcwd</span>
returns the name of the current directory:
<a id="hevea_default1231"></a>
<a id="hevea_default1232"></a></p><pre class="verbatim">&gt;&gt;&gt; import os
&gt;&gt;&gt; cwd = os.getcwd()
&gt;&gt;&gt; cwd
'/home/dinsdale'
</pre><p>
<span class="c004">cwd</span> stands for &#X201C;current working directory&#X201D;. The result in
this example is <span class="c004">/home/dinsdale</span>, which is the home directory of a
user named <span class="c004">dinsdale</span>.
<a id="hevea_default1233"></a>
<a id="hevea_default1234"></a></p><p>A string like <code class="verb">'/home/dinsdale'</code> that identifies a file or
directory is called a <span class="c010">path</span>.</p><p>A simple filename, like <span class="c004">memo.txt</span> is also considered a path,
but it is a <span class="c010">relative path</span> because it relates to the current
directory. If the current directory is <span class="c004">/home/dinsdale</span>, the
filename <span class="c004">memo.txt</span> would refer to <span class="c004">/home/dinsdale/memo.txt</span>.
<a id="hevea_default1235"></a> <a id="hevea_default1236"></a>
<a id="hevea_default1237"></a> <a id="hevea_default1238"></a></p><p>A path that begins with <span class="c004">/</span> does not depend on the current
directory; it is called an <span class="c010">absolute path</span>. To find the absolute
path to a file, you can use <span class="c004">os.path.abspath</span>:</p><pre class="verbatim">&gt;&gt;&gt; os.path.abspath('memo.txt')
'/home/dinsdale/memo.txt'
</pre><p>
<span class="c004">os.path</span> provides other functions for working with filenames
and paths. For example,
<span class="c004">os.path.exists</span> checks
whether a file or directory exists:
<a id="hevea_default1239"></a>
<a id="hevea_default1240"></a></p><pre class="verbatim">&gt;&gt;&gt; os.path.exists('memo.txt')
True
</pre><p>
If it exists, <span class="c004">os.path.isdir</span> checks whether it&#X2019;s a directory:</p><pre class="verbatim">&gt;&gt;&gt; os.path.isdir('memo.txt')
False
&gt;&gt;&gt; os.path.isdir('/home/dinsdale')
True
</pre><p>
Similarly, <span class="c004">os.path.isfile</span> checks whether it&#X2019;s a file.</p><p><span class="c004">os.listdir</span> returns a list of the files (and other directories)
in the given directory:</p><pre class="verbatim">&gt;&gt;&gt; os.listdir(cwd)
['music', 'photos', 'memo.txt']
</pre><p>
To demonstrate these functions, the following example
&#X201C;walks&#X201D; through a directory, prints
the names of all the files, and calls itself recursively on
all the directories.
<a id="hevea_default1241"></a>
<a id="hevea_default1242"></a></p><pre class="verbatim">def walk(dirname):
    for name in os.listdir(dirname):
        path = os.path.join(dirname, name)

        if os.path.isfile(path):
            print(path)
        else:
            walk(path)
</pre><p>
<span class="c004">os.path.join</span> takes a directory and a file name and joins
them into a complete path.</p><p>The <span class="c004">os</span> module provides a function called <span class="c004">walk</span> that is
similar to this one but more versatile. As an exercise, read the
documentation and use it to print the names of the files in a given
directory and its subdirectories. You can download my solution from
<a href="https://thinkpython.com/code/walk.py"><span class="c004">https://thinkpython.com/code/walk.py</span></a>.</p>
<!--TOC section id="sec169" Catching exceptions-->
<h2 class="section" id="sec169">14.5&#X2003;Catching exceptions</h2><!--SEC END --><p>
<a id="catch"></a></p><p>A lot of things can go wrong when you try to read and write
files. If you try to open a file that doesn&#X2019;t exist, you get an
<span class="c004">FileNotFoundError</span>:
<a id="hevea_default1243"></a>
<a id="hevea_default1244"></a>
<a id="hevea_default1245"></a>
<a id="hevea_default1246"></a></p><pre class="verbatim">&gt;&gt;&gt; fin = open('bad_file')
FileNotFoundError: [Errno 2] No such file or directory: 'bad_file'

</pre><p>
If you don&#X2019;t have permission to access a file:
<a id="hevea_default1247"></a>
<a id="hevea_default1248"></a></p><pre class="verbatim">&gt;&gt;&gt; fout = open('/etc/passwd', 'w')
PermissionError: [Errno 13] Permission denied: '/etc/passwd'
</pre><p>
And if you try to open a directory for reading, you get</p><pre class="verbatim">&gt;&gt;&gt; fin = open('/home')
IsADirectoryError: [Errno 21] Is a directory: '/home'
</pre><p>
To avoid these errors, you could use functions like <span class="c004">os.path.exists</span>
and <span class="c004">os.path.isfile</span>, but it would take a lot of time and code
to check all the possibilities (if &#X201C;<span class="c004">Errno 21</span>&#X201D; is any
indication, there are at least 21 things that can go wrong).
<a id="hevea_default1249"></a>
<a id="hevea_default1250"></a>
<a id="hevea_default1251"></a></p><p>It is better to go ahead and try&#X2014;and deal with problems if they
happen&#X2014;which is exactly what the <span class="c004">try</span> statement does. The
syntax is similar to an <span class="c004">if...else</span> statement:</p><pre class="verbatim">try:
    fin = open('bad_file')
except:
    print('Something went wrong.')
</pre><p>
Python starts by executing the <span class="c004">try</span> clause. If all goes
well, it skips the <span class="c004">except</span> clause and proceeds. If an
exception occurs, it jumps out of the <span class="c004">try</span> clause and
runs the <span class="c004">except</span> clause.</p><p>Handling an exception with a <span class="c004">try</span> statement is called <span class="c010">catching</span> an exception. In this example, the <span class="c004">except</span> clause
prints an error message that is not very helpful. In general,
catching an exception gives you a chance to fix the problem, or try
again, or at least end the program gracefully.</p>
<!--TOC section id="sec170" Databases-->
<h2 class="section" id="sec170">14.6&#X2003;Databases</h2><!--SEC END --><p>
<a id="hevea_default1252"></a></p><p>A <span class="c010">database</span> is a file that is organized for storing data. Many
databases are organized like a dictionary in the sense that they map
from keys to values. The biggest difference between a database and a
dictionary is that the database is on disk (or other permanent
storage), so it persists after the program ends. <a id="hevea_default1253"></a> <a id="hevea_default1254"></a></p><p>The module <span class="c004">dbm</span> provides an interface for creating
and updating database files.
As an example, I&#X2019;ll create a database
that contains captions for image files.
<a id="hevea_default1255"></a>
<a id="hevea_default1256"></a></p><p>Opening a database is similar to opening other files:</p><pre class="verbatim">&gt;&gt;&gt; import dbm
&gt;&gt;&gt; db = dbm.open('captions', 'c')
</pre><p>
The mode <code class="verb">'c'</code> means that the database should be created if
it doesn&#X2019;t already exist. The result is a database object
that can be used (for most operations) like a dictionary.
<a id="hevea_default1257"></a>
<a id="hevea_default1258"></a></p><p>When you create a new item, <span class="c004">dbm</span> updates the database file.
<a id="hevea_default1259"></a></p><pre class="verbatim">&gt;&gt;&gt; db['cleese.png'] = 'Photo of John Cleese.'
</pre><p>
When you access one of the items, <span class="c004">dbm</span> reads the file:</p><pre class="verbatim">&gt;&gt;&gt; db['cleese.png']
b'Photo of John Cleese.'
</pre><p>
The result is a <span class="c010">bytes object</span>, which is why it begins with <span class="c004">b</span>. A bytes object is similar to a string in many ways. When you
get farther into Python, the difference becomes important, but for now
we can ignore it.
<a id="hevea_default1260"></a>
<a id="hevea_default1261"></a></p><p>If you make another assignment to an existing key, <span class="c004">dbm</span> replaces
the old value:</p><pre class="verbatim">&gt;&gt;&gt; db['cleese.png'] = 'Photo of John Cleese doing a silly walk.'
&gt;&gt;&gt; db['cleese.png']
b'Photo of John Cleese doing a silly walk.'
</pre><p>Some dictionary methods, like <span class="c004">keys</span> and <span class="c004">items</span>, don&#X2019;t
work with database objects. But iteration with a <span class="c004">for</span>
loop works:
<a id="hevea_default1262"></a></p><pre class="verbatim">for key in db.keys():
    print(key, db[key])
</pre><p>
As with other files, you should close the database when you are
done:</p><pre class="verbatim">&gt;&gt;&gt; db.close()
</pre><p>
<a id="hevea_default1263"></a>
<a id="hevea_default1264"></a></p>
<!--TOC section id="sec171" Pickling-->
<h2 class="section" id="sec171">14.7&#X2003;Pickling</h2><!--SEC END --><p>
<a id="hevea_default1265"></a></p><p>A limitation of <span class="c004">dbm</span> is that the keys and values have to be
strings or bytes. If you try to use any other type, you get an error.
<a id="hevea_default1266"></a> <a id="hevea_default1267"></a></p><p>The <span class="c004">pickle</span> module can help. It translates
almost any type of object into a string suitable for storage in a
database, and then translates strings back into objects.</p><p><span class="c004">pickle.dumps</span> takes an object as a parameter and returns
a string representation (<span class="c004">dumps</span> is short for &#X201C;dump string&#X201D;):</p><pre class="verbatim">&gt;&gt;&gt; import pickle
&gt;&gt;&gt; t = [1, 2, 3]
&gt;&gt;&gt; pickle.dumps(t)
b'\x80\x03]q\x00(K\x01K\x02K\x03e.'
</pre><p>
The format isn&#X2019;t obvious to human readers; it is meant to be
easy for <span class="c004">pickle</span> to interpret. <span class="c004">pickle.loads</span>
(&#X201C;load string&#X201D;) reconstitutes the object:</p><pre class="verbatim">&gt;&gt;&gt; t1 = [1, 2, 3]
&gt;&gt;&gt; s = pickle.dumps(t1)
&gt;&gt;&gt; t2 = pickle.loads(s)
&gt;&gt;&gt; t2
[1, 2, 3]
</pre><p>
Although the new object has the same value as the old, it is
not (in general) the same object:</p><pre class="verbatim">&gt;&gt;&gt; t1 == t2
True
&gt;&gt;&gt; t1 is t2
False
</pre><p>
In other words, pickling and then unpickling has the same effect
as copying the object.</p><p>You can use <span class="c004">pickle</span> to store non-strings in a database.
In fact, this combination is so common that it has been
encapsulated in a module called <span class="c004">shelve</span>.
<a id="hevea_default1268"></a>
<a id="hevea_default1269"></a></p>
<!--TOC section id="sec172" Pipes-->
<h2 class="section" id="sec172">14.8&#X2003;Pipes</h2><!--SEC END --><p>
<a id="hevea_default1270"></a>
<a id="hevea_default1271"></a></p><p>Most operating systems provide a command-line interface,
also known as a <span class="c010">shell</span>. Shells usually provide commands
to navigate the file system and launch applications. For
example, in Unix you can change directories with <span class="c004">cd</span>,
display the contents of a directory with <span class="c004">ls</span>, and launch
a web browser by typing (for example) <span class="c004">firefox</span>.
<a id="hevea_default1272"></a>
<a id="hevea_default1273"></a></p><p>Any program that you can launch from the shell can also be
launched from Python using a <span class="c010">pipe object</span>, which
represents a running program.</p><p>For example, the Unix command <span class="c004">ls -l</span> normally displays the
contents of the current directory in long format. You can
launch <span class="c004">ls</span> with <span class="c004">os.popen</span><sup><a id="text1" href="#note1">1</a></sup>:
<a id="hevea_default1274"></a>
<a id="hevea_default1275"></a></p><pre class="verbatim">&gt;&gt;&gt; cmd = 'ls -l'
&gt;&gt;&gt; fp = os.popen(cmd)
</pre><p>
The argument is a string that contains a shell command. The
return value is an object that behaves like an open
file. You can read the output from the <span class="c004">ls</span> process one
line at a time with <span class="c004">readline</span> or get the whole thing at
once with <span class="c004">read</span>:
<a id="hevea_default1276"></a>
<a id="hevea_default1277"></a>
<a id="hevea_default1278"></a>
<a id="hevea_default1279"></a></p><pre class="verbatim">&gt;&gt;&gt; res = fp.read()
</pre><p>
When you are done, you close the pipe like a file:
<a id="hevea_default1280"></a>
<a id="hevea_default1281"></a></p><pre class="verbatim">&gt;&gt;&gt; stat = fp.close()
&gt;&gt;&gt; print(stat)
None
</pre><p>
The return value is the final status of the <span class="c004">ls</span> process;
<span class="c004">None</span> means that it ended normally (with no errors).</p><p>For example, most Unix systems provide a command called <span class="c004">md5sum</span>
that reads the contents of a file and computes a &#X201C;checksum&#X201D;.
You can read about MD5 at <a href="http://en.wikipedia.org/wiki/Md5"><span class="c004">http://en.wikipedia.org/wiki/Md5</span></a>. This
command provides an efficient way to check whether two files
have the same contents. The probability that different contents
yield the same checksum is very small (that is, unlikely to happen
before the universe collapses).
<a id="hevea_default1282"></a>
<a id="hevea_default1283"></a></p><p>You can use a pipe to run <span class="c004">md5sum</span> from Python and get the result:</p><pre class="verbatim">&gt;&gt;&gt; filename = 'book.tex'
&gt;&gt;&gt; cmd = 'md5sum ' + filename
&gt;&gt;&gt; fp = os.popen(cmd)
&gt;&gt;&gt; res = fp.read()
&gt;&gt;&gt; stat = fp.close()
&gt;&gt;&gt; print(res)
1e0033f0ed0656636de0d75144ba32e0  book.tex
&gt;&gt;&gt; print(stat)
None
</pre>
<!--TOC section id="sec173" Writing modules-->
<h2 class="section" id="sec173">14.9&#X2003;Writing modules</h2><!--SEC END --><p>
<a id="modules"></a>
<a id="hevea_default1284"></a>
<a id="hevea_default1285"></a></p><p>Any file that contains Python code can be imported as a module.
For example, suppose you have a file named <span class="c004">wc.py</span> with the following
code:</p><pre class="verbatim">def linecount(filename):
    count = 0
    for line in open(filename):
        count += 1
    return count

print(linecount('wc.py'))
</pre><p>
If you run this program, it reads itself and prints the number
of lines in the file, which is 7.
You can also import it like this:</p><pre class="verbatim">&gt;&gt;&gt; import wc
7
</pre><p>
Now you have a module object <span class="c004">wc</span>:
<a id="hevea_default1286"></a>
<a id="hevea_default1287"></a></p><pre class="verbatim">&gt;&gt;&gt; wc
&lt;module 'wc' from 'wc.py'&gt;
</pre><p>
The module object provides <code class="verb">linecount</code>:</p><pre class="verbatim">&gt;&gt;&gt; wc.linecount('wc.py')
7
</pre><p>
So that&#X2019;s how you write modules in Python.</p><p>The only problem with this example is that when you import
the module it runs the test code at the bottom. Normally
when you import a module, it defines new functions but it
doesn&#X2019;t run them.
<a id="hevea_default1288"></a>
<a id="hevea_default1289"></a></p><p>Programs that will be imported as modules often
use the following idiom:</p><pre class="verbatim">if __name__ == '__main__':
    print(linecount('wc.py'))
</pre><p>
<code class="verb">__name__</code> is a built-in variable that is set when the
program starts. If the program is running as a script,
<code class="verb">__name__</code> has the value <code class="verb">'__main__'</code>; in that
case, the test code runs. Otherwise,
if the module is being imported, the test code is skipped.</p><p><a id="hevea_default1290"></a>
<a id="hevea_default1291"></a></p><p>As an exercise, type this example into a file named <span class="c004">wc.py</span> and run
it as a script. Then run the Python interpreter and
<span class="c004">import wc</span>. What is the value of <code class="verb">__name__</code>
when the module is being imported?</p><p>Warning: If you import a module that has already been imported,
Python does nothing. It does not re-read the file, even if it has
changed.
<a id="hevea_default1292"></a>
<a id="hevea_default1293"></a>
<a id="hevea_default1294"></a></p><p>If you want to reload a module, you can use the built-in function
<span class="c004">reload</span>, but it can be tricky, so the safest thing to do is
restart the interpreter and then import the module again.</p>
<!--TOC section id="sec174" Debugging-->
<h2 class="section" id="sec174">14.10&#X2003;Debugging</h2><!--SEC END --><p>
<a id="hevea_default1295"></a>
<a id="hevea_default1296"></a></p><p>When you are reading and writing files, you might run into problems
with whitespace. These errors can be hard to debug because spaces,
tabs and newlines are normally invisible:</p><pre class="verbatim">&gt;&gt;&gt; s = '1 2\t 3\n 4'
&gt;&gt;&gt; print(s)
1 2  3
 4
</pre><p>
<a id="hevea_default1297"></a>
<a id="hevea_default1298"></a>
<a id="hevea_default1299"></a></p><p>The built-in function <span class="c004">repr</span> can help. It takes any object as an
argument and returns a string representation of the object. For
strings, it represents whitespace
characters with backslash sequences:</p><pre class="verbatim">&gt;&gt;&gt; print(repr(s))
'1 2\t 3\n 4'
</pre><p>This can be helpful for debugging.</p><p>One other problem you might run into is that different systems
use different characters to indicate the end of a line. Some
systems use a newline, represented <code class="verb">\n</code>. Others use
a return character, represented <code class="verb">\r</code>. Some use both.
If you move files between different systems, these inconsistencies
can cause problems.
<a id="hevea_default1300"></a></p><p>For most systems, there are applications to convert from one
format to another. You can find them (and read more about this
issue) at <a href="http://en.wikipedia.org/wiki/Newline"><span class="c004">http://en.wikipedia.org/wiki/Newline</span></a>. Or, of course, you
could write one yourself.</p>
<!--TOC section id="sec175" Glossary-->
<h2 class="section" id="sec175">14.11&#X2003;Glossary</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c010">persistent:</span></dt><dd class="dd-description"> Pertaining to a program that runs indefinitely
and keeps at least some of its data in permanent storage.
<a id="hevea_default1301"></a></dd><dt class="dt-description"><span class="c010">format operator:</span></dt><dd class="dd-description"> An operator, <span class="c004">%</span>, that takes a format
string and a tuple and generates a string that includes
the elements of the tuple formatted as specified by the format string.
<a id="hevea_default1302"></a>
<a id="hevea_default1303"></a></dd><dt class="dt-description"><span class="c010">format string:</span></dt><dd class="dd-description"> A string, used with the format operator, that
contains format sequences.
<a id="hevea_default1304"></a></dd><dt class="dt-description"><span class="c010">format sequence:</span></dt><dd class="dd-description"> A sequence of characters in a format string,
like <span class="c004">%d</span>, that specifies how a value should be formatted.
<a id="hevea_default1305"></a></dd><dt class="dt-description"><span class="c010">text file:</span></dt><dd class="dd-description"> A sequence of characters stored in permanent
storage like a hard drive.
<a id="hevea_default1306"></a></dd><dt class="dt-description"><span class="c010">directory:</span></dt><dd class="dd-description"> A named collection of files, also called a folder.
<a id="hevea_default1307"></a></dd><dt class="dt-description"><span class="c010">path:</span></dt><dd class="dd-description"> A string that identifies a file.
<a id="hevea_default1308"></a></dd><dt class="dt-description"><span class="c010">relative path:</span></dt><dd class="dd-description"> A path that starts from the current directory.
<a id="hevea_default1309"></a></dd><dt class="dt-description"><span class="c010">absolute path:</span></dt><dd class="dd-description"> A path that starts from the topmost directory
in the file system.
<a id="hevea_default1310"></a></dd><dt class="dt-description"><span class="c010">catch:</span></dt><dd class="dd-description"> To prevent an exception from terminating
a program using the <span class="c004">try</span>
and <span class="c004">except</span> statements.
<a id="hevea_default1311"></a></dd><dt class="dt-description"><span class="c010">database:</span></dt><dd class="dd-description"> A file whose contents are organized like a dictionary
with keys that correspond to values.
<a id="hevea_default1312"></a></dd><dt class="dt-description"><span class="c010">bytes object:</span></dt><dd class="dd-description"> An object similar to a string.
<a id="hevea_default1313"></a>
<a id="hevea_default1314"></a></dd><dt class="dt-description"><span class="c010">shell:</span></dt><dd class="dd-description"> A program that allows users to type commands and then
executes them by starting other programs.
<a id="hevea_default1315"></a></dd><dt class="dt-description"><span class="c010">pipe object:</span></dt><dd class="dd-description"> An object that represents a running program, allowing
a Python program to run commands and read the results.
<a id="hevea_default1316"></a>
<a id="hevea_default1317"></a></dd></dl>
<!--TOC section id="sec176" Exercises-->
<h2 class="section" id="sec176">14.12&#X2003;Exercises</h2><!--SEC END --><div class="theorem"><span class="c010">Exercise&#XA0;1</span>&#X2003;<p><em>Write a function called <span class="c004">sed</span> that takes as arguments a pattern string,
a replacement string, and two filenames; it should read the first file
and write the contents into the second file (creating it if
necessary). If the pattern string appears anywhere in the file, it
should be replaced with the replacement string.</em></p><p><em>If an error occurs while opening, reading, writing or closing files,
your program should catch the exception, print an error message, and
exit. Solution: </em><a href="https://thinkpython.com/code/sed.py"><em><span class="c004">https://thinkpython.com/code/sed.py</span></em></a><em>.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;2</span>&#X2003;
<a id="hevea_default1318"></a>
<a id="hevea_default1319"></a><p><em>If you download my solution to Exercise&#XA0;</em><a href="#anagrams"><em>2</em></a><em> from
</em><a href="https://thinkpython.com/code/anagram_sets.py"><em><span class="c004">https://thinkpython.com/code/anagram_sets.py</span></em></a><em>, you&#X2019;ll see that it creates
a dictionary that maps from a sorted string of letters to the list of
words that can be spelled with those letters. For example,
</em><code class="verb"><em>'opst'</em></code><em> maps to the list
</em><code class="verb"><em>['opts', 'post', 'pots', 'spot', 'stop', 'tops']</em></code><em>.</em></p><p><em>Write a module that imports </em><code class="verb"><em>anagram_sets</em></code><em> and provides
two new functions: </em><code class="verb"><em>store_anagrams</em></code><em> should store the
anagram dictionary in a &#X201C;shelf&#X201D;; </em><code class="verb"><em>read_anagrams</em></code><em> should
look up a word and return a list of its anagrams.
Solution: </em><a href="https://thinkpython.com/code/anagram_db.py"><em><span class="c004">https://thinkpython.com/code/anagram_db.py</span></em></a><em>.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;3</span>&#X2003;
<a id="checksum"></a>
<a id="hevea_default1320"></a><p><em>In a large collection of MP3 files, there may be more than one
copy of the same song, stored in different directories or with
different file names. The goal of this exercise is to search for
duplicates.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Write a program that searches a directory and all of its
subdirectories, recursively, and returns a list of complete paths
for all files with a given suffix (like <span class="c004">.mp3</span>).
Hint: <span class="c004">os.path</span> provides several useful functions for
manipulating file and path names.
</em><a id="hevea_default1321"></a>
<a id="hevea_default1322"></a>
<a id="hevea_default1323"></a>
<a id="hevea_default1324"></a></li><li class="li-enumerate"><em>To recognize duplicates, you can use <span class="c004">md5sum</span>
to compute a &#X201C;checksum&#X201D; for each files. If two files have
the same checksum, they probably have the same contents.
</em><a id="hevea_default1325"></a></li><li class="li-enumerate"><em>To double-check, you can use the Unix command <span class="c004">diff</span>.
</em><a id="hevea_default1326"></a></li></ol><p><em>Solution: </em><a href="https://thinkpython.com/code/find_duplicates.py"><em><span class="c004">https://thinkpython.com/code/find_duplicates.py</span></em></a><em>.</em></p></div>
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes"><a id="note1" href="#text1">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext"><span class="c004">popen</span> is deprecated
now, which means we are supposed to stop using it and start using
the <span class="c004">subprocess</span> module. But for simple cases, I find
<span class="c004">subprocess</span> more complicated than necessary. So I am going
to keep using <span class="c004">popen</span> until they take it away.</div></dd></dl>
<!--END NOTES-->
<!--TOC chapter id="sec177" Classes and objects-->
<h1 class="chapter" id="sec177">Chapter&#XA0;15&#X2003;Classes and objects</h1><!--SEC END --><p>
<a id="clobjects"></a></p><p>At this point you know how to use
functions to organize code and
built-in types to organize data. The next step is to learn
&#X201C;object-oriented programming&#X201D;, which uses programmer-defined types
to organize both code and data. Object-oriented programming is
a big topic; it will take a few chapters to get there.
<a id="hevea_default1327"></a></p><p>Code examples from this chapter are available from
<a href="https://thinkpython.com/code/Point1.py"><span class="c004">https://thinkpython.com/code/Point1.py</span></a>; solutions
to the exercises are available from
<a href="https://thinkpython.com/code/Point1_soln.py"><span class="c004">https://thinkpython.com/code/Point1_soln.py</span></a>.</p>
<!--TOC section id="sec178" Programmer-defined types-->
<h2 class="section" id="sec178">15.1&#X2003;Programmer-defined types</h2><!--SEC END --><p>
<a id="point"></a>
<a id="hevea_default1328"></a>
<a id="hevea_default1329"></a></p><p>We have used many of Python&#X2019;s built-in types; now we are going
to define a new type. As an example, we will create a type
called <span class="c004">Point</span> that represents a point in two-dimensional
space.
<a id="hevea_default1330"></a></p><p>In mathematical notation, points are often written in
parentheses with a comma separating the coordinates. For example,
(0,0) represents the origin, and (<span class="c009">x</span>,<span class="c009">y</span>) represents the
point <span class="c009">x</span> units to the right and <span class="c009">y</span> units up from the origin.</p><p>There are several ways we might represent points in Python:</p><ul class="itemize"><li class="li-itemize">We could store the coordinates separately in two
variables, <span class="c004">x</span> and <span class="c004">y</span>.</li><li class="li-itemize">We could store the coordinates as elements in a list
or tuple.</li><li class="li-itemize">We could create a new type to represent points as
objects.</li></ul><p>
<a id="hevea_default1331"></a></p><p>Creating a new type
is more complicated than the other options, but
it has advantages that will be apparent soon.</p><p>A programmer-defined type is also called a <span class="c010">class</span>.
A class definition looks like this:
<a id="hevea_default1332"></a>
<a id="hevea_default1333"></a>
<a id="hevea_default1334"></a>
<a id="hevea_default1335"></a></p><pre class="verbatim">class Point:
    """Represents a point in 2-D space."""
</pre><p>
The header indicates that the new class is called <span class="c004">Point</span>.
The body is a docstring that explains what the class is for.
You can define variables and methods inside a class definition,
but we will get back to that later.
<a id="hevea_default1336"></a>
<a id="hevea_default1337"></a>
<a id="hevea_default1338"></a></p><p>Defining a class named <span class="c004">Point</span> creates a <span class="c010">class object</span>.</p><pre class="verbatim">&gt;&gt;&gt; Point
&lt;class '__main__.Point'&gt;
</pre><p>
Because <span class="c004">Point</span> is defined at the top level, its &#X201C;full
name&#X201D; is <code class="verb">__main__.Point</code>.
<a id="hevea_default1339"></a>
<a id="hevea_default1340"></a></p><p>The class object is like a factory for creating objects. To create a
Point, you call <span class="c004">Point</span> as if it were a function.</p><pre class="verbatim">&gt;&gt;&gt; blank = Point()
&gt;&gt;&gt; blank
&lt;__main__.Point object at 0xb7e9d3ac&gt;
</pre><p>
The return value is a reference to a Point object, which we
assign to <span class="c004">blank</span>.</p><p>Creating a new object is called
<span class="c010">instantiation</span>, and the object is an <span class="c010">instance</span> of
the class.
<a id="hevea_default1341"></a>
<a id="hevea_default1342"></a></p><p>When you print an instance, Python tells you what class it
belongs to and where it is stored in memory (the prefix
<span class="c004">0x</span> means that the following number is in hexadecimal).
<a id="hevea_default1343"></a></p><p>Every object is an instance of some class, so &#X201C;object&#X201D; and
&#X201C;instance&#X201D; are interchangeable. But in this chapter I use
&#X201C;instance&#X201D; to indicate that I am talking about a programmer-defined
type.</p>
<!--TOC section id="sec179" Attributes-->
<h2 class="section" id="sec179">15.2&#X2003;Attributes</h2><!--SEC END --><p>
<a id="attributes"></a>
<a id="hevea_default1344"></a>
<a id="hevea_default1345"></a>
<a id="hevea_default1346"></a></p><p>You can assign values to an instance using dot notation:</p><pre class="verbatim">&gt;&gt;&gt; blank.x = 3.0
&gt;&gt;&gt; blank.y = 4.0
</pre><p>
This syntax is similar to the syntax for selecting a variable from a
module, such as <span class="c004">math.pi</span> or <span class="c004">string.whitespace</span>. In this case,
though, we are assigning values to named elements of an object.
These elements are called <span class="c010">attributes</span>.</p><p>As a noun, &#X201C;AT-trib-ute&#X201D; is pronounced with emphasis on the first
syllable, as opposed to &#X201C;a-TRIB-ute&#X201D;, which is a verb.</p><p>Figure&#XA0;<a href="#fig.point">15.1</a> is a state diagram that shows the result of these assignments.
A state diagram that shows an object and its attributes is
called an <span class="c010">object diagram</span>.
<a id="hevea_default1347"></a>
<a id="hevea_default1348"></a>
<a id="hevea_default1349"></a>
<a id="hevea_default1350"></a></p><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2020.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 15.1: Object diagram.</td></tr>
</table></div>
<a id="fig.point"></a>
<div class="center"><hr class="floatrule"></div></blockquote><p>The variable <span class="c004">blank</span> refers to a Point object, which
contains two attributes. Each attribute refers to a
floating-point number.</p><p>You can read the value of an attribute using the same syntax:</p><pre class="verbatim">&gt;&gt;&gt; blank.y
4.0
&gt;&gt;&gt; x = blank.x
&gt;&gt;&gt; x
3.0
</pre><p>
The expression <span class="c004">blank.x</span> means, &#X201C;Go to the object <span class="c004">blank</span>
refers to and get the value of <span class="c004">x</span>.&#X201D; In the example, we assign that
value to a variable named <span class="c004">x</span>. There is no conflict between
the variable <span class="c004">x</span> and the attribute <span class="c004">x</span>.</p><p>You can use dot notation as part of any expression. For example:</p><pre class="verbatim">&gt;&gt;&gt; '(%g, %g)' % (blank.x, blank.y)
'(3.0, 4.0)'
&gt;&gt;&gt; distance = math.sqrt(blank.x**2 + blank.y**2)
&gt;&gt;&gt; distance
5.0
</pre><p>
You can pass an instance as an argument in the usual way.
For example:
<a id="hevea_default1351"></a></p><pre class="verbatim">def print_point(p):
    print('(%g, %g)' % (p.x, p.y))
</pre><p>
<code class="verb">print_point</code> takes a point as an argument and displays it in
mathematical notation. To invoke it, you can pass <span class="c004">blank</span> as
an argument:</p><pre class="verbatim">&gt;&gt;&gt; print_point(blank)
(3.0, 4.0)
</pre><p>
Inside the function, <span class="c004">p</span> is an alias for <span class="c004">blank</span>, so if
the function modifies <span class="c004">p</span>, <span class="c004">blank</span> changes.
<a id="hevea_default1352"></a></p><p>As an exercise, write a function called <code class="verb">distance_between_points</code>
that takes two Points as arguments and returns the distance between
them.</p>
<!--TOC section id="sec180" Rectangles-->
<h2 class="section" id="sec180">15.3&#X2003;Rectangles</h2><!--SEC END --><p>
<a id="rectangles"></a></p><p>Sometimes it is obvious what the attributes of an object should be,
but other times you have to make decisions. For example, imagine you
are designing a class to represent rectangles. What attributes would
you use to specify the location and size of a rectangle? You can
ignore angle; to keep things simple, assume that the rectangle is
either vertical or horizontal.
<a id="hevea_default1353"></a></p><p>There are at least two possibilities:</p><ul class="itemize"><li class="li-itemize">You could specify one corner of the rectangle
(or the center), the width, and the height.</li><li class="li-itemize">You could specify two opposing corners.</li></ul><p>At this point it is hard to say whether either is better than
the other, so we&#X2019;ll implement the first one, just as an example.
<a id="hevea_default1354"></a>
<a id="hevea_default1355"></a></p><p>Here is the class definition:</p><pre class="verbatim">class Rectangle:
    """Represents a rectangle.

    attributes: width, height, corner.
    """
</pre><p>
The docstring lists the attributes: <span class="c004">width</span> and
<span class="c004">height</span> are numbers; <span class="c004">corner</span> is a Point object that
specifies the lower-left corner.</p><p>To represent a rectangle, you have to instantiate a Rectangle
object and assign values to the attributes:</p><pre class="verbatim">box = Rectangle()
box.width = 100.0
box.height = 200.0
box.corner = Point()
box.corner.x = 0.0
box.corner.y = 0.0
</pre><p>
The expression <span class="c004">box.corner.x</span> means,
&#X201C;Go to the object <span class="c004">box</span> refers to and select the attribute named
<span class="c004">corner</span>; then go to that object and select the attribute named
<span class="c004">x</span>.&#X201D;</p><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2021.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 15.2: Object diagram.</td></tr>
</table></div>
<a id="fig.rectangle"></a>
<div class="center"><hr class="floatrule"></div></blockquote><p>Figure&#XA0;<a href="#fig.rectangle">15.2</a> shows the state of this object.
An object that is an attribute of another object is <span class="c010">embedded</span>.
<a id="hevea_default1356"></a>
<a id="hevea_default1357"></a>
<a id="hevea_default1358"></a>
<a id="hevea_default1359"></a>
<a id="hevea_default1360"></a>
<a id="hevea_default1361"></a></p>
<!--TOC section id="sec181" Instances as return values-->
<h2 class="section" id="sec181">15.4&#X2003;Instances as return values</h2><!--SEC END --><p>
<a id="hevea_default1362"></a>
<a id="hevea_default1363"></a></p><p>Functions can return instances. For example, <code class="verb">find_center</code>
takes a <span class="c004">Rectangle</span> as an argument and returns a <span class="c004">Point</span>
that contains the coordinates of the center of the <span class="c004">Rectangle</span>:</p><pre class="verbatim">def find_center(rect):
    p = Point()
    p.x = rect.corner.x + rect.width/2
    p.y = rect.corner.y + rect.height/2
    return p
</pre><p>
Here is an example that passes <span class="c004">box</span> as an argument and assigns
the resulting Point to <span class="c004">center</span>:</p><pre class="verbatim">&gt;&gt;&gt; center = find_center(box)
&gt;&gt;&gt; print_point(center)
(50, 100)
</pre>
<!--TOC section id="sec182" Objects are mutable-->
<h2 class="section" id="sec182">15.5&#X2003;Objects are mutable</h2><!--SEC END --><p>
<a id="hevea_default1364"></a>
<a id="hevea_default1365"></a></p><p>You can change the state of an object by making an assignment to one of
its attributes. For example, to change the size of a rectangle
without changing its position, you can modify the values of <span class="c004">width</span> and <span class="c004">height</span>:</p><pre class="verbatim">box.width = box.width + 50
box.height = box.height + 100
</pre><p>
You can also write functions that modify objects. For example,
<code class="verb">grow_rectangle</code> takes a Rectangle object and two numbers,
<span class="c004">dwidth</span> and <span class="c004">dheight</span>, and adds the numbers to the
width and height of the rectangle:</p><pre class="verbatim">def grow_rectangle(rect, dwidth, dheight):
    rect.width += dwidth
    rect.height += dheight
</pre><p>
Here is an example that demonstrates the effect:</p><pre class="verbatim">&gt;&gt;&gt; box.width, box.height
(150.0, 300.0)
&gt;&gt;&gt; grow_rectangle(box, 50, 100)
&gt;&gt;&gt; box.width, box.height
(200.0, 400.0)
</pre><p>
Inside the function, <span class="c004">rect</span> is an
alias for <span class="c004">box</span>, so when the function modifies <span class="c004">rect</span>,
<span class="c004">box</span> changes.</p><p>As an exercise, write a function named <code class="verb">move_rectangle</code> that takes
a Rectangle and two numbers named <span class="c004">dx</span> and <span class="c004">dy</span>. It
should change the location of the rectangle by adding <span class="c004">dx</span>
to the <span class="c004">x</span> coordinate of <span class="c004">corner</span> and adding <span class="c004">dy</span>
to the <span class="c004">y</span> coordinate of <span class="c004">corner</span>.</p>
<!--TOC section id="sec183" Copying-->
<h2 class="section" id="sec183">15.6&#X2003;Copying</h2><!--SEC END --><p>
<a id="copying"></a>
<a id="hevea_default1366"></a></p><p>Aliasing can make a program difficult to read because changes
in one place might have unexpected effects in another place.
It is hard to keep track of all the variables that might refer
to a given object.
<a id="hevea_default1367"></a>
<a id="hevea_default1368"></a>
<a id="hevea_default1369"></a>
<a id="hevea_default1370"></a></p><p>Copying an object is often an alternative to aliasing.
The <span class="c004">copy</span> module contains a function called <span class="c004">copy</span> that
can duplicate any object:</p><pre class="verbatim">&gt;&gt;&gt; p1 = Point()
&gt;&gt;&gt; p1.x = 3.0
&gt;&gt;&gt; p1.y = 4.0

&gt;&gt;&gt; import copy
&gt;&gt;&gt; p2 = copy.copy(p1)
</pre><p>
<span class="c004">p1</span> and <span class="c004">p2</span> contain the same data, but they are
not the same Point.</p><pre class="verbatim">&gt;&gt;&gt; print_point(p1)
(3, 4)
&gt;&gt;&gt; print_point(p2)
(3, 4)
&gt;&gt;&gt; p1 is p2
False
&gt;&gt;&gt; p1 == p2
False
</pre><p>
The <span class="c004">is</span> operator indicates that <span class="c004">p1</span> and <span class="c004">p2</span> are not the
same object, which is what we expected. But you might have expected
<span class="c004">==</span> to yield <span class="c004">True</span> because these points contain the same
data. In that case, you will be disappointed to learn that for
instances, the default behavior of the <span class="c004">==</span> operator is the same
as the <span class="c004">is</span> operator; it checks object identity, not object
equivalence. That&#X2019;s because for programmer-defined types, Python doesn&#X2019;t
know what should be considered equivalent. At least, not yet.
<a id="hevea_default1371"></a>
<a id="hevea_default1372"></a>
<a id="hevea_default1373"></a>
<a id="hevea_default1374"></a></p><p>If you use <span class="c004">copy.copy</span> to duplicate a Rectangle, you will find
that it copies the Rectangle object but not the embedded Point.
<a id="hevea_default1375"></a></p><pre class="verbatim">&gt;&gt;&gt; box2 = copy.copy(box)
&gt;&gt;&gt; box2 is box
False
&gt;&gt;&gt; box2.corner is box.corner
True
</pre><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2022.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 15.3: Object diagram.</td></tr>
</table></div>
<a id="fig.rectangle2"></a>
<div class="center"><hr class="floatrule"></div></blockquote><p>Figure&#XA0;<a href="#fig.rectangle2">15.3</a> shows what the object diagram looks like.
<a id="hevea_default1376"></a>
<a id="hevea_default1377"></a>
<a id="hevea_default1378"></a>
<a id="hevea_default1379"></a>
This operation is called a <span class="c010">shallow copy</span> because it copies the
object and any references it contains, but not the embedded objects.
<a id="hevea_default1380"></a>
<a id="hevea_default1381"></a></p><p>For most applications, this is not what you want. In this example,
invoking <code class="verb">grow_rectangle</code> on one of the Rectangles would not
affect the other, but invoking <code class="verb">move_rectangle</code> on either would
affect both! This behavior is confusing and error-prone.
<a id="hevea_default1382"></a>
<a id="hevea_default1383"></a></p><p>Fortunately, the <span class="c004">copy</span> module provides a method named <span class="c004">deepcopy</span> that copies not only the object but also
the objects it refers to, and the objects <em>they</em> refer to,
and so on.
You will not be surprised to learn that this operation is
called a <span class="c010">deep copy</span>.
<a id="hevea_default1384"></a>
<a id="hevea_default1385"></a></p><pre class="verbatim">&gt;&gt;&gt; box3 = copy.deepcopy(box)
&gt;&gt;&gt; box3 is box
False
&gt;&gt;&gt; box3.corner is box.corner
False
</pre><p>
<span class="c004">box3</span> and <span class="c004">box</span> are completely separate objects.</p><p>As an exercise, write a version of <code class="verb">move_rectangle</code> that creates and
returns a new Rectangle instead of modifying the old one.</p>
<!--TOC section id="sec184" Debugging-->
<h2 class="section" id="sec184">15.7&#X2003;Debugging</h2><!--SEC END --><p>
<a id="hasattr"></a>
<a id="hevea_default1386"></a></p><p>When you start working with objects, you are likely to encounter
some new exceptions. If you try to access an attribute
that doesn&#X2019;t exist, you get an <span class="c004">AttributeError</span>:
<a id="hevea_default1387"></a>
<a id="hevea_default1388"></a></p><pre class="verbatim">&gt;&gt;&gt; p = Point()
&gt;&gt;&gt; p.x = 3
&gt;&gt;&gt; p.y = 4
&gt;&gt;&gt; p.z
AttributeError: Point instance has no attribute 'z'
</pre><p>
If you are not sure what type an object is, you can ask:
<a id="hevea_default1389"></a>
<a id="hevea_default1390"></a></p><pre class="verbatim">&gt;&gt;&gt; type(p)
&lt;class '__main__.Point'&gt;
</pre><p>
You can also use <span class="c004">isinstance</span> to check whether an object
is an instance of a class:
<a id="hevea_default1391"></a>
<a id="hevea_default1392"></a></p><pre class="verbatim">&gt;&gt;&gt; isinstance(p, Point)
True
</pre><p>
If you are not sure whether an object has a particular attribute,
you can use the built-in function <span class="c004">hasattr</span>:
<a id="hevea_default1393"></a>
<a id="hevea_default1394"></a></p><pre class="verbatim">&gt;&gt;&gt; hasattr(p, 'x')
True
&gt;&gt;&gt; hasattr(p, 'z')
False
</pre><p>
The first argument can be any object; the second argument is a <em>string</em> that contains the name of the attribute.
<a id="hevea_default1395"></a></p><p>You can also use a <span class="c004">try</span> statement to see if the object has the
attributes you need:
<a id="hevea_default1396"></a>
<a id="hevea_default1397"></a></p><pre class="verbatim">try:
    x = p.x
except AttributeError:
    x = 0
</pre><p>This approach can make it easier to write functions that work with
different types; more on that topic is
coming up in Section&#XA0;<a href="#polymorphism">17.9</a>.</p>
<!--TOC section id="sec185" Glossary-->
<h2 class="section" id="sec185">15.8&#X2003;Glossary</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c010">class:</span></dt><dd class="dd-description"> A programmer-defined type. A class definition creates a new
class object.
<a id="hevea_default1398"></a>
<a id="hevea_default1399"></a>
<a id="hevea_default1400"></a></dd><dt class="dt-description"><span class="c010">class object:</span></dt><dd class="dd-description"> An object that contains information about a
programmer-defined type. The class object can be used to create instances
of the type.
<a id="hevea_default1401"></a>
<a id="hevea_default1402"></a></dd><dt class="dt-description"><span class="c010">instance:</span></dt><dd class="dd-description"> An object that belongs to a class.
<a id="hevea_default1403"></a></dd><dt class="dt-description"><span class="c010">instantiate:</span></dt><dd class="dd-description"> To create a new object.
<a id="hevea_default1404"></a></dd><dt class="dt-description"><span class="c010">attribute:</span></dt><dd class="dd-description"> One of the named values associated with an object.
<a id="hevea_default1405"></a>
<a id="hevea_default1406"></a></dd><dt class="dt-description"><span class="c010">embedded object:</span></dt><dd class="dd-description"> An object that is stored as an attribute
of another object.
<a id="hevea_default1407"></a>
<a id="hevea_default1408"></a></dd><dt class="dt-description"><span class="c010">shallow copy:</span></dt><dd class="dd-description"> To copy the contents of an object, including
any references to embedded objects;
implemented by the <span class="c004">copy</span> function in the <span class="c004">copy</span> module.
<a id="hevea_default1409"></a></dd><dt class="dt-description"><span class="c010">deep copy:</span></dt><dd class="dd-description"> To copy the contents of an object as well as any
embedded objects, and any objects embedded in them, and so on;
implemented by the <span class="c004">deepcopy</span> function in the <span class="c004">copy</span> module.
<a id="hevea_default1410"></a></dd><dt class="dt-description"><span class="c010">object diagram:</span></dt><dd class="dd-description"> A diagram that shows objects, their
attributes, and the values of the attributes.
<a id="hevea_default1411"></a>
<a id="hevea_default1412"></a></dd></dl>
<!--TOC section id="sec186" Exercises-->
<h2 class="section" id="sec186">15.9&#X2003;Exercises</h2><!--SEC END --><div class="theorem"><span class="c010">Exercise&#XA0;1</span>&#X2003;<p><em>Write a definition for a class named <span class="c004">Circle</span> with attributes
<span class="c004">center</span> and <span class="c004">radius</span>, where <span class="c004">center</span> is a Point object
and <span class="c004">radius</span> is a number.</em></p><p><em>Instantiate a Circle object that represents a circle with its center
at </em>(150, 100)<em> and radius 75.</em></p><p><em>Write a function named </em><code class="verb"><em>point_in_circle</em></code><em> that takes a Circle and
a Point and returns True if the Point lies in or on the boundary of
the circle.</em></p><p><em>Write a function named </em><code class="verb"><em>rect_in_circle</em></code><em> that takes a Circle and a
Rectangle and returns True if the Rectangle lies entirely in or on the boundary
of the circle.</em></p><p><em>Write a function named </em><code class="verb"><em>rect_circle_overlap</em></code><em> that takes a Circle
and a Rectangle and returns True if any of the corners of the Rectangle fall
inside the Circle. Or as a more challenging version, return True if
any part of the Rectangle falls inside the Circle.</em></p><p><em>Solution: </em><a href="https://thinkpython.com/code/Circle.py"><em><span class="c004">https://thinkpython.com/code/Circle.py</span></em></a><em>.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;2</span>&#X2003;<p><em>Write a function called </em><code class="verb"><em>draw_rect</em></code><em> that takes a Turtle object
and a Rectangle and uses the Turtle to draw the Rectangle. See
Chapter&#XA0;</em><a href="#turtlechap"><em>4</em></a><em> for examples using Turtle objects.</em></p><p><em>Write a function called </em><code class="verb"><em>draw_circle</em></code><em> that takes a Turtle and
a Circle and draws the Circle.</em></p><p><em>Solution: </em><a href="https://thinkpython.com/code/draw.py"><em><span class="c004">https://thinkpython.com/code/draw.py</span></em></a><em>.</em></p></div>
<!--TOC chapter id="sec187" Classes and functions-->
<h1 class="chapter" id="sec187">Chapter&#XA0;16&#X2003;Classes and functions</h1><!--SEC END --><p>
<a id="time"></a></p><p>Now that we know how to create new types, the next
step is to write functions that take programmer-defined objects
as parameters and return them as results. In this chapter I
also present &#X201C;functional programming style&#X201D; and two new
program development plans.</p><p>Code examples from this chapter are available from
<a href="https://thinkpython.com/code/Time1.py"><span class="c004">https://thinkpython.com/code/Time1.py</span></a>.
Solutions to the exercises are at
<a href="https://thinkpython.com/code/Time1_soln.py"><span class="c004">https://thinkpython.com/code/Time1_soln.py</span></a>.</p>
<!--TOC section id="sec188" Time-->
<h2 class="section" id="sec188">16.1&#X2003;Time</h2><!--SEC END --><p>
<a id="isafter"></a></p><p>As another example of a programmer-defined type, we&#X2019;ll define a class
called <span class="c004">Time</span> that records the time of day. The class definition
looks like this: <a id="hevea_default1413"></a>
<a id="hevea_default1414"></a> <a id="hevea_default1415"></a> <a id="hevea_default1416"></a></p><pre class="verbatim">class Time:
    """Represents the time of day.

    attributes: hour, minute, second
    """
</pre><p>
We can create a new <span class="c004">Time</span> object and assign
attributes for hours, minutes, and seconds:</p><pre class="verbatim">time = Time()
time.hour = 11
time.minute = 59
time.second = 30
</pre><p>
The state diagram for the <span class="c004">Time</span> object looks like Figure&#XA0;<a href="#fig.time">16.1</a>.
<a id="hevea_default1417"></a>
<a id="hevea_default1418"></a>
<a id="hevea_default1419"></a>
<a id="hevea_default1420"></a></p><p>As an exercise, write a function called <code class="verb">print_time</code> that takes a
Time object and prints it in the form <span class="c004">hour:minute:second</span>.
Hint: the format sequence <code class="verb">'%.2d'</code> prints an integer using
at least two digits, including a leading zero if necessary.</p><p>Write a boolean function called <code class="verb">is_after</code> that
takes two Time objects, <span class="c004">t1</span> and <span class="c004">t2</span>, and
returns <span class="c004">True</span> if <span class="c004">t1</span> follows <span class="c004">t2</span> chronologically and
<span class="c004">False</span> otherwise. Challenge: don&#X2019;t use an <span class="c004">if</span> statement.</p><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2023.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 16.1: Object diagram.</td></tr>
</table></div>
<a id="fig.time"></a>
<div class="center"><hr class="floatrule"></div></blockquote>
<!--TOC section id="sec189" Pure functions-->
<h2 class="section" id="sec189">16.2&#X2003;Pure functions</h2><!--SEC END --><p>
<a id="hevea_default1421"></a>
<a id="hevea_default1422"></a></p><p>In the next few sections, we&#X2019;ll write two functions that add time
values. They demonstrate two kinds of functions: pure functions and
modifiers. They also demonstrate a development plan I&#X2019;ll call <span class="c010">prototype and patch</span>, which is a way of tackling a complex problem
by starting with a simple prototype and incrementally dealing with the
complications.</p><p>Here is a simple prototype of <code class="verb">add_time</code>:</p><pre class="verbatim">def add_time(t1, t2):
    sum = Time()
    sum.hour = t1.hour + t2.hour
    sum.minute = t1.minute + t2.minute
    sum.second = t1.second + t2.second
    return sum
</pre><p>
The function creates a new <span class="c004">Time</span> object, initializes its
attributes, and returns a reference to the new object. This is called
a <span class="c010">pure function</span> because it does not modify any of the objects
passed to it as arguments and it has no effect,
like displaying a value or getting user input,
other than returning a value.
<a id="hevea_default1423"></a>
<a id="hevea_default1424"></a></p><p>To test this function, I&#X2019;ll create two Time objects: <span class="c004">start</span>
contains the start time of a movie, like <em>Monty Python and the
Holy Grail</em>, and <span class="c004">duration</span> contains the run time of the movie,
which is one hour 35 minutes.
<a id="hevea_default1425"></a></p><p><code class="verb">add_time</code> figures out when the movie will be done.</p><pre class="verbatim">&gt;&gt;&gt; start = Time()
&gt;&gt;&gt; start.hour = 9
&gt;&gt;&gt; start.minute = 45
&gt;&gt;&gt; start.second =  0

&gt;&gt;&gt; duration = Time()
&gt;&gt;&gt; duration.hour = 1
&gt;&gt;&gt; duration.minute = 35
&gt;&gt;&gt; duration.second = 0

&gt;&gt;&gt; done = add_time(start, duration)
&gt;&gt;&gt; print_time(done)
10:80:00
</pre><p>
The result, <span class="c004">10:80:00</span> might not be what you were hoping
for. The problem is that this function does not deal with cases where the
number of seconds or minutes adds up to more than sixty. When that
happens, we have to &#X201C;carry&#X201D; the extra seconds into the minute column
or the extra minutes into the hour column.
<a id="hevea_default1426"></a></p><p>Here&#X2019;s an improved version:</p><pre class="verbatim">def add_time(t1, t2):
    sum = Time()
    sum.hour = t1.hour + t2.hour
    sum.minute = t1.minute + t2.minute
    sum.second = t1.second + t2.second

    if sum.second &gt;= 60:
        sum.second -= 60
        sum.minute += 1

    if sum.minute &gt;= 60:
        sum.minute -= 60
        sum.hour += 1

    return sum
</pre><p>
Although this function is correct, it is starting to get big.
We will see a shorter alternative later.</p>
<!--TOC section id="sec190" Modifiers-->
<h2 class="section" id="sec190">16.3&#X2003;Modifiers</h2><!--SEC END --><p>
<a id="increment"></a>
<a id="hevea_default1427"></a>
<a id="hevea_default1428"></a></p><p>Sometimes it is useful for a function to modify the objects it gets as
parameters. In that case, the changes are visible to the caller.
Functions that work this way are called <span class="c010">modifiers</span>.
<a id="hevea_default1429"></a></p><p><span class="c004">increment</span>, which adds a given number of seconds to a <span class="c004">Time</span>
object, can be written naturally as a
modifier. Here is a rough draft:</p><pre class="verbatim">def increment(time, seconds):
    time.second += seconds

    if time.second &gt;= 60:
        time.second -= 60
        time.minute += 1

    if time.minute &gt;= 60:
        time.minute -= 60
        time.hour += 1
</pre><p>
The first line performs the basic operation; the remainder deals
with the special cases we saw before.
<a id="hevea_default1430"></a></p><p>Is this function correct? What happens if <span class="c004">seconds</span>
is much greater than sixty?</p><p>In that case, it is not enough to carry once; we have to keep doing it
until <span class="c004">time.second</span> is less than sixty. One solution is to
replace the <span class="c004">if</span> statements with <span class="c004">while</span> statements. That
would make the function correct, but not very efficient. As an
exercise, write a correct version of <span class="c004">increment</span> that doesn&#X2019;t
contain any loops.</p><p>Anything that can be done with modifiers can also be done with pure
functions. In fact, some programming languages only allow pure
functions. There is some evidence that programs that use pure
functions are faster to develop and less error-prone than programs
that use modifiers. But modifiers are convenient at times,
and functional programs tend to be less efficient.</p><p>In general, I recommend that you write pure functions whenever it is
reasonable and resort to modifiers only if there is a compelling
advantage. This approach might be called a <span class="c010">functional
programming style</span>.
<a id="hevea_default1431"></a></p><p>As an exercise, write a &#X201C;pure&#X201D; version of <span class="c004">increment</span> that
creates and returns a new Time object rather than modifying the
parameter.</p>
<!--TOC section id="sec191" Prototyping versus planning-->
<h2 class="section" id="sec191">16.4&#X2003;Prototyping versus planning</h2><!--SEC END --><p>
<a id="prototype"></a>
<a id="hevea_default1432"></a>
<a id="hevea_default1433"></a>
<a id="hevea_default1434"></a>
<a id="hevea_default1435"></a></p><p>The development plan I am demonstrating is called &#X201C;prototype and
patch&#X201D;. For each function, I wrote a prototype that performed the
basic calculation and then tested it, patching errors along the
way.</p><p>This approach can be effective, especially if you don&#X2019;t yet have a
deep understanding of the problem. But incremental corrections can
generate code that is unnecessarily complicated&#X2014;since it deals with
many special cases&#X2014;and unreliable&#X2014;since it is hard to know if you
have found all the errors.</p><p>An alternative is <span class="c010">designed development</span>, in which high-level
insight into the problem can make the programming much easier. In
this case, the insight is that a Time object is really a three-digit
number in base 60 (see <a href="http://en.wikipedia.org/wiki/Sexagesimal"><span class="c004">http://en.wikipedia.org/wiki/Sexagesimal</span></a>). The
<span class="c004">second</span> attribute is the &#X201C;ones column&#X201D;, the <span class="c004">minute</span>
attribute is the &#X201C;sixties column&#X201D;, and the <span class="c004">hour</span> attribute is
the &#X201C;thirty-six hundreds column&#X201D;.
<a id="hevea_default1436"></a></p><p>When we wrote <code class="verb">add_time</code> and <span class="c004">increment</span>, we were effectively
doing addition in base 60, which is why we had to carry from one
column to the next.
<a id="hevea_default1437"></a></p><p>This observation suggests another approach to the whole problem&#X2014;we
can convert Time objects to integers and take advantage of the fact
that the computer knows how to do integer arithmetic.</p><p>Here is a function that converts Times to integers:</p><pre class="verbatim">def time_to_int(time):
    minutes = time.hour * 60 + time.minute
    seconds = minutes * 60 + time.second
    return seconds
</pre><p>
And here is a function that converts an integer to a Time
(recall that <span class="c004">divmod</span> divides the first argument by the second
and returns the quotient and remainder as a tuple).
<a id="hevea_default1438"></a></p><pre class="verbatim">def int_to_time(seconds):
    time = Time()
    minutes, time.second = divmod(seconds, 60)
    time.hour, time.minute = divmod(minutes, 60)
    return time
</pre><p>
You might have to think a bit, and run some tests, to convince
yourself that these functions are correct. One way to test them is to
check that <code class="verb">time_to_int(int_to_time(x)) == x</code> for many values of
<span class="c004">x</span>. This is an example of a consistency check.
<a id="hevea_default1439"></a></p><p>Once you are convinced they are correct, you can use them to
rewrite <code class="verb">add_time</code>:</p><pre class="verbatim">def add_time(t1, t2):
    seconds = time_to_int(t1) + time_to_int(t2)
    return int_to_time(seconds)
</pre><p>
This version is shorter than the original, and easier to verify. As
an exercise, rewrite <span class="c004">increment</span> using <code class="verb">time_to_int</code> and
<code class="verb">int_to_time</code>.</p><p>In some ways, converting from base 60 to base 10 and back is harder
than just dealing with times. Base conversion is more abstract; our
intuition for dealing with time values is better.</p><p>But if we have the insight to treat times as base 60 numbers and make
the investment of writing the conversion functions (<code class="verb">time_to_int</code>
and <code class="verb">int_to_time</code>), we get a program that is shorter, easier to
read and debug, and more reliable.</p><p>It is also easier to add features later. For example, imagine
subtracting two Times to find the duration between them. The
naive approach would be to implement subtraction with borrowing.
Using the conversion functions would be easier and more likely to be
correct.
<a id="hevea_default1440"></a>
<a id="hevea_default1441"></a>
<a id="hevea_default1442"></a></p><p>Ironically, sometimes making a problem harder (or more general) makes it
easier (because there are fewer special cases and fewer opportunities
for error).</p>
<!--TOC section id="sec192" Debugging-->
<h2 class="section" id="sec192">16.5&#X2003;Debugging</h2><!--SEC END --><p>
<a id="hevea_default1443"></a></p><p>A Time object is well-formed if the values of <span class="c004">minute</span> and <span class="c004">second</span> are between 0 and 60 (including 0 but not 60) and if
<span class="c004">hour</span> is positive. <span class="c004">hour</span> and <span class="c004">minute</span> should be
integer values, but we might allow <span class="c004">second</span> to have a
fraction part.
<a id="hevea_default1444"></a></p><p>Requirements like these are called <span class="c010">invariants</span> because
they should always be true. To put it a different way, if they
are not true, something has gone wrong.</p><p>Writing code to check invariants can help detect errors
and find their causes. For example, you might have a function
like <code class="verb">valid_time</code> that takes a Time object and returns
<span class="c004">False</span> if it violates an invariant:</p><pre class="verbatim">def valid_time(time):
    if time.hour &lt; 0 or time.minute &lt; 0 or time.second &lt; 0:
        return False
    if time.minute &gt;= 60 or time.second &gt;= 60:
        return False
    return True
</pre><p>
At the beginning of each function you could check the
arguments to make sure they are valid:
<a id="hevea_default1445"></a>
<a id="hevea_default1446"></a></p><pre class="verbatim">def add_time(t1, t2):
    if not valid_time(t1) or not valid_time(t2):
        raise ValueError('invalid Time object in add_time')
    seconds = time_to_int(t1) + time_to_int(t2)
    return int_to_time(seconds)
</pre><p>
Or you could use an <span class="c010">assert statement</span>, which checks a given invariant
and raises an exception if it fails:
<a id="hevea_default1447"></a>
<a id="hevea_default1448"></a></p><pre class="verbatim">def add_time(t1, t2):
    assert valid_time(t1) and valid_time(t2)
    seconds = time_to_int(t1) + time_to_int(t2)
    return int_to_time(seconds)
</pre><p>
<span class="c004">assert</span> statements are useful because they distinguish
code that deals with normal conditions from code
that checks for errors.</p>
<!--TOC section id="sec193" Glossary-->
<h2 class="section" id="sec193">16.6&#X2003;Glossary</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c010">prototype and patch:</span></dt><dd class="dd-description"> A development plan that involves
writing a rough draft of a program, testing, and correcting errors as
they are found.
<a id="hevea_default1449"></a></dd><dt class="dt-description"><span class="c010">designed development:</span></dt><dd class="dd-description"> A development plan that involves
high-level insight into the problem and more planning than incremental
development or prototype development.
<a id="hevea_default1450"></a></dd><dt class="dt-description"><span class="c010">pure function:</span></dt><dd class="dd-description"> A function that does not modify any of the objects it
receives as arguments. Most pure functions are fruitful.
<a id="hevea_default1451"></a></dd><dt class="dt-description"><span class="c010">modifier:</span></dt><dd class="dd-description"> A function that changes one or more of the objects it
receives as arguments. Most modifiers are void; that is, they
return <span class="c004">None</span>. <a id="hevea_default1452"></a></dd><dt class="dt-description"><span class="c010">functional programming style:</span></dt><dd class="dd-description"> A style of program design in which the
majority of functions are pure.
<a id="hevea_default1453"></a></dd><dt class="dt-description"><span class="c010">invariant:</span></dt><dd class="dd-description"> A condition that should always be true during the
execution of a program.
<a id="hevea_default1454"></a></dd><dt class="dt-description"><span class="c010">assert statement:</span></dt><dd class="dd-description"> A statement that checks a condition and raises
an exception if it fails.
<a id="hevea_default1455"></a>
<a id="hevea_default1456"></a></dd></dl>
<!--TOC section id="sec194" Exercises-->
<h2 class="section" id="sec194">16.7&#X2003;Exercises</h2><!--SEC END --><p>Code examples from this chapter are available from
<a href="https://thinkpython.com/code/Time1.py"><span class="c004">https://thinkpython.com/code/Time1.py</span></a>; solutions to the
exercises are available from <a href="https://thinkpython.com/code/Time1_soln.py"><span class="c004">https://thinkpython.com/code/Time1_soln.py</span></a>.</p><div class="theorem"><span class="c010">Exercise&#XA0;1</span>&#X2003;<p><em>Write a function called </em><code class="verb"><em>mul_time</em></code><em> that takes a Time object
and a number and returns a new Time object that contains
the product of the original Time and the number.</em></p><p><em>Then use </em><code class="verb"><em>mul_time</em></code><em> to write a function that takes a Time
object that represents the finishing time in a race, and a number
that represents the distance, and returns a Time object that represents
the average pace (time per mile).
</em><a id="hevea_default1457"></a></p></div><div class="theorem"><span class="c010">Exercise&#XA0;2</span>&#X2003;
<a id="hevea_default1458"></a>
<a id="hevea_default1459"></a><p><em>The <span class="c004">datetime</span> module provides <span class="c004">time</span> objects
that are similar to the Time objects in this chapter, but
they provide a rich set of methods and operators. Read the
documentation at </em><a href="http://docs.python.org/3/library/datetime.html"><span class="c004"><em>http://docs.python.org/3/library/datetime.html</em></span></a><em>.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Use the <span class="c004">datetime</span> module to write a program that gets the
current date and prints the day of the week.</em></li><li class="li-enumerate"><em>Write a program that takes a birthday as input and prints the
user&#X2019;s age and the number of days, hours, minutes and seconds until
their next birthday.
</em><a id="hevea_default1460"></a></li><li class="li-enumerate"><em>For two people born on different days, there is a day when one
is twice as old as the other. That&#X2019;s their Double Day. Write a
program that takes two birth dates and computes their Double Day.</em></li><li class="li-enumerate"><em>For a little more challenge, write the more general version that
computes the day when one person is </em><span class="c009">n</span><em> times older than the other.
</em><a id="hevea_default1461"></a></li></ol><p><em>Solution: </em><a href="https://thinkpython.com/code/double.py"><em><span class="c004">https://thinkpython.com/code/double.py</span></em></a></p></div>
<!--TOC chapter id="sec195" Classes and methods-->
<h1 class="chapter" id="sec195">Chapter&#XA0;17&#X2003;Classes and methods</h1><!--SEC END --><p>Although we are using some of Python&#X2019;s object-oriented features,
the programs from the last two chapters are not really
object-oriented because they don&#X2019;t represent the relationships
between programmer-defined types and the functions that operate
on them. The next step is to transform those functions into
methods that make the relationships explicit.</p><p>Code examples from this chapter are available from
<a href="https://thinkpython.com/code/Time2.py"><span class="c004">https://thinkpython.com/code/Time2.py</span></a>, and solutions
to the exercises are in <a href="https://thinkpython.com/code/Point2_soln.py"><span class="c004">https://thinkpython.com/code/Point2_soln.py</span></a>.</p>
<!--TOC section id="sec196" Object-oriented features-->
<h2 class="section" id="sec196">17.1&#X2003;Object-oriented features</h2><!--SEC END --><p>
<a id="hevea_default1462"></a></p><p>Python is an <span class="c010">object-oriented programming language</span>, which means
that it provides features that support object-oriented
programming, which has these defining characteristics:</p><ul class="itemize"><li class="li-itemize">Programs include class and method definitions.</li><li class="li-itemize">Most of the computation is expressed in terms of operations on
objects.</li><li class="li-itemize">Objects often represent things
in the real world, and methods often
correspond to the ways things in the real world interact.</li></ul><p>For example, the <span class="c004">Time</span> class defined in Chapter&#XA0;<a href="#time">16</a>
corresponds to the way people record the time of day, and the
functions we defined correspond to the kinds of things people do with
times. Similarly, the <span class="c004">Point</span> and <span class="c004">Rectangle</span> classes
in Chapter&#XA0;<a href="#clobjects">15</a>
correspond to the mathematical concepts of a point and a rectangle.</p><p>So far, we have not taken advantage of the features Python provides to
support object-oriented programming. These
features are not strictly necessary; most of them provide
alternative syntax for things we have already done. But in many cases,
the alternative is more concise and more accurately conveys the
structure of the program.</p><p>For example, in <span class="c004">Time1.py</span> there is no obvious
connection between the class definition and the function definitions
that follow. With some examination, it is apparent that every function
takes at least one <span class="c004">Time</span> object as an argument.
<a id="hevea_default1463"></a>
<a id="hevea_default1464"></a></p><p>This observation is the motivation for <span class="c010">methods</span>; a method is
a function that is associated with a particular class.
We have seen methods for strings, lists, dictionaries and tuples.
In this chapter, we will define methods for programmer-defined types.
<a id="hevea_default1465"></a>
<a id="hevea_default1466"></a>
<a id="hevea_default1467"></a>
<a id="hevea_default1468"></a></p><p>Methods are semantically the same as functions, but there are
two syntactic differences:</p><ul class="itemize"><li class="li-itemize">Methods are defined inside a class definition in order
to make the relationship between the class and the method explicit.</li><li class="li-itemize">The syntax for invoking a method is different from the
syntax for calling a function.</li></ul><p>In the next few sections, we will take the functions from the previous
two chapters and transform them into methods. This transformation is
purely mechanical; you can do it by following a sequence of
steps. If you are comfortable converting from one form to another,
you will be able to choose the best form for whatever you are doing.</p>
<!--TOC section id="sec197" Printing objects-->
<h2 class="section" id="sec197">17.2&#X2003;Printing objects</h2><!--SEC END --><p>
<a id="hevea_default1469"></a></p><p>In Chapter&#XA0;<a href="#time">16</a>, we defined a class named
<span class="c004">Time</span> and in Section&#XA0;<a href="#isafter">16.1</a>, you
wrote a function named <code class="verb">print_time</code>:</p><pre class="verbatim">class Time:
    """Represents the time of day."""

def print_time(time):
    print('%.2d:%.2d:%.2d' % (time.hour, time.minute, time.second))
</pre><p>
To call this function, you have to pass a <span class="c004">Time</span> object as an
argument:</p><pre class="verbatim">&gt;&gt;&gt; start = Time()
&gt;&gt;&gt; start.hour = 9
&gt;&gt;&gt; start.minute = 45
&gt;&gt;&gt; start.second = 00
&gt;&gt;&gt; print_time(start)
09:45:00
</pre><p>
To make <code class="verb">print_time</code> a method, all we have to do is
move the function definition inside the class definition. Notice
the change in indentation.
<a id="hevea_default1470"></a></p><pre class="verbatim">class Time:
    def print_time(time):
        print('%.2d:%.2d:%.2d' % (time.hour, time.minute, time.second))
</pre><p>
Now there are two ways to call <code class="verb">print_time</code>. The first
(and less common) way is to use function syntax:
<a id="hevea_default1471"></a>
<a id="hevea_default1472"></a></p><pre class="verbatim">&gt;&gt;&gt; Time.print_time(start)
09:45:00
</pre><p>
In this use of dot notation, <span class="c004">Time</span> is the name of the class,
and <code class="verb">print_time</code> is the name of the method. <span class="c004">start</span> is
passed as a parameter.</p><p>The second (and more concise) way is to use method syntax:
<a id="hevea_default1473"></a></p><pre class="verbatim">&gt;&gt;&gt; start.print_time()
09:45:00
</pre><p>
In this use of dot notation, <code class="verb">print_time</code> is the name of the
method (again), and <span class="c004">start</span> is the object the method is
invoked on, which is called the <span class="c010">subject</span>. Just as the
subject of a sentence is what the sentence is about, the subject
of a method invocation is what the method is about.
<a id="hevea_default1474"></a></p><p>Inside the method, the subject is assigned to the first
parameter, so in this case <span class="c004">start</span> is assigned
to <span class="c004">time</span>.
<a id="hevea_default1475"></a>
<a id="hevea_default1476"></a></p><p>By convention, the first parameter of a method is
called <span class="c004">self</span>, so it would be more common to write
<code class="verb">print_time</code> like this:</p><pre class="verbatim">class Time:
    def print_time(self):
        print('%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second))
</pre><p>
The reason for this convention is an implicit metaphor:
<a id="hevea_default1477"></a></p><ul class="itemize"><li class="li-itemize">The syntax for a function call, <code class="verb">print_time(start)</code>,
suggests that the function is the active agent. It says something
like, &#X201C;Hey <code class="verb">print_time</code>! Here&#X2019;s an object for you to print.&#X201D;</li><li class="li-itemize">In object-oriented programming, the objects are the active
agents. A method invocation like <code class="verb">start.print_time()</code> says
&#X201C;Hey <span class="c004">start</span>! Please print yourself.&#X201D;</li></ul><p>This change in perspective might be more polite, but it is not obvious
that it is useful. In the examples we have seen so far, it may not
be. But sometimes shifting responsibility from the functions onto the
objects makes it possible to write more versatile functions (or
methods), and makes it easier to maintain and reuse code.</p><p>As an exercise, rewrite <code class="verb">time_to_int</code> (from
Section&#XA0;<a href="#prototype">16.4</a>) as a method. You might be tempted to
rewrite <code class="verb">int_to_time</code> as a method, too, but that doesn&#X2019;t
really make sense because there would be no object to invoke
it on.</p>
<!--TOC section id="sec198" Another example-->
<h2 class="section" id="sec198">17.3&#X2003;Another example</h2><!--SEC END --><p>
<a id="hevea_default1478"></a></p><p>Here&#X2019;s a version of <span class="c004">increment</span> (from Section&#XA0;<a href="#increment">16.3</a>)
rewritten as a method:</p><pre class="verbatim"># inside class Time:

    def increment(self, seconds):
        seconds += self.time_to_int()
        return int_to_time(seconds)
</pre><p>
This version assumes that <code class="verb">time_to_int</code> is written
as a method. Also, note that
it is a pure function, not a modifier.</p><p>Here&#X2019;s how you would invoke <span class="c004">increment</span>:</p><pre class="verbatim">&gt;&gt;&gt; start.print_time()
09:45:00
&gt;&gt;&gt; end = start.increment(1337)
&gt;&gt;&gt; end.print_time()
10:07:17
</pre><p>
The subject, <span class="c004">start</span>, gets assigned to the first parameter,
<span class="c004">self</span>. The argument, <span class="c004">1337</span>, gets assigned to the
second parameter, <span class="c004">seconds</span>.</p><p>This mechanism can be confusing, especially if you make an error.
For example, if you invoke <span class="c004">increment</span> with two arguments, you
get:
<a id="hevea_default1479"></a>
<a id="hevea_default1480"></a></p><pre class="verbatim">&gt;&gt;&gt; end = start.increment(1337, 460)
TypeError: increment() takes 2 positional arguments but 3 were given
</pre><p>
The error message is initially confusing, because there are
only two arguments in parentheses. But the subject is also
considered an argument, so all together that&#X2019;s three.</p><p>By the way, a <span class="c010">positional argument</span> is an argument that
doesn&#X2019;t have a parameter name; that is, it is not a keyword
argument. In this function call:
<a id="hevea_default1481"></a>
<a id="hevea_default1482"></a></p><pre class="verbatim">sketch(parrot, cage, dead=True)
</pre><p><span class="c004">parrot</span> and <span class="c004">cage</span> are positional, and <span class="c004">dead</span> is
a keyword argument.</p>
<!--TOC section id="sec199" A more complicated example-->
<h2 class="section" id="sec199">17.4&#X2003;A more complicated example</h2><!--SEC END --><p>Rewriting <code class="verb">is_after</code> (from Section&#XA0;<a href="#isafter">16.1</a>) is slightly
more complicated because it takes two Time objects as parameters. In
this case it is conventional to name the first parameter <span class="c004">self</span>
and the second parameter <span class="c004">other</span>: <a id="hevea_default1483"></a>
<a id="hevea_default1484"></a></p><pre class="verbatim"># inside class Time:

    def is_after(self, other):
        return self.time_to_int() &gt; other.time_to_int()
</pre><p>
To use this method, you have to invoke it on one object and pass
the other as an argument:</p><pre class="verbatim">&gt;&gt;&gt; end.is_after(start)
True
</pre><p>
One nice thing about this syntax is that it almost reads
like English: &#X201C;end is after start?&#X201D;</p>
<!--TOC section id="sec200" The init method-->
<h2 class="section" id="sec200">17.5&#X2003;The init method</h2><!--SEC END --><p>
<a id="hevea_default1485"></a>
<a id="hevea_default1486"></a></p><p>The init method (short for &#X201C;initialization&#X201D;) is
a special method that gets invoked when an object is instantiated.
Its full name is <code class="verb">__init__</code> (two underscore characters,
followed by <span class="c004">init</span>, and then two more underscores). An
init method for the <span class="c004">Time</span> class might look like this:</p><pre class="verbatim"># inside class Time:

    def __init__(self, hour=0, minute=0, second=0):
        self.hour = hour
        self.minute = minute
        self.second = second
</pre><p>
It is common for the parameters of <code class="verb">__init__</code>
to have the same names as the attributes. The statement</p><pre class="verbatim">        self.hour = hour
</pre><p>
stores the value of the parameter <span class="c004">hour</span> as an attribute
of <span class="c004">self</span>.
<a id="hevea_default1487"></a>
<a id="hevea_default1488"></a>
<a id="hevea_default1489"></a>
<a id="hevea_default1490"></a></p><p>The parameters are optional, so if you call <span class="c004">Time</span> with
no arguments, you get the default values.</p><pre class="verbatim">&gt;&gt;&gt; time = Time()
&gt;&gt;&gt; time.print_time()
00:00:00
</pre><p>
If you provide one argument, it overrides <span class="c004">hour</span>:</p><pre class="verbatim">&gt;&gt;&gt; time = Time (9)
&gt;&gt;&gt; time.print_time()
09:00:00
</pre><p>
If you provide two arguments, they override <span class="c004">hour</span> and
<span class="c004">minute</span>.</p><pre class="verbatim">&gt;&gt;&gt; time = Time(9, 45)
&gt;&gt;&gt; time.print_time()
09:45:00
</pre><p>
And if you provide three arguments, they override all three
default values.</p><p>As an exercise, write an init method for the <span class="c004">Point</span> class that takes
<span class="c004">x</span> and <span class="c004">y</span> as optional parameters and assigns
them to the corresponding attributes.
<a id="hevea_default1491"></a>
<a id="hevea_default1492"></a></p>
<!--TOC section id="sec201" The <span class="c004">__str__</span> method-->
<h2 class="section" id="sec201">17.6&#X2003;The <span class="c004">__str__</span> method</h2><!--SEC END --><p>
<a id="hevea_default1493"></a>
<a id="hevea_default1494"></a></p><p><code class="verb">__str__</code> is a special method, like <code class="verb">__init__</code>,
that is supposed to return a string representation of an object.
<a id="hevea_default1495"></a></p><p>For example, here is a <span class="c004">str</span> method for Time objects:</p><pre class="verbatim"># inside class Time:

    def __str__(self):
        return '%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second)
</pre><p>
When you <span class="c004">print</span> an object, Python invokes the <span class="c004">str</span> method:
<a id="hevea_default1496"></a>
<a id="hevea_default1497"></a></p><pre class="verbatim">&gt;&gt;&gt; time = Time(9, 45)
&gt;&gt;&gt; print(time)
09:45:00
</pre><p>
When I write a new class, I almost always start by writing
<code class="verb">__init__</code>, which makes it easier to instantiate objects, and
<code class="verb">__str__</code>, which is useful for debugging.</p><p>As an exercise, write a <span class="c004">str</span> method for the <span class="c004">Point</span> class.
Create a Point object and print it.</p>
<!--TOC section id="sec202" Operator overloading-->
<h2 class="section" id="sec202">17.7&#X2003;Operator overloading</h2><!--SEC END --><p>
<a id="operator.overloading"></a></p><p>By defining other special methods, you can specify the behavior
of operators on programmer-defined types. For example, if you define
a method named <code class="verb">__add__</code> for the <span class="c004">Time</span> class, you can use the
<span class="c004">+</span> operator on Time objects.
<a id="hevea_default1498"></a>
<a id="hevea_default1499"></a></p><p>Here is what the definition might look like:
<a id="hevea_default1500"></a>
<a id="hevea_default1501"></a></p><pre class="verbatim"># inside class Time:

    def __add__(self, other):
        seconds = self.time_to_int() + other.time_to_int()
        return int_to_time(seconds)
</pre><p>
And here is how you could use it:</p><pre class="verbatim">&gt;&gt;&gt; start = Time(9, 45)
&gt;&gt;&gt; duration = Time(1, 35)
&gt;&gt;&gt; print(start + duration)
11:20:00
</pre><p>
When you apply the <span class="c004">+</span> operator to Time objects, Python invokes
<code class="verb">__add__</code>. When you print the result, Python invokes
<code class="verb">__str__</code>. So there is a lot happening behind the scenes!
<a id="hevea_default1502"></a></p><p>Changing the behavior of an operator so that it works with
programmer-defined types is called <span class="c010">operator overloading</span>. For every
operator in Python there is a corresponding special method, like
<code class="verb">__add__</code>. For more details, see
<a href="http://docs.python.org/3/reference/datamodel.html#specialnames"><span class="c004">http://docs.python.org/3/reference/datamodel.html#specialnames</span></a>.</p><p>As an exercise, write an <span class="c004">add</span> method for the Point class.</p>
<!--TOC section id="sec203" Type-based dispatch-->
<h2 class="section" id="sec203">17.8&#X2003;Type-based dispatch</h2><!--SEC END --><p>In the previous section we added two Time objects, but you
also might want to add an integer to a Time object. The
following is a version of <code class="verb">__add__</code>
that checks the type of <span class="c004">other</span> and invokes either
<code class="verb">add_time</code> or <span class="c004">increment</span>:</p><pre class="verbatim"># inside class Time:

    def __add__(self, other):
        if isinstance(other, Time):
            return self.add_time(other)
        else:
            return self.increment(other)

    def add_time(self, other):
        seconds = self.time_to_int() + other.time_to_int()
        return int_to_time(seconds)

    def increment(self, seconds):
        seconds += self.time_to_int()
        return int_to_time(seconds)
</pre><p>
The built-in function <span class="c004">isinstance</span> takes a value and a
class object, and returns <span class="c004">True</span> if the value is an instance
of the class.
<a id="hevea_default1503"></a>
<a id="hevea_default1504"></a></p><p>If <span class="c004">other</span> is a Time object, <code class="verb">__add__</code> invokes
<code class="verb">add_time</code>. Otherwise it assumes that the parameter
is a number and invokes <span class="c004">increment</span>. This operation is
called a <span class="c010">type-based dispatch</span> because it dispatches the
computation to different methods based on the type of the
arguments.
<a id="hevea_default1505"></a>
<a id="hevea_default1506"></a></p><p>Here are examples that use the <span class="c004">+</span> operator with different
types:</p><pre class="verbatim">&gt;&gt;&gt; start = Time(9, 45)
&gt;&gt;&gt; duration = Time(1, 35)
&gt;&gt;&gt; print(start + duration)
11:20:00
&gt;&gt;&gt; print(start + 1337)
10:07:17
</pre><p>
Unfortunately, this implementation of addition is not commutative.
If the integer is the first operand, you get
<a id="hevea_default1507"></a></p><pre class="verbatim">&gt;&gt;&gt; print(1337 + start)
TypeError: unsupported operand type(s) for +: 'int' and 'instance'
</pre><p>
The problem is, instead of asking the Time object to add an integer,
Python is asking an integer to add a Time object, and it doesn&#X2019;t know
how. But there is a clever solution for this problem: the
special method <code class="verb">__radd__</code>, which stands for &#X201C;right-side add&#X201D;.
This method is invoked when a Time object appears on the right side of
the <span class="c004">+</span> operator. Here&#X2019;s the definition:
<a id="hevea_default1508"></a>
<a id="hevea_default1509"></a></p><pre class="verbatim"># inside class Time:

    def __radd__(self, other):
        return self.__add__(other)
</pre><p>
And here&#X2019;s how it&#X2019;s used:</p><pre class="verbatim">&gt;&gt;&gt; print(1337 + start)
10:07:17
</pre><p>As an exercise, write an <span class="c004">add</span> method for Points that works with
either a Point object or a tuple:</p><ul class="itemize"><li class="li-itemize">If the second operand is a Point, the method should return a new
Point whose <span class="c009">x</span> coordinate is the sum of the <span class="c009">x</span> coordinates of the
operands, and likewise for the <span class="c009">y</span> coordinates.</li><li class="li-itemize">If the second operand is a tuple, the method should add the
first element of the tuple to the <span class="c009">x</span> coordinate and the second
element to the <span class="c009">y</span> coordinate, and return a new Point with the result.</li></ul>
<!--TOC section id="sec204" Polymorphism-->
<h2 class="section" id="sec204">17.9&#X2003;Polymorphism</h2><!--SEC END --><p>
<a id="polymorphism"></a></p><p>Type-based dispatch is useful when it is necessary, but (fortunately)
it is not always necessary. Often you can avoid it by writing functions
that work correctly for arguments with different types.
<a id="hevea_default1510"></a>
<a id="hevea_default1511"></a></p><p>Many of the functions we wrote for strings also
work for other sequence types.
For example, in Section&#XA0;<a href="#histogram">11.2</a>
we used <span class="c004">histogram</span> to count the number of times each letter
appears in a word.</p><pre class="verbatim">def histogram(s):
    d = dict()
    for c in s:
        if c not in d:
            d[c] = 1
        else:
            d[c] = d[c]+1
    return d
</pre><p>
This function also works for lists, tuples, and even dictionaries,
as long as the elements of <span class="c004">s</span> are hashable, so they can be used
as keys in <span class="c004">d</span>.</p><pre class="verbatim">&gt;&gt;&gt; t = ['spam', 'egg', 'spam', 'spam', 'bacon', 'spam']
&gt;&gt;&gt; histogram(t)
{'bacon': 1, 'egg': 1, 'spam': 4}
</pre><p>
Functions that work with several types are called <span class="c010">polymorphic</span>.
Polymorphism can facilitate code reuse. For example, the built-in
function <span class="c004">sum</span>, which adds the elements of a sequence, works
as long as the elements of the sequence support addition.
<a id="hevea_default1512"></a></p><p>Since Time objects provide an <span class="c004">add</span> method, they work
with <span class="c004">sum</span>:</p><pre class="verbatim">&gt;&gt;&gt; t1 = Time(7, 43)
&gt;&gt;&gt; t2 = Time(7, 41)
&gt;&gt;&gt; t3 = Time(7, 37)
&gt;&gt;&gt; total = sum([t1, t2, t3])
&gt;&gt;&gt; print(total)
23:01:00
</pre><p>
In general, if all of the operations inside a function
work with a given type, the function works with that type.</p><p>The best kind of polymorphism is the unintentional kind, where
you discover that a function you already wrote can be
applied to a type you never planned for.</p>
<!--TOC section id="sec205" Debugging-->
<h2 class="section" id="sec205">17.10&#X2003;Debugging</h2><!--SEC END --><p>
<a id="hevea_default1513"></a></p><p>It is legal to add attributes to objects at any point in the execution
of a program, but if you have objects with the same type that don&#X2019;t
have the same attributes, it is easy to make mistakes.
It is considered a good idea to
initialize all of an object&#X2019;s attributes in the init method.
<a id="hevea_default1514"></a>
<a id="hevea_default1515"></a></p><p>If you are not sure whether an object has a particular attribute, you
can use the built-in function <span class="c004">hasattr</span> (see Section&#XA0;<a href="#hasattr">15.7</a>).
<a id="hevea_default1516"></a>
<a id="hevea_default1517"></a>
<a id="hevea_default1518"></a>
<a id="hevea_default1519"></a></p><p>Another way to access attributes is the built-in function <span class="c004">vars</span>,
which takes an object and returns a dictionary that maps from
attribute names (as strings) to their values:</p><pre class="verbatim">&gt;&gt;&gt; p = Point(3, 4)
&gt;&gt;&gt; vars(p)
{'y': 4, 'x': 3}
</pre><p>
For purposes of debugging, you might find it useful to keep this
function handy:</p><pre class="verbatim">def print_attributes(obj):
    for attr in vars(obj):
        print(attr, getattr(obj, attr))
</pre><p>
<code class="verb">print_attributes</code> traverses the dictionary
and prints each attribute name and its corresponding value.
<a id="hevea_default1520"></a>
<a id="hevea_default1521"></a></p><p>The built-in function <span class="c004">getattr</span> takes an object and an attribute
name (as a string) and returns the attribute&#X2019;s value.
<a id="hevea_default1522"></a>
<a id="hevea_default1523"></a></p>
<!--TOC section id="sec206" Interface and implementation-->
<h2 class="section" id="sec206">17.11&#X2003;Interface and implementation</h2><!--SEC END --><p>One of the goals of object-oriented design is to make software more
maintainable, which means that you can keep the program working when
other parts of the system change, and modify the program to meet new
requirements.
<a id="hevea_default1524"></a>
<a id="hevea_default1525"></a>
<a id="hevea_default1526"></a>
<a id="hevea_default1527"></a></p><p>A design principle that helps achieve that goal is to keep
interfaces separate from implementations. For objects, that means
that the methods a class provides should not depend on how the
attributes are represented.
<a id="hevea_default1528"></a></p><p>For example, in this chapter we developed a class that represents
a time of day. Methods provided by this class include
<code class="verb">time_to_int</code>, <code class="verb">is_after</code>, and <code class="verb">add_time</code>.</p><p>We could implement those methods in several ways. The details of the
implementation depend on how we represent time. In this chapter, the
attributes of a <span class="c004">Time</span> object are <span class="c004">hour</span>, <span class="c004">minute</span>, and
<span class="c004">second</span>.</p><p>As an alternative, we could replace these attributes with
a single integer representing the number of seconds
since midnight. This implementation would make some methods,
like <code class="verb">is_after</code>, easier to write, but it makes other methods
harder.</p><p>After you deploy a new class, you might discover a better
implementation. If other parts of the program are using your
class, it might be time-consuming and error-prone to change the
interface.</p><p>But if you designed the interface carefully, you can
change the implementation without changing the interface, which
means that other parts of the program don&#X2019;t have to change.</p>
<!--TOC section id="sec207" Glossary-->
<h2 class="section" id="sec207">17.12&#X2003;Glossary</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c010">object-oriented language:</span></dt><dd class="dd-description"> A language that provides features,
such as programmer-defined types and methods, that facilitate
object-oriented programming.
<a id="hevea_default1529"></a></dd><dt class="dt-description"><span class="c010">object-oriented programming:</span></dt><dd class="dd-description"> A style of programming in which
data and the operations that manipulate it are organized into classes
and methods.
<a id="hevea_default1530"></a></dd><dt class="dt-description"><span class="c010">method:</span></dt><dd class="dd-description"> A function that is defined inside a class definition and
is invoked on instances of that class.
<a id="hevea_default1531"></a></dd><dt class="dt-description"><span class="c010">subject:</span></dt><dd class="dd-description"> The object a method is invoked on.
<a id="hevea_default1532"></a></dd><dt class="dt-description"><span class="c010">positional argument:</span></dt><dd class="dd-description"> An argument that does not include
a parameter name, so it is not a keyword argument.
<a id="hevea_default1533"></a>
<a id="hevea_default1534"></a></dd><dt class="dt-description"><span class="c010">operator overloading:</span></dt><dd class="dd-description"> Changing the behavior of an operator like
<span class="c004">+</span> so it works with a programmer-defined type.
<a id="hevea_default1535"></a>
<a id="hevea_default1536"></a></dd><dt class="dt-description"><span class="c010">type-based dispatch:</span></dt><dd class="dd-description"> A programming pattern that checks the type
of an operand and invokes different functions for different types.
<a id="hevea_default1537"></a></dd><dt class="dt-description"><span class="c010">polymorphic:</span></dt><dd class="dd-description"> Pertaining to a function that can work with more
than one type.
<a id="hevea_default1538"></a></dd></dl>
<!--TOC section id="sec208" Exercises-->
<h2 class="section" id="sec208">17.13&#X2003;Exercises</h2><!--SEC END --><div class="theorem"><span class="c010">Exercise&#XA0;1</span>&#X2003;<p><em>Download the code from this chapter from
</em><a href="https://thinkpython.com/code/Time2.py"><span class="c004"><em>https://thinkpython.com/code/Time2.py</em></span></a><em>. Change the attributes of
<span class="c004">Time</span> to be a single integer representing seconds since
midnight. Then modify the methods (and the function
</em><code class="verb"><em>int_to_time</em></code><em>) to work with the new implementation. You
should not have to modify the test code in <span class="c004">main</span>. When you
are done, the output should be the same as before. Solution:
</em><a href="https://thinkpython.com/code/Time2_soln.py"><span class="c004"><em>https://thinkpython.com/code/Time2_soln.py</em></span></a><em>.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;2</span>&#X2003;
<a id="kangaroo"></a>
<a id="hevea_default1539"></a>
<a id="hevea_default1540"></a>
<a id="hevea_default1541"></a>
<a id="hevea_default1542"></a>
<a id="hevea_default1543"></a>
<a id="hevea_default1544"></a><p><em>This exercise is a cautionary tale about one of the most
common, and difficult to find, errors in Python.
Write a definition for a class named <span class="c004">Kangaroo</span> with the following
methods:</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>An </em><code class="verb"><em>__init__</em></code><em> method that initializes an attribute named
</em><code class="verb"><em>pouch_contents</em></code><em> to an empty list.</em></li><li class="li-enumerate"><em>A method named </em><code class="verb"><em>put_in_pouch</em></code><em> that takes an object
of any type and adds it to </em><code class="verb"><em>pouch_contents</em></code><em>.</em></li><li class="li-enumerate"><em>A </em><code class="verb"><em>__str__</em></code><em> method that returns a string representation
of the Kangaroo object and the contents of the pouch.</em></li></ol><p><em>
Test your code
by creating two <span class="c004">Kangaroo</span> objects, assigning them to variables
named <span class="c004">kanga</span> and <span class="c004">roo</span>, and then adding <span class="c004">roo</span> to the
contents of <span class="c004">kanga</span>&#X2019;s pouch.</em></p><p><em>Download </em><a href="https://thinkpython.com/code/BadKangaroo.py"><em><span class="c004">https://thinkpython.com/code/BadKangaroo.py</span></em></a><em>. It contains
a solution to the previous problem with one big, nasty bug.
Find and fix the bug.</em></p><p><em>If you get stuck, you can download
</em><a href="https://thinkpython.com/code/GoodKangaroo.py"><span class="c004"><em>https://thinkpython.com/code/GoodKangaroo.py</em></span></a><em>, which explains the
problem and demonstrates a solution.
</em><a id="hevea_default1545"></a>
<a id="hevea_default1546"></a>
<a id="hevea_default1547"></a></p></div>
<!--TOC chapter id="sec209" Inheritance-->
<h1 class="chapter" id="sec209">Chapter&#XA0;18&#X2003;Inheritance</h1><!--SEC END --><p>The language feature most often associated with object-oriented
programming is <span class="c010">inheritance</span>. Inheritance is the ability to
define a new class that is a modified version of an existing class.
In this chapter I demonstrate inheritance using classes that represent
playing cards, decks of cards, and poker hands.
<a id="hevea_default1548"></a>
<a id="hevea_default1549"></a>
<a id="hevea_default1550"></a></p><p>If you don&#X2019;t play
poker, you can read about it at
<a href="http://en.wikipedia.org/wiki/Poker"><span class="c004">http://en.wikipedia.org/wiki/Poker</span></a>, but you don&#X2019;t have to; I&#X2019;ll
tell you what you need to know for the exercises.</p><p>Code examples from
this chapter are available from
<a href="https://thinkpython.com/code/Card.py"><span class="c004">https://thinkpython.com/code/Card.py</span></a>.</p>
<!--TOC section id="sec210" Card objects-->
<h2 class="section" id="sec210">18.1&#X2003;Card objects</h2><!--SEC END --><p>There are fifty-two cards in a deck, each of which belongs to one of
four suits and one of thirteen ranks. The suits are Spades, Hearts,
Diamonds, and Clubs (in descending order in bridge). The ranks are
Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, and King. Depending on
the game that you are playing, an Ace may be higher than King
or lower than 2.
<a id="hevea_default1551"></a>
<a id="hevea_default1552"></a></p><p>If we want to define a new object to represent a playing card, it is
obvious what the attributes should be: <span class="c004">rank</span> and
<span class="c004">suit</span>. It is not as obvious what type the attributes
should be. One possibility is to use strings containing words like
<code class="verb">'Spade'</code> for suits and <code class="verb">'Queen'</code> for ranks. One problem with
this implementation is that it would not be easy to compare cards to
see which had a higher rank or suit.
<a id="hevea_default1553"></a>
<a id="hevea_default1554"></a>
<a id="hevea_default1555"></a>
<a id="hevea_default1556"></a></p><p>An alternative is to use integers to <span class="c010">encode</span> the ranks and suits.
In this context, &#X201C;encode&#X201D; means that we are going to define a mapping
between numbers and suits, or between numbers and ranks. This
kind of encoding is not meant to be a secret (that
would be &#X201C;encryption&#X201D;).</p><p>For example, this table shows the suits and the corresponding integer
codes:</p><table class="c001 cellpading0"><tr><td class="c013">Spades</td><td class="c012">&#X21A6;</td><td class="c013">3 </td></tr>
<tr><td class="c013">Hearts</td><td class="c012">&#X21A6;</td><td class="c013">2 </td></tr>
<tr><td class="c013">Diamonds</td><td class="c012">&#X21A6;</td><td class="c013">1 </td></tr>
<tr><td class="c013">Clubs</td><td class="c012">&#X21A6;</td><td class="c013">0
</td></tr>
</table><p>This code makes it easy to compare cards; because higher suits map to
higher numbers, we can compare suits by comparing their codes.</p><p>The mapping for ranks is fairly obvious; each of the numerical ranks
maps to the corresponding integer, and for face cards:</p><table class="c001 cellpading0"><tr><td class="c013">Jack</td><td class="c012">&#X21A6;</td><td class="c013">11 </td></tr>
<tr><td class="c013">Queen</td><td class="c012">&#X21A6;</td><td class="c013">12 </td></tr>
<tr><td class="c013">King</td><td class="c012">&#X21A6;</td><td class="c013">13 </td></tr>
</table><p>I am using the &#X21A6;&#XA0;symbol to make it clear that these mappings
are not part of the Python program. They are part of the program
design, but they don&#X2019;t appear explicitly in the code.
<a id="hevea_default1557"></a>
<a id="hevea_default1558"></a></p><p>The class definition for <span class="c004">Card</span> looks like this:</p><pre class="verbatim">class Card:
    """Represents a standard playing card."""

    def __init__(self, suit=0, rank=2):
        self.suit = suit
        self.rank = rank
</pre><p>
As usual, the init method takes an optional
parameter for each attribute. The default card is
the 2 of Clubs.
<a id="hevea_default1559"></a>
<a id="hevea_default1560"></a></p><p>To create a Card, you call <span class="c004">Card</span> with the
suit and rank of the card you want.</p><pre class="verbatim">queen_of_diamonds = Card(1, 12)
</pre>
<!--TOC section id="sec211" Class attributes-->
<h2 class="section" id="sec211">18.2&#X2003;Class attributes</h2><!--SEC END --><p>
<a id="class.attribute"></a>
<a id="hevea_default1561"></a>
<a id="hevea_default1562"></a></p><p>In order to print Card objects in a way that people can easily
read, we need a mapping from the integer codes to the corresponding
ranks and suits. A natural way to
do that is with lists of strings. We assign these lists to <span class="c010">class
attributes</span>:</p><pre class="verbatim"># inside class Card:

    suit_names = ['Clubs', 'Diamonds', 'Hearts', 'Spades']
    rank_names = [None, 'Ace', '2', '3', '4', '5', '6', '7',
              '8', '9', '10', 'Jack', 'Queen', 'King']

    def __str__(self):
        return '%s of %s' % (Card.rank_names[self.rank],
                             Card.suit_names[self.suit])
</pre><p>
Variables like <code class="verb">suit_names</code> and <code class="verb">rank_names</code>, which are
defined inside a class but outside of any method, are called
class attributes because they are associated with the class object
<span class="c004">Card</span>.
<a id="hevea_default1563"></a>
<a id="hevea_default1564"></a></p><p>This term distinguishes them from variables like <span class="c004">suit</span> and <span class="c004">rank</span>, which are called <span class="c010">instance attributes</span> because they are
associated with a particular instance.
<a id="hevea_default1565"></a></p><p>Both kinds of attribute are accessed using dot notation. For
example, in <code class="verb">__str__</code>, <span class="c004">self</span> is a Card object,
and <span class="c004">self.rank</span> is its rank. Similarly, <span class="c004">Card</span>
is a class object, and <code class="verb">Card.rank_names</code> is a
list of strings associated with the class.</p><p>Every card has its own <span class="c004">suit</span> and <span class="c004">rank</span>, but there
is only one copy of <code class="verb">suit_names</code> and <code class="verb">rank_names</code>.</p><p>Putting it all together, the expression
<code class="verb">Card.rank_names[self.rank]</code> means &#X201C;use the attribute <span class="c004">rank</span>
from the object <span class="c004">self</span> as an index into the list <code class="verb">rank_names</code>
from the class <span class="c004">Card</span>, and select the appropriate string.&#X201D;</p><p>The first element of <code class="verb">rank_names</code> is <span class="c004">None</span> because there
is no card with rank zero. By including <span class="c004">None</span> as a place-keeper,
we get a mapping with the nice property that the index 2 maps to the
string <code class="verb">'2'</code>, and so on. To avoid this tweak, we could have
used a dictionary instead of a list.</p><p>With the methods we have so far, we can create and print cards:</p><pre class="verbatim">&gt;&gt;&gt; card1 = Card(2, 11)
&gt;&gt;&gt; print(card1)
Jack of Hearts
</pre><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2024.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 18.1: Object diagram.</td></tr>
</table></div>
<a id="fig.card1"></a>
<div class="center"><hr class="floatrule"></div></blockquote><p>Figure&#XA0;<a href="#fig.card1">18.1</a> is a diagram of the <span class="c004">Card</span> class object and
one Card instance. <span class="c004">Card</span> is a class object; its type is <span class="c004">type</span>. <span class="c004">card1</span> is an instance of <span class="c004">Card</span>, so its type is
<span class="c004">Card</span>. To save space, I didn&#X2019;t draw the contents of
<code class="verb">suit_names</code> and <code class="verb">rank_names</code>. <a id="hevea_default1566"></a>
<a id="hevea_default1567"></a> <a id="hevea_default1568"></a> <a id="hevea_default1569"></a></p>
<!--TOC section id="sec212" Comparing cards-->
<h2 class="section" id="sec212">18.3&#X2003;Comparing cards</h2><!--SEC END --><p>
<a id="comparecard"></a>
<a id="hevea_default1570"></a>
<a id="hevea_default1571"></a></p><p>For built-in types, there are relational operators
(<span class="c004">&lt;</span>, <span class="c004">&gt;</span>, <span class="c004">==</span>, etc.)
that compare
values and determine when one is greater than, less than, or equal to
another. For programmer-defined types, we can override the behavior of
the built-in operators by providing a method named
<code class="verb">__lt__</code>, which stands for &#X201C;less than&#X201D;.
<a id="hevea_default1572"></a>
<a id="hevea_default1573"></a></p><p><code class="verb">__lt__</code> takes two parameters, <span class="c004">self</span> and <span class="c004">other</span>,
and returns <span class="c004">True</span> if <span class="c004">self</span> is strictly less than <span class="c004">other</span>.
<a id="hevea_default1574"></a>
<a id="hevea_default1575"></a></p><p>The correct ordering for cards is not obvious.
For example, which
is better, the 3 of Clubs or the 2 of Diamonds? One has a higher
rank, but the other has a higher suit. In order to compare
cards, you have to decide whether rank or suit is more important.</p><p>The answer might depend on what game you are playing, but to keep
things simple, we&#X2019;ll make the arbitrary choice that suit is more
important, so all of the Spades outrank all of the Diamonds,
and so on.
<a id="hevea_default1576"></a>
<a id="hevea_default1577"></a></p><p>With that decided, we can write <code class="verb">__lt__</code>:</p><pre class="verbatim"># inside class Card:

    def __lt__(self, other):
        # check the suits
        if self.suit &lt; other.suit: return True
        if self.suit &gt; other.suit: return False

        # suits are the same... check ranks
        return self.rank &lt; other.rank
</pre><p>
You can write this more concisely using tuple comparison:
<a id="hevea_default1578"></a>
<a id="hevea_default1579"></a></p><pre class="verbatim"># inside class Card:

    def __lt__(self, other):
        t1 = self.suit, self.rank
        t2 = other.suit, other.rank
        return t1 &lt; t2
</pre><p>
As an exercise, write an <code class="verb">__lt__</code> method for Time objects. You
can use tuple comparison, but you also might consider
comparing integers.</p>
<!--TOC section id="sec213" Decks-->
<h2 class="section" id="sec213">18.4&#X2003;Decks</h2><!--SEC END --><p>
<a id="hevea_default1580"></a>
<a id="hevea_default1581"></a></p><p>Now that we have Cards, the next step is to define Decks. Since a
deck is made up of cards, it is natural for each Deck to contain a
list of cards as an attribute.
<a id="hevea_default1582"></a>
<a id="hevea_default1583"></a></p><p>The following is a class definition for <span class="c004">Deck</span>. The
init method creates the attribute <span class="c004">cards</span> and generates
the standard set of fifty-two cards:
<a id="hevea_default1584"></a>
<a id="hevea_default1585"></a>
<a id="hevea_default1586"></a>
<a id="hevea_default1587"></a></p><pre class="verbatim">class Deck:

    def __init__(self):
        self.cards = []
        for suit in range(4):
            for rank in range(1, 14):
                card = Card(suit, rank)
                self.cards.append(card)
</pre><p>
The easiest way to populate the deck is with a nested loop. The outer
loop enumerates the suits from 0 to 3. The inner loop enumerates the
ranks from 1 to 13. Each iteration
creates a new Card with the current suit and rank,
and appends it to <span class="c004">self.cards</span>.
<a id="hevea_default1588"></a>
<a id="hevea_default1589"></a></p>
<!--TOC section id="sec214" Printing the deck-->
<h2 class="section" id="sec214">18.5&#X2003;Printing the deck</h2><!--SEC END --><p>
<a id="printdeck"></a>
<a id="hevea_default1590"></a>
<a id="hevea_default1591"></a></p><p>Here is a <code class="verb">__str__</code> method for <span class="c004">Deck</span>:</p><pre class="verbatim"># inside class Deck:

    def __str__(self):
        res = []
        for card in self.cards:
            res.append(str(card))
        return '\n'.join(res)
</pre><p>
This method demonstrates an efficient way to accumulate a large
string: building a list of strings and then using the string method
<span class="c004">join</span>. The built-in function <span class="c004">str</span> invokes the
<code class="verb">__str__</code> method on each card and returns the string
representation. <a id="hevea_default1592"></a> <a id="hevea_default1593"></a>
<a id="hevea_default1594"></a> <a id="hevea_default1595"></a> <a id="hevea_default1596"></a></p><p>Since we invoke <span class="c004">join</span> on a newline character, the cards
are separated by newlines. Here&#X2019;s what the result looks like:</p><pre class="verbatim">&gt;&gt;&gt; deck = Deck()
&gt;&gt;&gt; print(deck)
Ace of Clubs
2 of Clubs
3 of Clubs
...
10 of Spades
Jack of Spades
Queen of Spades
King of Spades
</pre><p>
Even though the result appears on 52 lines, it is
one long string that contains newlines.</p>
<!--TOC section id="sec215" Add, remove, shuffle and sort-->
<h2 class="section" id="sec215">18.6&#X2003;Add, remove, shuffle and sort</h2><!--SEC END --><p>To deal cards, we would like a method that
removes a card from the deck and returns it.
The list method <span class="c004">pop</span> provides a convenient way to do that:
<a id="hevea_default1597"></a>
<a id="hevea_default1598"></a></p><pre class="verbatim"># inside class Deck:

    def pop_card(self):
        return self.cards.pop()
</pre><p>
Since <span class="c004">pop</span> removes the <em>last</em> card in the list, we are
dealing from the bottom of the deck.
<a id="hevea_default1599"></a>
<a id="hevea_default1600"></a></p><p>To add a card, we can use the list method <span class="c004">append</span>:</p><pre class="verbatim"># inside class Deck:

    def add_card(self, card):
        self.cards.append(card)
</pre><p>
A method like this that uses another method without doing
much work is sometimes called a <span class="c010">veneer</span>. The metaphor
comes from woodworking, where a veneer is a thin
layer of good quality wood glued to the surface of a cheaper piece of
wood to improve the appearance.
<a id="hevea_default1601"></a></p><p>In this case <code class="verb">add_card</code> is a &#X201C;thin&#X201D; method that expresses
a list operation in terms appropriate for decks. It
improves the appearance, or interface, of the
implementation.</p><p>As another example, we can write a Deck method named <span class="c004">shuffle</span>
using the function <span class="c004">shuffle</span> from the <span class="c004">random</span> module:
<a id="hevea_default1602"></a>
<a id="hevea_default1603"></a>
<a id="hevea_default1604"></a>
<a id="hevea_default1605"></a></p><pre class="verbatim"># inside class Deck:

    def shuffle(self):
        random.shuffle(self.cards)
</pre><p>
Don&#X2019;t forget to import <span class="c004">random</span>.</p><p>As an exercise, write a Deck method named <span class="c004">sort</span> that uses the
list method <span class="c004">sort</span> to sort the cards in a <span class="c004">Deck</span>. <span class="c004">sort</span>
uses the <code class="verb">__lt__</code> method we defined to determine the order.
<a id="hevea_default1606"></a> <a id="hevea_default1607"></a></p>
<!--TOC section id="sec216" Inheritance-->
<h2 class="section" id="sec216">18.7&#X2003;Inheritance</h2><!--SEC END --><p>
<a id="hevea_default1608"></a>
<a id="hevea_default1609"></a></p><p>Inheritance is the ability to define a new class that is a modified
version of an existing class. As an example, let&#X2019;s say we want a
class to represent a &#X201C;hand&#X201D;, that is, the cards held by one player.
A hand is similar to a deck: both are made up of a collection of
cards, and both require operations like adding and removing cards.</p><p>A hand is also different from a deck; there are operations we want for
hands that don&#X2019;t make sense for a deck. For example, in poker we
might compare two hands to see which one wins. In bridge, we might
compute a score for a hand in order to make a bid.</p><p>This relationship between classes&#X2014;similar, but different&#X2014;lends
itself to inheritance.
To define a new class that inherits from an existing class,
you put the name of the existing class in parentheses:
<a id="hevea_default1610"></a>
<a id="hevea_default1611"></a>
<a id="hevea_default1612"></a>
<a id="hevea_default1613"></a>
<a id="hevea_default1614"></a></p><pre class="verbatim">class Hand(Deck):
    """Represents a hand of playing cards."""
</pre><p>
This definition indicates that <span class="c004">Hand</span> inherits from <span class="c004">Deck</span>;
that means we can use methods like <code class="verb">pop_card</code> and <code class="verb">add_card</code>
for Hands as well as Decks.</p><p>When a new class inherits from an existing one, the existing
one is called the <span class="c010">parent</span> and the new class is
called the <span class="c010">child</span>.
<a id="hevea_default1615"></a>
<a id="hevea_default1616"></a>
<a id="hevea_default1617"></a></p><p>In this example, <span class="c004">Hand</span> inherits <code class="verb">__init__</code> from <span class="c004">Deck</span>,
but it doesn&#X2019;t really do what we want: instead of populating the hand
with 52 new cards, the init method for Hands should initialize <span class="c004">cards</span> with an empty list. <a id="hevea_default1618"></a> <a id="hevea_default1619"></a>
<a id="hevea_default1620"></a></p><p>If we provide an init method in the <span class="c004">Hand</span> class, it overrides the
one in the <span class="c004">Deck</span> class:</p><pre class="verbatim"># inside class Hand:

    def __init__(self, label=''):
        self.cards = []
        self.label = label
</pre><p>
When you create a Hand, Python invokes this init method, not the
one in <span class="c004">Deck</span>.</p><pre class="verbatim">&gt;&gt;&gt; hand = Hand('new hand')
&gt;&gt;&gt; hand.cards
[]
&gt;&gt;&gt; hand.label
'new hand'
</pre><p>
The other methods are inherited from <span class="c004">Deck</span>, so we can use
<code class="verb">pop_card</code> and <code class="verb">add_card</code> to deal a card:</p><pre class="verbatim">&gt;&gt;&gt; deck = Deck()
&gt;&gt;&gt; card = deck.pop_card()
&gt;&gt;&gt; hand.add_card(card)
&gt;&gt;&gt; print(hand)
King of Spades
</pre><p>
A natural next step is to encapsulate this code in a method
called <code class="verb">move_cards</code>:
<a id="hevea_default1621"></a></p><pre class="verbatim"># inside class Deck:

    def move_cards(self, hand, num):
        for i in range(num):
            hand.add_card(self.pop_card())
</pre><p>
<code class="verb">move_cards</code> takes two arguments, a Hand object and the number of
cards to deal. It modifies both <span class="c004">self</span> and <span class="c004">hand</span>, and
returns <span class="c004">None</span>.</p><p>In some games, cards are moved from one hand to another,
or from a hand back to the deck. You can use <code class="verb">move_cards</code>
for any of these operations: <span class="c004">self</span> can be either a Deck
or a Hand, and <span class="c004">hand</span>, despite the name, can also be a <span class="c004">Deck</span>.</p><p>Inheritance is a useful feature. Some programs that would be
repetitive without inheritance can be written more elegantly
with it. Inheritance can facilitate code reuse, since you can
customize the behavior of parent classes without having to modify
them. In some cases, the inheritance structure reflects the natural
structure of the problem, which makes the design easier to
understand.</p><p>On the other hand, inheritance can make programs difficult to read.
When a method is invoked, it is sometimes not clear where to find its
definition. The relevant code may be spread across several modules.
Also, many of the things that can be done using inheritance can be
done as well or better without it.</p>
<!--TOC section id="sec217" Class diagrams-->
<h2 class="section" id="sec217">18.8&#X2003;Class diagrams</h2><!--SEC END --><p>
<a id="class.diagram"></a></p><p>So far we have seen stack diagrams, which show the state of
a program, and object diagrams, which show the attributes
of an object and their values. These diagrams represent a snapshot
in the execution of a program, so they change as the program
runs.</p><p>They are also highly detailed; for some purposes, too
detailed. A class diagram is a more abstract representation
of the structure of a program. Instead of showing individual
objects, it shows classes and the relationships between them.</p><p>There are several kinds of relationship between classes:</p><ul class="itemize"><li class="li-itemize">Objects in one class might contain references to objects
in another class. For example, each Rectangle contains a reference
to a Point, and each Deck contains references to many Cards.
This kind of relationship is called <span class="c010">HAS-A</span>, as in, &#X201C;a Rectangle
has a Point.&#X201D;</li><li class="li-itemize">One class might inherit from another. This relationship
is called <span class="c010">IS-A</span>, as in, &#X201C;a Hand is a kind of a Deck.&#X201D;</li><li class="li-itemize">One class might depend on another in the sense that objects
in one class take objects in the second class as parameters, or
use objects in the second class as part of a computation. This
kind of relationship is called a <span class="c010">dependency</span>.</li></ul><p>
<a id="hevea_default1622"></a>
<a id="hevea_default1623"></a>
<a id="hevea_default1624"></a>
<a id="hevea_default1625"></a></p><p>A <span class="c010">class diagram</span> is a graphical representation of these
relationships. For example, Figure&#XA0;<a href="#fig.class1">18.2</a> shows the
relationships between <span class="c004">Card</span>, <span class="c004">Deck</span> and <span class="c004">Hand</span>.</p><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2025.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 18.2: Class diagram.</td></tr>
</table></div>
<a id="fig.class1"></a>
<div class="center"><hr class="floatrule"></div></blockquote><p>The arrow with a hollow triangle head represents an IS-A
relationship; in this case it indicates that Hand inherits
from Deck.</p><p>The standard arrow head represents a HAS-A
relationship; in this case a Deck has references to Card
objects.
<a id="hevea_default1626"></a></p><p>The star (<span class="c004">*</span>) near the arrow head is a
<span class="c010">multiplicity</span>; it indicates how many Cards a Deck has.
A multiplicity can be a simple number, like <span class="c004">52</span>, a range,
like <span class="c004">5..7</span> or a star, which indicates that a Deck can
have any number of Cards.</p><p>There are no dependencies in this diagram. They would normally
be shown with a dashed arrow. Or if there are a lot of
dependencies, they are sometimes omitted.</p><p>A more detailed diagram might show that a Deck actually
contains a <em>list</em> of Cards, but built-in types
like list and dict are usually not included in class diagrams.</p>
<!--TOC section id="sec218" Debugging-->
<h2 class="section" id="sec218">18.9&#X2003;Debugging</h2><!--SEC END --><p>
<a id="hevea_default1627"></a></p><p>Inheritance can make debugging difficult because when you invoke a
method on an object, it might be hard to figure out which method will
be invoked.
<a id="hevea_default1628"></a></p><p>Suppose you are writing a function that works with Hand objects.
You would like it to work with all kinds of Hands, like
PokerHands, BridgeHands, etc. If you invoke a method like
<span class="c004">shuffle</span>, you might get the one defined in <span class="c004">Deck</span>,
but if any of the subclasses override this method, you&#X2019;ll
get that version instead. This behavior is usually a good
thing, but it can be confusing.</p><p>Any time you are unsure about the flow of execution through your
program, the simplest solution is to add print statements at the
beginning of the relevant methods. If <span class="c004">Deck.shuffle</span> prints a
message that says something like <span class="c004">Running Deck.shuffle</span>, then as
the program runs it traces the flow of execution.
<a id="hevea_default1629"></a></p><p>As an alternative, you could use this function, which takes an
object and a method name (as a string) and returns the class that
provides the definition of the method:</p><pre class="verbatim">def find_defining_class(obj, meth_name):
    for ty in type(obj).mro():
        if meth_name in ty.__dict__:
            return ty
</pre><p>
Here&#X2019;s an example:</p><pre class="verbatim">&gt;&gt;&gt; hand = Hand()
&gt;&gt;&gt; find_defining_class(hand, 'shuffle')
&lt;class '__main__.Deck'&gt;
</pre><p>
So the <span class="c004">shuffle</span> method for this Hand is the one in <span class="c004">Deck</span>.
<a id="hevea_default1630"></a>
<a id="hevea_default1631"></a>
<a id="hevea_default1632"></a></p><p><code class="verb">find_defining_class</code> uses the <span class="c004">mro</span> method to get the list
of class objects (types) that will be searched for methods. &#X201C;MRO&#X201D;
stands for &#X201C;method resolution order&#X201D;, which is the sequence of
classes Python searches to &#X201C;resolve&#X201D; a method name.</p><p>Here&#X2019;s a design suggestion: when you override a method,
the interface of the new method should be the same as the old. It
should take the same parameters, return the same type, and obey the
same preconditions and postconditions. If you follow this rule, you
will find that any function designed to work with an instance of a
parent class, like a Deck, will also work with instances of child
classes like a Hand and PokerHand.
<a id="hevea_default1633"></a>
<a id="hevea_default1634"></a>
<a id="hevea_default1635"></a>
<a id="hevea_default1636"></a></p><p>If you violate this rule, which is called the &#X201C;Liskov substitution
principle&#X201D;, your code will collapse like (sorry) a house of cards.
<a id="hevea_default1637"></a></p>
<!--TOC section id="sec219" Data encapsulation-->
<h2 class="section" id="sec219">18.10&#X2003;Data encapsulation</h2><!--SEC END --><p>The previous chapters demonstrate a development plan we might call
&#X201C;object-oriented design&#X201D;. We identified objects we needed&#X2014;like
<span class="c004">Point</span>, <span class="c004">Rectangle</span> and <span class="c004">Time</span>&#X2014;and defined classes to
represent them. In each case there is an obvious correspondence
between the object and some entity in the real world (or at least a
mathematical world).
<a id="hevea_default1638"></a></p><p>But sometimes it is less obvious what objects you need
and how they should interact. In that case you need a different
development plan. In the same way that we discovered function
interfaces by encapsulation and generalization, we can discover
class interfaces by <span class="c010">data encapsulation</span>.
<a id="hevea_default1639"></a></p><p>Markov analysis, from Section&#XA0;<a href="#markov">13.8</a>, provides a good example.
If you download my code from <a href="https://thinkpython.com/code/markov.py"><span class="c004">https://thinkpython.com/code/markov.py</span></a>,
you&#X2019;ll see that it uses two global variables&#X2014;<code class="verb">suffix_map</code> and
<code class="verb">prefix</code>&#X2014;that are read and written from several functions.</p><pre class="verbatim">suffix_map = {}
prefix = ()
</pre><p>Because these variables are global, we can only run one analysis at a
time. If we read two texts, their prefixes and suffixes would be
added to the same data structures (which makes for some interesting
generated text).</p><p>To run multiple analyses, and keep them separate, we can encapsulate
the state of each analysis in an object.
Here&#X2019;s what that looks like:</p><pre class="verbatim">class Markov:

    def __init__(self):
        self.suffix_map = {}
        self.prefix = ()
</pre><p>Next, we transform the functions into methods. For example,
here&#X2019;s <code class="verb">process_word</code>:</p><pre class="verbatim">    def process_word(self, word, order=2):
        if len(self.prefix) &lt; order:
            self.prefix += (word,)
            return

        try:
            self.suffix_map[self.prefix].append(word)
        except KeyError:
            # if there is no entry for this prefix, make one
            self.suffix_map[self.prefix] = [word]

        self.prefix = shift(self.prefix, word)
</pre><p>Transforming a program like this&#X2014;changing the design without
changing the behavior&#X2014;is another example of refactoring
(see Section&#XA0;<a href="#refactoring">4.7</a>).
<a id="hevea_default1640"></a></p><p>This example suggests a development plan for designing objects and
methods:</p><ol class="enumerate" type=1><li class="li-enumerate">Start by writing functions that read and write global
variables (when necessary).</li><li class="li-enumerate">Once you get the program working, look for associations
between global variables and the functions that use them.</li><li class="li-enumerate">Encapsulate related variables as attributes of an object.</li><li class="li-enumerate">Transform the associated functions into methods of the new
class.</li></ol><p>As an exercise, download my Markov code from
<a href="https://thinkpython.com/code/markov.py"><span class="c004">https://thinkpython.com/code/markov.py</span></a>, and follow the steps
described above to encapsulate the global variables as attributes of a
new class called <span class="c004">Markov</span>. Solution:
<a href="https://thinkpython.com/code/markov2.py"><span class="c004">https://thinkpython.com/code/markov2.py</span></a>.</p>
<!--TOC section id="sec220" Glossary-->
<h2 class="section" id="sec220">18.11&#X2003;Glossary</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c010">encode:</span></dt><dd class="dd-description"> To represent one set of values using another
set of values by constructing a mapping between them.
<a id="hevea_default1641"></a></dd><dt class="dt-description"><span class="c010">class attribute:</span></dt><dd class="dd-description"> An attribute associated with a class
object. Class attributes are defined inside
a class definition but outside any method.
<a id="hevea_default1642"></a>
<a id="hevea_default1643"></a></dd><dt class="dt-description"><span class="c010">instance attribute:</span></dt><dd class="dd-description"> An attribute associated with an
instance of a class.
<a id="hevea_default1644"></a>
<a id="hevea_default1645"></a></dd><dt class="dt-description"><span class="c010">veneer:</span></dt><dd class="dd-description"> A method or function that provides a different
interface to another function without doing much computation.
<a id="hevea_default1646"></a></dd><dt class="dt-description"><span class="c010">inheritance:</span></dt><dd class="dd-description"> The ability to define a new class that is a
modified version of a previously defined class.
<a id="hevea_default1647"></a></dd><dt class="dt-description"><span class="c010">parent class:</span></dt><dd class="dd-description"> The class from which a child class inherits.
<a id="hevea_default1648"></a></dd><dt class="dt-description"><span class="c010">child class:</span></dt><dd class="dd-description"> A new class created by inheriting from an
existing class; also called a &#X201C;subclass&#X201D;.
<a id="hevea_default1649"></a>
<a id="hevea_default1650"></a></dd><dt class="dt-description"><span class="c010">IS-A relationship:</span></dt><dd class="dd-description"> A relationship between a child class
and its parent class.
<a id="hevea_default1651"></a></dd><dt class="dt-description"><span class="c010">HAS-A relationship:</span></dt><dd class="dd-description"> A relationship between two classes
where instances of one class contain references to instances of
the other.
<a id="hevea_default1652"></a></dd><dt class="dt-description"><span class="c010">dependency:</span></dt><dd class="dd-description"> A relationship between two classes
where instances of one class use instances of the other class,
but do not store them as attributes.
<a id="hevea_default1653"></a></dd><dt class="dt-description"><span class="c010">class diagram:</span></dt><dd class="dd-description"> A diagram that shows the classes in a program
and the relationships between them.
<a id="hevea_default1654"></a>
<a id="hevea_default1655"></a></dd><dt class="dt-description"><span class="c010">multiplicity:</span></dt><dd class="dd-description"> A notation in a class diagram that shows, for
a HAS-A relationship, how many references there are to instances
of another class.
<a id="hevea_default1656"></a></dd><dt class="dt-description"><span class="c010">data encapsulation:</span></dt><dd class="dd-description"> A program development plan that
involves a prototype using global variables and a final version
that makes the global variables into instance attributes.
<a id="hevea_default1657"></a>
<a id="hevea_default1658"></a></dd></dl>
<!--TOC section id="sec221" Exercises-->
<h2 class="section" id="sec221">18.12&#X2003;Exercises</h2><!--SEC END --><div class="theorem"><span class="c010">Exercise&#XA0;1</span>&#X2003;<em>
For the following program, draw a class diagram that shows
these classes and the relationships among them.</em><pre class="verbatim"><em>class PingPongParent:
    pass

class Ping(PingPongParent):
    def __init__(self, pong):
        self.pong = pong


class Pong(PingPongParent):
    def __init__(self, pings=None):
        if pings is None:
            self.pings = []
        else:
            self.pings = pings

    def add_ping(self, ping):
        self.pings.append(ping)

pong = Pong()
ping = Ping(pong)
pong.add_ping(ping)
</em></pre></div><div class="theorem"><span class="c010">Exercise&#XA0;2</span>&#X2003;<em>
Write a Deck method called </em><code class="verb"><em>deal_hands</em></code><em> that
takes two parameters, the number of hands and the number of cards per
hand. It should create the appropriate number of Hand objects, deal
the appropriate number of cards per hand, and return a list of Hands.
</em></div><div class="theorem"><span class="c010">Exercise&#XA0;3</span>&#X2003;
<a id="poker"></a><p><em>The following are the possible hands in poker, in increasing order
of value and decreasing order of probability:
</em><a id="hevea_default1659"></a></p><dl class="description"><dt class="dt-description"><em><span class="c010">pair:</span></em></dt><dd class="dd-description"><em> two cards with the same rank
</em></dd><dt class="dt-description"><span class="c010"><em>two pair:</em></span></dt><dd class="dd-description"><em> two pairs of cards with the same rank
</em></dd><dt class="dt-description"><span class="c010"><em>three of a kind:</em></span></dt><dd class="dd-description"><em> three cards with the same rank
</em></dd><dt class="dt-description"><span class="c010"><em>straight:</em></span></dt><dd class="dd-description"><em> five cards with ranks in sequence (aces can
be high or low, so <span class="c004">Ace-2-3-4-5</span> is a straight and so is <span class="c004">10-Jack-Queen-King-Ace</span>, but <span class="c004">Queen-King-Ace-2-3</span> is not.)
</em></dd><dt class="dt-description"><span class="c010"><em>flush:</em></span></dt><dd class="dd-description"><em> five cards with the same suit
</em></dd><dt class="dt-description"><span class="c010"><em>full house:</em></span></dt><dd class="dd-description"><em> three cards with one rank, two cards with another
</em></dd><dt class="dt-description"><span class="c010"><em>four of a kind:</em></span></dt><dd class="dd-description"><em> four cards with the same rank
</em></dd><dt class="dt-description"><span class="c010"><em>straight flush:</em></span></dt><dd class="dd-description"><em> five cards in sequence (as defined above) and
with the same suit
</em></dd></dl><p><em>
The goal of these exercises is to estimate
the probability of drawing these various hands.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Download the following files from </em><a href="https://thinkpython.com/code"><em><span class="c004">https://thinkpython.com/code</span></em></a><em>:</em><dl class="description"><dt class="dt-description"><span class="c005"><em>Card.py</em></span></dt><dd class="dd-description"><em>: A complete version of the <span class="c004">Card</span>,
<span class="c004">Deck</span> and <span class="c004">Hand</span> classes in this chapter.</em></dd><dt class="dt-description"><span class="c005"><em>PokerHand.py</em></span></dt><dd class="dd-description"><em>: An incomplete implementation of a class
that represents a poker hand, and some code that tests it.</em></dd></dl></li><li class="li-enumerate"><em>If you run <span class="c004">PokerHand.py</span>, it deals seven 7-card poker hands
and checks to see if any of them contains a flush. Read this
code carefully before you go on.</em></li><li class="li-enumerate"><em>Add methods to <span class="c004">PokerHand.py</span> named </em><code class="verb"><em>has_pair</em></code><em>,
</em><code class="verb"><em>has_twopair</em></code><em>, etc. that return True or False according to
whether or not the hand meets the relevant criteria. Your code should
work correctly for &#X201C;hands&#X201D; that contain any number of cards
(although 5 and 7 are the most common sizes).</em></li><li class="li-enumerate"><em>Write a method named <span class="c004">classify</span> that figures out
the highest-value classification for a hand and sets the
<span class="c004">label</span> attribute accordingly. For example, a 7-card hand
might contain a flush and a pair; it should be labeled &#X201C;flush&#X201D;.</em></li><li class="li-enumerate"><em>When you are convinced that your classification methods are
working, the next step is to estimate the probabilities of the various
hands. Write a function in <span class="c004">PokerHand.py</span> that shuffles a deck of
cards, divides it into hands, classifies the hands, and counts the
number of times various classifications appear.</em></li><li class="li-enumerate"><em>Print a table of the classifications and their probabilities.
Run your program with larger and larger numbers of hands until the
output values converge to a reasonable degree of accuracy. Compare
your results to the values at </em><a href="http://en.wikipedia.org/wiki/Hand_rankings"><span class="c004"><em>http://en.wikipedia.org/wiki/Hand_rankings</em></span></a><em>.</em></li></ol><p><em>Solution: </em><a href="https://thinkpython.com/code/PokerHandSoln.py"><em><span class="c004">https://thinkpython.com/code/PokerHandSoln.py</span></em></a><em>.
</em></p></div>
<!--TOC chapter id="sec222" The Goodies-->
<h1 class="chapter" id="sec222">Chapter&#XA0;19&#X2003;The Goodies</h1><!--SEC END --><p>One of my goals for this book has been to teach you as little Python
as possible. When there were two ways to do something, I picked
one and avoided mentioning the other. Or sometimes I put the second
one into an exercise.</p><p>Now I want to go back for some of the good bits that got left behind.
Python provides a number of features that are not really necessary&#X2014;you
can write good code without them&#X2014;but with them you can sometimes
write code that&#X2019;s more concise, readable or efficient, and sometimes
all three.</p>
<!--TOC section id="sec223" Conditional expressions-->
<h2 class="section" id="sec223">19.1&#X2003;Conditional expressions</h2><!--SEC END --><p>We saw conditional statements in Section&#XA0;<a href="#conditional.execution">5.4</a>.
Conditional statements are often used to choose one of two values;
for example:
<a id="hevea_default1660"></a>
<a id="hevea_default1661"></a></p><pre class="verbatim">if x &gt; 0:
    y = math.log(x)
else:
    y = float('nan')
</pre><p>This statement checks whether <span class="c004">x</span> is positive. If so, it computes
<span class="c004">math.log</span>. If not, <span class="c004">math.log</span> would raise a ValueError. To
avoid stopping the program, we generate a &#X201C;NaN&#X201D;, which is a special
floating-point value that represents &#X201C;Not a Number&#X201D;.
<a id="hevea_default1662"></a>
<a id="hevea_default1663"></a></p><p>We can write this statement more concisely using a <span class="c010">conditional
expression</span>:</p><pre class="verbatim">y = math.log(x) if x &gt; 0 else float('nan')
</pre><p>You can almost read this line like English: &#X201C;<span class="c004">y</span> gets log-<span class="c004">x</span>
if <span class="c004">x</span> is greater than 0; otherwise it gets NaN&#X201D;.</p><p>Recursive functions can sometimes be rewritten using conditional
expressions. For example, here is a recursive version of <span class="c004">factorial</span>:
<a id="hevea_default1664"></a>
<a id="hevea_default1665"></a></p><pre class="verbatim">def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)
</pre><p>We can rewrite it like this:</p><pre class="verbatim">def factorial(n):
    return 1 if n == 0 else n * factorial(n-1)
</pre><p>Another use of conditional expressions is handling optional
arguments. For example, here is the init method from
<span class="c004">GoodKangaroo</span> (see Exercise&#XA0;<a href="#kangaroo">2</a>):
<a id="hevea_default1666"></a>
<a id="hevea_default1667"></a></p><pre class="verbatim">    def __init__(self, name, contents=None):
        self.name = name
        if contents == None:
            contents = []
        self.pouch_contents = contents
</pre><p>We can rewrite this one like this:</p><pre class="verbatim">    def __init__(self, name, contents=None):
        self.name = name
        self.pouch_contents = [] if contents == None else contents
</pre><p>In general, you can replace a conditional statement with a conditional
expression if both branches contain simple expressions that are
either returned or assigned to the same variable.
<a id="hevea_default1668"></a>
<a id="hevea_default1669"></a></p>
<!--TOC section id="sec224" List comprehensions-->
<h2 class="section" id="sec224">19.2&#X2003;List comprehensions</h2><!--SEC END --><p>In Section&#XA0;<a href="#filter">10.7</a> we saw the map and filter patterns. For
example, this function takes a list of strings, maps the string method
<span class="c004">capitalize</span> to the elements, and returns a new list of strings:</p><pre class="verbatim">def capitalize_all(t):
    res = []
    for s in t:
        res.append(s.capitalize())
    return res
</pre><p>We can write this more concisely using a <span class="c010">list comprehension</span>:
<a id="hevea_default1670"></a></p><pre class="verbatim">def capitalize_all(t):
    return [s.capitalize() for s in t]
</pre><p>The bracket operators indicate that we are constructing a new
list. The expression inside the brackets specifies the elements
of the list, and the <span class="c004">for</span> clause indicates what sequence
we are traversing.
<a id="hevea_default1671"></a>
<a id="hevea_default1672"></a></p><p>The syntax of a list comprehension is a little awkward because
the loop variable, <span class="c004">s</span> in this example, appears in the expression
before we get to the definition.
<a id="hevea_default1673"></a></p><p>List comprehensions can also be used for filtering. For example,
this function selects only the elements of <span class="c004">t</span> that are
upper case, and returns a new list:
<a id="hevea_default1674"></a>
<a id="hevea_default1675"></a></p><pre class="verbatim">def only_upper(t):
    res = []
    for s in t:
        if s.isupper():
            res.append(s)
    return res
</pre><p>We can rewrite it using a list comprehension</p><pre class="verbatim">def only_upper(t):
    return [s for s in t if s.isupper()]
</pre><p>List comprehensions are concise and easy to read, at least for simple
expressions. And they are usually faster than the equivalent for
loops, sometimes much faster. So if you are mad at me for not
mentioning them earlier, I understand.</p><p>But, in my defense, list comprehensions are harder to debug because
you can&#X2019;t put a print statement inside the loop. I suggest that you
use them only if the computation is simple enough that you are likely
to get it right the first time. And for beginners that means never.
<a id="hevea_default1676"></a></p>
<!--TOC section id="sec225" Generator expressions-->
<h2 class="section" id="sec225">19.3&#X2003;Generator expressions</h2><!--SEC END --><p><span class="c010">Generator expressions</span> are similar to list comprehensions, but
with parentheses instead of square brackets:
<a id="hevea_default1677"></a>
<a id="hevea_default1678"></a></p><pre class="verbatim">&gt;&gt;&gt; g = (x**2 for x in range(5))
&gt;&gt;&gt; g
&lt;generator object &lt;genexpr&gt; at 0x7f4c45a786c0&gt;
</pre><p>
The result is a generator object that knows how to iterate through
a sequence of values. But unlike a list comprehension, it does not
compute the values all at once; it waits to be asked. The built-in
function <span class="c004">next</span> gets the next value from the generator:
<a id="hevea_default1679"></a>
<a id="hevea_default1680"></a></p><pre class="verbatim">&gt;&gt;&gt; next(g)
0
&gt;&gt;&gt; next(g)
1
</pre><p>
When you get to the end of the sequence, <span class="c004">next</span> raises a
StopIteration exception. You can also use a <span class="c004">for</span> loop to iterate
through the values:
<a id="hevea_default1681"></a>
<a id="hevea_default1682"></a></p><pre class="verbatim">&gt;&gt;&gt; for val in g:
...     print(val)
4
9
16
</pre><p>
The generator object keeps track of where it is in the sequence,
so the <span class="c004">for</span> loop picks up where <span class="c004">next</span> left off. Once the
generator is exhausted, it continues to raise <span class="c004">StopIteration</span>:</p><pre class="verbatim">&gt;&gt;&gt; next(g)
StopIteration
</pre><p>Generator expressions are often used with functions like <span class="c004">sum</span>,
<span class="c004">max</span>, and <span class="c004">min</span>:
<a id="hevea_default1683"></a>
<a id="hevea_default1684"></a></p><pre class="verbatim">&gt;&gt;&gt; sum(x**2 for x in range(5))
30
</pre>
<!--TOC section id="sec226" <span class="c004">any</span> and <span class="c004">all</span>-->
<h2 class="section" id="sec226">19.4&#X2003;<span class="c004">any</span> and <span class="c004">all</span></h2><!--SEC END --><p>Python provides a built-in function, <span class="c004">any</span>, that takes a sequence
of boolean values and returns <span class="c004">True</span> if any of the values are <span class="c004">True</span>. It works on lists:
<a id="hevea_default1685"></a>
<a id="hevea_default1686"></a></p><pre class="verbatim">&gt;&gt;&gt; any([False, False, True])
True
</pre><p>
But it is often used with generator expressions:
<a id="hevea_default1687"></a>
<a id="hevea_default1688"></a></p><pre class="verbatim">&gt;&gt;&gt; any(letter == 't' for letter in 'monty')
True
</pre><p>
That example isn&#X2019;t very useful because it does the same thing
as the <span class="c004">in</span> operator. But we could use <span class="c004">any</span> to rewrite
some of the search functions we wrote in Section&#XA0;<a href="#search">9.3</a>. For
example, we could write <span class="c004">avoids</span> like this:
<a id="hevea_default1689"></a>
<a id="hevea_default1690"></a></p><pre class="verbatim">def avoids(word, forbidden):
    return not any(letter in forbidden for letter in word)
</pre><p>
The function almost reads like English, &#X201C;<span class="c004">word</span> avoids
<span class="c004">forbidden</span> if there are not any forbidden letters in <span class="c004">word</span>.&#X201D;</p><p>Using <span class="c004">any</span> with a generator expression is efficient because
it stops immediately if it finds a <span class="c004">True</span> value,
so it doesn&#X2019;t have to evaluate the whole sequence.</p><p>Python provides another built-in function, <span class="c004">all</span>, that returns
<span class="c004">True</span> if every element of the sequence is <span class="c004">True</span>. As
an exercise, use <span class="c004">all</span> to re-write <code class="verb">uses_all</code> from
Section&#XA0;<a href="#search">9.3</a>.
<a id="hevea_default1691"></a>
<a id="hevea_default1692"></a></p>
<!--TOC section id="sec227" Sets-->
<h2 class="section" id="sec227">19.5&#X2003;Sets</h2><!--SEC END --><p>
<a id="sets"></a></p><p>In Section&#XA0;<a href="#dictsub">13.6</a> I use dictionaries to find the words
that appear in a document but not in a word list. The function
I wrote takes <span class="c004">d1</span>, which contains the words from the document
as keys, and <span class="c004">d2</span>, which contains the list of words. It
returns a dictionary that contains the keys from <span class="c004">d1</span> that
are not in <span class="c004">d2</span>.</p><pre class="verbatim">def subtract(d1, d2):
    res = dict()
    for key in d1:
        if key not in d2:
            res[key] = None
    return res
</pre><p>
In all of these dictionaries, the values are <span class="c004">None</span> because
we never use them. As a result, we waste some storage space.
<a id="hevea_default1693"></a></p><p>Python provides another built-in type, called a <span class="c004">set</span>, that
behaves like a collection of dictionary keys with no values. Adding
elements to a set is fast; so is checking membership. And sets
provide methods and operators to compute common set operations.
<a id="hevea_default1694"></a>
<a id="hevea_default1695"></a></p><p>For example, set subtraction is available as a method called
<span class="c004">difference</span> or as an operator, <span class="c004">-</span>. So we can rewrite
<span class="c004">subtract</span> like this:
<a id="hevea_default1696"></a></p><pre class="verbatim">def subtract(d1, d2):
    return set(d1) - set(d2)
</pre><p>
The result is a set instead of a dictionary, but for operations like
iteration, the behavior is the same.</p><p>Some of the exercises in this book can be done concisely and
efficiently with sets. For example, here is a solution to
<code class="verb">has_duplicates</code>, from
Exercise&#XA0;<a href="#duplicate">7</a>, that uses a dictionary:</p><pre class="verbatim">def has_duplicates(t):
    d = {}
    for x in t:
        if x in d:
            return True
        d[x] = True
    return False
</pre><p>When an element appears for the first time, it is added to the
dictionary. If the same element appears again, the function returns
<span class="c004">True</span>.</p><p>Using sets, we can write the same function like this:</p><pre class="verbatim">def has_duplicates(t):
    return len(set(t)) &lt; len(t)
</pre><p>
An element can only appear in a set once, so if an element in <span class="c004">t</span>
appears more than once, the set will be smaller than <span class="c004">t</span>. If there
are no duplicates, the set will be the same size as <span class="c004">t</span>.
<a id="hevea_default1697"></a></p><p>We can also use sets to do some of the exercises in
Chapter&#XA0;<a href="#wordplay">9</a>. For example, here&#X2019;s a version of
<code class="verb">uses_only</code> with a loop:</p><pre class="verbatim">def uses_only(word, available):
    for letter in word:
        if letter not in available:
            return False
    return True
</pre><p>
<code class="verb">uses_only</code> checks whether all letters in <span class="c004">word</span> are
in <span class="c004">available</span>. We can rewrite it like this:</p><pre class="verbatim">def uses_only(word, available):
    return set(word) &lt;= set(available)
</pre><p>
The <code class="verb">&lt;=</code> operator checks whether one set is a subset of another,
including the possibility that they are equal, which is true if all
the letters in <span class="c004">word</span> appear in <span class="c004">available</span>.
<a id="hevea_default1698"></a></p><p>As an exercise, rewrite <code class="verb">avoids</code> using sets.</p>
<!--TOC section id="sec228" Counters-->
<h2 class="section" id="sec228">19.6&#X2003;Counters</h2><!--SEC END --><p>A Counter is like a set, except that if an element appears more
than once, the Counter keeps track of how many times it appears.
If you are familiar with the mathematical idea of a <span class="c010">multiset</span>,
a Counter is a natural way to represent a multiset.
<a id="hevea_default1699"></a>
<a id="hevea_default1700"></a>
<a id="hevea_default1701"></a></p><p>Counter is defined in a standard module called <span class="c004">collections</span>,
so you have to import it. You can initialize a Counter with a string,
list, or anything else that supports iteration:
<a id="hevea_default1702"></a>
<a id="hevea_default1703"></a></p><pre class="verbatim">&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; count = Counter('parrot')
&gt;&gt;&gt; count
Counter({'r': 2, 't': 1, 'o': 1, 'p': 1, 'a': 1})
</pre><p>Counters behave like dictionaries in many ways; they map from each
key to the number of times it appears. As in dictionaries,
the keys have to be hashable.</p><p>Unlike dictionaries, Counters don&#X2019;t raise an exception if you access
an element that doesn&#X2019;t appear. Instead, they return 0:</p><pre class="verbatim">&gt;&gt;&gt; count['d']
0
</pre><p>We can use Counters to rewrite <code class="verb">is_anagram</code> from
Exercise&#XA0;<a href="#anagram">6</a>:</p><pre class="verbatim">def is_anagram(word1, word2):
    return Counter(word1) == Counter(word2)
</pre><p>If two words are anagrams, they contain the same letters with the same
counts, so their Counters are equivalent.</p><p>Counters provide methods and operators to perform set-like operations,
including addition, subtraction, union and intersection. And
they provide an often-useful method, <code class="verb">most_common</code>, which
returns a list of value-frequency pairs, sorted from most common to
least:</p><pre class="verbatim">&gt;&gt;&gt; count = Counter('parrot')
&gt;&gt;&gt; for val, freq in count.most_common(3):
...     print(val, freq)
r 2
p 1
a 1
</pre>
<!--TOC section id="sec229" defaultdict-->
<h2 class="section" id="sec229">19.7&#X2003;defaultdict</h2><!--SEC END --><p>The <span class="c004">collections</span> module also provides <span class="c004">defaultdict</span>, which is
like a dictionary except that if you access a key that doesn&#X2019;t exist,
it can generate a new value on the fly.
<a id="hevea_default1704"></a>
<a id="hevea_default1705"></a>
<a id="hevea_default1706"></a>
<a id="hevea_default1707"></a></p><p>When you create a defaultdict, you provide a function that&#X2019;s used to
create new values. A function used to create objects is sometimes
called a <span class="c010">factory</span>. The built-in functions that create lists, sets,
and other types can be used as factories:
<a id="hevea_default1708"></a></p><pre class="verbatim">&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; d = defaultdict(list)
</pre><p>Notice that the argument is <span class="c004">list</span>, which is a class object,
not <span class="c004">list()</span>, which is a new list. The function you provide
doesn&#X2019;t get called unless you access a key that doesn&#X2019;t exist.</p><pre class="verbatim">&gt;&gt;&gt; t = d['new key']
&gt;&gt;&gt; t
[]
</pre><p>The new list, which we&#X2019;re calling <span class="c004">t</span>, is also added to the
dictionary. So if we modify <span class="c004">t</span>, the change appears in <span class="c004">d</span>:</p><pre class="verbatim">&gt;&gt;&gt; t.append('new value')
&gt;&gt;&gt; d
defaultdict(&lt;class 'list'&gt;, {'new key': ['new value']})
</pre><p>If you are making a dictionary of lists, you can often write simpler
code using <span class="c004">defaultdict</span>. In my solution to
Exercise&#XA0;<a href="#anagrams">2</a>, which you can get from
<a href="https://thinkpython.com/code/anagram_sets.py"><span class="c004">https://thinkpython.com/code/anagram_sets.py</span></a>, I make a
dictionary that maps from a sorted string of letters to the list of
words that can be spelled with those letters. For example, <span class="c004">&#X2019;opst&#X2019;</span> maps to the list <span class="c004">[&#X2019;opts&#X2019;, &#X2019;post&#X2019;, &#X2019;pots&#X2019;, &#X2019;spot&#X2019;,
&#X2019;stop&#X2019;, &#X2019;tops&#X2019;]</span>.</p><p>Here&#X2019;s the original code:</p><pre class="verbatim">def all_anagrams(filename):
    d = {}
    for line in open(filename):
        word = line.strip().lower()
        t = signature(word)
        if t not in d:
            d[t] = [word]
        else:
            d[t].append(word)
    return d
</pre><p>This can be simplified using <span class="c004">setdefault</span>, which you might
have used in Exercise&#XA0;<a href="#setdefault">2</a>:
<a id="hevea_default1709"></a></p><pre class="verbatim">def all_anagrams(filename):
    d = {}
    for line in open(filename):
        word = line.strip().lower()
        t = signature(word)
        d.setdefault(t, []).append(word)
    return d
</pre><p>This solution has the drawback that it makes a new list
every time, regardless of whether it is needed. For lists,
that&#X2019;s no big deal, but if the factory
function is complicated, it might be.
<a id="hevea_default1710"></a></p><p>We can avoid this problem and
simplify the code using a <span class="c004">defaultdict</span>:</p><pre class="verbatim">def all_anagrams(filename):
    d = defaultdict(list)
    for line in open(filename):
        word = line.strip().lower()
        t = signature(word)
        d[t].append(word)
    return d
</pre><p>My solution to Exercise&#XA0;<a href="#poker">3</a>, which you can download from
<a href="https://thinkpython.com/code/PokerHandSoln.py"><span class="c004">https://thinkpython.com/code/PokerHandSoln.py</span></a>,
uses <span class="c004">setdefault</span> in the function
<code class="verb">has_straightflush</code>. This solution has the drawback
of creating a <span class="c004">Hand</span> object every time through the loop, whether
it is needed or not. As an exercise, rewrite it using
a defaultdict.</p>
<!--TOC section id="sec230" Named tuples-->
<h2 class="section" id="sec230">19.8&#X2003;Named tuples</h2><!--SEC END --><p>Many simple objects are basically collections of related values.
For example, the Point object defined in Chapter&#XA0;<a href="#clobjects">15</a> contains
two numbers, <span class="c004">x</span> and <span class="c004">y</span>. When you define a class like
this, you usually start with an init method and a str method:</p><pre class="verbatim">class Point:

    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def __str__(self):
        return '(%g, %g)' % (self.x, self.y)
</pre><p>This is a lot of code to convey a small amount of information.
Python provides a more concise way to say the same thing:</p><pre class="verbatim">from collections import namedtuple
Point = namedtuple('Point', ['x', 'y'])
</pre><p>The first argument is the name of the class you want to create.
The second is a list of the attributes Point objects should have,
as strings. The return value from <span class="c004">namedtuple</span> is a class object:
<a id="hevea_default1711"></a>
<a id="hevea_default1712"></a>
<a id="hevea_default1713"></a>
<a id="hevea_default1714"></a></p><pre class="verbatim">&gt;&gt;&gt; Point
&lt;class '__main__.Point'&gt;
</pre><p><span class="c004">Point</span> automatically provides methods like <code class="verb">__init__</code> and
<code class="verb">__str__</code> so you don&#X2019;t have to write them.
<a id="hevea_default1715"></a>
<a id="hevea_default1716"></a></p><p>To create a Point object, you use the Point class as a function:</p><pre class="verbatim">&gt;&gt;&gt; p = Point(1, 2)
&gt;&gt;&gt; p
Point(x=1, y=2)
</pre><p>The init method assigns the arguments to attributes using the names
you provided. The str method prints a representation of the Point
object and its attributes.</p><p>You can access the elements of the named tuple by name:</p><pre class="verbatim">&gt;&gt;&gt; p.x, p.y
(1, 2)
</pre><p>But you can also treat a named tuple as a tuple:</p><pre class="verbatim">&gt;&gt;&gt; p[0], p[1]
(1, 2)

&gt;&gt;&gt; x, y = p
&gt;&gt;&gt; x, y
(1, 2)
</pre><p>Named tuples provide a quick way to define simple classes.
The drawback is that simple classes don&#X2019;t always stay simple.
You might decide later that you want to add methods to a named tuple.
In that case, you could define a new class that inherits from
the named tuple:
<a id="hevea_default1717"></a></p><pre class="verbatim">class Pointier(Point):
    # add more methods here
</pre><p>Or you could switch to a conventional class definition.</p>
<!--TOC section id="sec231" Gathering keyword args-->
<h2 class="section" id="sec231">19.9&#X2003;Gathering keyword args</h2><!--SEC END --><p>In Section&#XA0;<a href="#gather">12.4</a>, we saw how to write a function that
gathers its arguments into a tuple:
<a id="hevea_default1718"></a></p><pre class="verbatim">def printall(*args):
    print(args)
</pre><p>
You can call this function with any number of positional arguments
(that is, arguments that don&#X2019;t have keywords):
<a id="hevea_default1719"></a>
<a id="hevea_default1720"></a></p><pre class="verbatim">&gt;&gt;&gt; printall(1, 2.0, '3')
(1, 2.0, '3')
</pre><p>
But the <span class="c004">*</span> operator doesn&#X2019;t gather keyword arguments:
<a id="hevea_default1721"></a>
<a id="hevea_default1722"></a></p><pre class="verbatim">&gt;&gt;&gt; printall(1, 2.0, third='3')
TypeError: printall() got an unexpected keyword argument 'third'
</pre><p>
To gather keyword arguments, you can use the <span class="c004">**</span> operator:</p><pre class="verbatim">def printall(*args, **kwargs):
    print(args, kwargs)
</pre><p>
You can call the keyword gathering parameter anything you want, but
<span class="c004">kwargs</span> is a common choice. The result is a dictionary that maps
from keywords to values:</p><pre class="verbatim">&gt;&gt;&gt; printall(1, 2.0, third='3')
(1, 2.0) {'third': '3'}
</pre><p>
If you have a dictionary of keywords and values, you can use the
scatter operator, <span class="c004">**</span> to call a function:
<a id="hevea_default1723"></a></p><pre class="verbatim">&gt;&gt;&gt; d = dict(x=1, y=2)
&gt;&gt;&gt; Point(**d)
Point(x=1, y=2)
</pre><p>
Without the scatter operator, the function would treat <span class="c004">d</span> as
a single positional argument, so it would assign <span class="c004">d</span> to
<span class="c004">x</span> and complain because there&#X2019;s nothing to assign to <span class="c004">y</span>:</p><pre class="verbatim">&gt;&gt;&gt; d = dict(x=1, y=2)
&gt;&gt;&gt; Point(d)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: __new__() missing 1 required positional argument: 'y'
</pre><p>
When you are working with functions that have a large number of
parameters, it is often useful to create and pass around dictionaries
that specify frequently used options.</p>
<!--TOC section id="sec232" Glossary-->
<h2 class="section" id="sec232">19.10&#X2003;Glossary</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c010">conditional expression:</span></dt><dd class="dd-description"> An expression that has one of two
values, depending on a condition.
<a id="hevea_default1724"></a>
<a id="hevea_default1725"></a></dd><dt class="dt-description"><span class="c010">list comprehension:</span></dt><dd class="dd-description"> An expression with a <span class="c004">for</span> loop in square
brackets that yields a new list.
<a id="hevea_default1726"></a></dd><dt class="dt-description"><span class="c010">generator expression:</span></dt><dd class="dd-description"> An expression with a <span class="c004">for</span> loop in parentheses
that yields a generator object.
<a id="hevea_default1727"></a>
<a id="hevea_default1728"></a></dd><dt class="dt-description"><span class="c010">multiset:</span></dt><dd class="dd-description"> A mathematical entity that represents a mapping
between the elements of a set and the number of times they appear.</dd><dt class="dt-description"><span class="c010">factory:</span></dt><dd class="dd-description"> A function, usually passed as a parameter, used to
create objects.
<a id="hevea_default1729"></a></dd></dl>
<!--TOC section id="sec233" Exercises-->
<h2 class="section" id="sec233">19.11&#X2003;Exercises</h2><!--SEC END --><div class="theorem"><span class="c010">Exercise&#XA0;1</span>&#X2003;<p><em>The following is a function that computes the binomial
coefficient recursively.</em></p><pre class="verbatim"><em>def binomial_coeff(n, k):
    """Compute the binomial coefficient "n choose k".

    n: number of trials
    k: number of successes

    returns: int
    """
    if k == 0:
        return 1
    if n == 0:
        return 0

    res = binomial_coeff(n-1, k) + binomial_coeff(n-1, k-1)
    return res
</em></pre><p><em>Rewrite the body of the function using nested conditional
expressions.</em></p><p><em>One note: this function is not very efficient because it ends up computing
the same values over and over. You could make it more efficient by
memoizing (see Section&#XA0;</em><a href="#memoize"><em>11.6</em></a><em>). But you will find that it&#X2019;s harder to
memoize if you write it using conditional expressions.</em></p></div>
<!--TOC chapter id="sec234" Debugging-->
<h1 class="chapter" id="sec234">Appendix&#XA0;A&#X2003;Debugging</h1><!--SEC END --><p>
<a id="hevea_default1730"></a></p><p>When you are debugging, you should distinguish among different
kinds of errors in order to track them down more quickly:</p><ul class="itemize"><li class="li-itemize">Syntax errors are discovered by the interpreter when it is
translating the source code into byte code. They indicate
that there is something wrong with the structure of the program.
Example: Omitting the colon at the end of a <span class="c004">def</span> statement
generates the somewhat redundant message <span class="c004">SyntaxError: invalid
syntax</span>.
<a id="hevea_default1731"></a>
<a id="hevea_default1732"></a></li><li class="li-itemize">Runtime errors are produced by the interpreter if something goes
wrong while the program is running. Most runtime error messages
include information about where the error occurred and what
functions were executing. Example: An infinite recursion eventually
causes the runtime error &#X201C;maximum recursion depth exceeded&#X201D;.
<a id="hevea_default1733"></a>
<a id="hevea_default1734"></a>
<a id="hevea_default1735"></a></li><li class="li-itemize">Semantic errors are problems with a program that runs without
producing error messages but doesn&#X2019;t do the right thing. Example:
An expression may not be evaluated in the order you expect, yielding
an incorrect result.
<a id="hevea_default1736"></a>
<a id="hevea_default1737"></a></li></ul><p>The first step in debugging is to figure out which kind of
error you are dealing with. Although the following sections are
organized by error type, some techniques are
applicable in more than one situation.</p>
<!--TOC section id="sec235" Syntax errors-->
<h2 class="section" id="sec235">A.1&#X2003;Syntax errors</h2><!--SEC END --><p>
<a id="hevea_default1738"></a></p><p>Syntax errors are usually easy to fix once you figure out what they
are. Unfortunately, the error messages are often not helpful.
The most common messages are <span class="c004">SyntaxError: invalid syntax</span> and
<span class="c004">SyntaxError: invalid token</span>, neither of which is very informative.</p><p>On the other hand, the message does tell you where in the program the
problem occurred. Actually, it tells you where Python
noticed a problem, which is not necessarily where the error
is. Sometimes the error is prior to the location of the error
message, often on the preceding line.
<a id="hevea_default1739"></a>
<a id="hevea_default1740"></a></p><p>If you are building the program incrementally, you should have
a good idea about where the error is. It will be in the last
line you added.</p><p>If you are copying code from a book, start by comparing
your code to the book&#X2019;s code very carefully. Check every character.
At the same time, remember that the book might be wrong, so
if you see something that looks like a syntax error, it might be.</p><p>Here are some ways to avoid the most common syntax errors:
<a id="hevea_default1741"></a></p><ol class="enumerate" type=1><li class="li-enumerate">Make sure you are not using a Python keyword for a variable name.
<a id="hevea_default1742"></a></li><li class="li-enumerate">Check that you have a colon at the end of the header of every
compound statement, including <span class="c004">for</span>, <span class="c004">while</span>,
<span class="c004">if</span>, and <span class="c004">def</span> statements.
<a id="hevea_default1743"></a>
<a id="hevea_default1744"></a></li><li class="li-enumerate">Make sure that any strings in the code have matching
quotation marks. Make sure that all quotation marks are
&#X201C;straight quotes&#X201D;, not &#X201C;curly quotes&#X201D;.
<a id="hevea_default1745"></a></li><li class="li-enumerate">If you have multiline strings with triple quotes (single or double), make
sure you have terminated the string properly. An unterminated string
may cause an <span class="c004">invalid token</span> error at the end of your program,
or it may treat the following part of the program as a string until it
comes to the next string. In the second case, it might not produce an error
message at all!
<a id="hevea_default1746"></a>
<a id="hevea_default1747"></a></li><li class="li-enumerate">An unclosed opening operator&#X2014;<code class="verb">(</code>, <code class="verb">{</code>, or
<code class="verb">[</code>&#X2014;makes Python continue with the next line as part of the
current statement. Generally, an error occurs almost immediately in
the next line.</li><li class="li-enumerate">Check for the classic <span class="c004">=</span> instead of <span class="c004">==</span> inside
a conditional.
<a id="hevea_default1748"></a></li><li class="li-enumerate">Check the indentation to make sure it lines up the way it
is supposed to. Python can handle space and tabs, but if you mix
them it can cause problems. The best way to avoid this problem
is to use a text editor that knows about Python and generates
consistent indentation.
<a id="hevea_default1749"></a>
<a id="hevea_default1750"></a></li><li class="li-enumerate">If you have non-ASCII characters in the code (including strings
and comments), that might cause a problem, although Python 3 usually
handles non-ASCII characters. Be careful if you paste in text from
a web page or other source.</li></ol><p>If nothing works, move on to the next section...</p>
<!--TOC subsection id="sec236" I keep making changes and it makes no difference.-->
<h3 class="subsection" id="sec236">A.1.1&#X2003;I keep making changes and it makes no difference.</h3><!--SEC END --><p>If the interpreter says there is an error and you don&#X2019;t see it, that
might be because you and the interpreter are not looking at the same
code. Check your programming environment to make sure that the
program you are editing is the one Python is trying to run.</p><p>If you are not sure, try putting an obvious and deliberate syntax
error at the beginning of the program. Now run it again. If the
interpreter doesn&#X2019;t find the new error, you are not running the
new code.</p><p>There are a few likely culprits:</p><ul class="itemize"><li class="li-itemize">You edited the file and forgot to save the changes before
running it again. Some programming environments do this
for you, but some don&#X2019;t.</li><li class="li-itemize">You changed the name of the file, but you are still running
the old name.</li><li class="li-itemize">Something in your development environment is configured
incorrectly.</li><li class="li-itemize">If you are writing a module and using <span class="c004">import</span>,
make sure you don&#X2019;t give your module the same name as one
of the standard Python modules.</li><li class="li-itemize">If you are using <span class="c004">import</span> to read a module, remember
that you have to restart the interpreter or use <span class="c004">reload</span>
to read a modified file. If you import the module again, it
doesn&#X2019;t do anything.
<a id="hevea_default1751"></a>
<a id="hevea_default1752"></a>
<a id="hevea_default1753"></a></li></ul><p>If you get stuck and you can&#X2019;t figure out what is going on, one
approach is to start again with a new program like &#X201C;Hello, World!&#X201D;,
and make sure you can get a known program to run. Then gradually add
the pieces of the original program to the new one.</p>
<!--TOC section id="sec237" Runtime errors-->
<h2 class="section" id="sec237">A.2&#X2003;Runtime errors</h2><!--SEC END --><p>Once your program is syntactically correct,
Python can read it and at least start running it. What could
possibly go wrong?</p>
<!--TOC subsection id="sec238" My program does absolutely nothing.-->
<h3 class="subsection" id="sec238">A.2.1&#X2003;My program does absolutely nothing.</h3><!--SEC END --><p>This problem is most common when your file consists of functions and
classes but does not actually invoke a function to start execution.
This may be intentional if you only plan to import this module to
supply classes and functions.</p><p>If it is not intentional, make sure there is a function call
in the program, and make sure the flow of execution reaches
it (see &#X201C;Flow of Execution&#X201D; below).</p>
<!--TOC subsection id="sec239" My program hangs.-->
<h3 class="subsection" id="sec239">A.2.2&#X2003;My program hangs.</h3><!--SEC END --><p>
<a id="hevea_default1754"></a>
<a id="hevea_default1755"></a>
<a id="hevea_default1756"></a></p><p>If a program stops and seems to be doing nothing, it is &#X201C;hanging&#X201D;.
Often that means that it is caught in an infinite loop or infinite
recursion.</p><ul class="itemize"><li class="li-itemize">If there is a particular loop that you suspect is the
problem, add a <span class="c004">print</span> statement immediately before the loop that says
&#X201C;entering the loop&#X201D; and another immediately after that says
&#X201C;exiting the loop&#X201D;.<p>Run the program. If you get the first message and not the second,
you&#X2019;ve got an infinite loop. Go to the &#X201C;Infinite Loop&#X201D; section
below.</p></li><li class="li-itemize">Most of the time, an infinite recursion will cause the program
to run for a while and then produce a &#X201C;RuntimeError: Maximum
recursion depth exceeded&#X201D; error. If that happens, go to the
&#X201C;Infinite Recursion&#X201D; section below.<p>If you are not getting this error but you suspect there is a problem
with a recursive method or function, you can still use the techniques
in the &#X201C;Infinite Recursion&#X201D; section.</p></li><li class="li-itemize">If neither of those steps works, start testing other
loops and other recursive functions and methods.</li><li class="li-itemize">If that doesn&#X2019;t work, then it is possible that
you don&#X2019;t understand the flow of execution in your program.
Go to the &#X201C;Flow of Execution&#X201D; section below.</li></ul>
<!--TOC subsubsection id="sec240" Infinite Loop-->
<h4 class="subsubsection" id="sec240">Infinite Loop</h4><!--SEC END --><p>
<a id="hevea_default1757"></a>
<a id="hevea_default1758"></a>
<a id="hevea_default1759"></a>
<a id="hevea_default1760"></a></p><p>If you think you have an infinite loop and you think you know
what loop is causing the problem, add a <span class="c004">print</span> statement at
the end of the loop that prints the values of the variables in
the condition and the value of the condition.</p><p>For example:</p><pre class="verbatim">while x &gt; 0 and y &lt; 0 :
    # do something to x
    # do something to y

    print('x: ', x)
    print('y: ', y)
    print("condition: ", (x &gt; 0 and y &lt; 0))
</pre><p>
Now when you run the program, you will see three lines of output
for each time through the loop. The last time through the
loop, the condition should be <span class="c004">False</span>. If the loop keeps
going, you will be able to see the values of <span class="c004">x</span> and <span class="c004">y</span>,
and you might figure out why they are not being updated correctly.</p>
<!--TOC subsubsection id="sec241" Infinite Recursion-->
<h4 class="subsubsection" id="sec241">Infinite Recursion</h4><!--SEC END --><p>
<a id="hevea_default1761"></a>
<a id="hevea_default1762"></a></p><p>Most of the time, infinite recursion causes the program to run
for a while and then produce a <span class="c004">Maximum recursion depth exceeded</span>
error.</p><p>If you suspect that a function is causing an infinite
recursion, make sure that there is a base case.
There should be some condition that causes the
function to return without making a recursive invocation.
If not, you need to rethink the algorithm and identify a base
case.</p><p>If there is a base case but the program doesn&#X2019;t seem to be reaching
it, add a <span class="c004">print</span> statement at the beginning of the function
that prints the parameters. Now when you run the program, you will see
a few lines of output every time the function is invoked,
and you will see the parameter values. If the parameters are not moving
toward the base case, you will get some ideas about why not.</p>
<!--TOC subsubsection id="sec242" Flow of Execution-->
<h4 class="subsubsection" id="sec242">Flow of Execution</h4><!--SEC END --><p>
<a id="hevea_default1763"></a></p><p>If you are not sure how the flow of execution is moving through
your program, add <span class="c004">print</span> statements to the beginning of each
function with a message like &#X201C;entering function <span class="c004">foo</span>&#X201D;, where
<span class="c004">foo</span> is the name of the function.</p><p>Now when you run the program, it will print a trace of each
function as it is invoked.</p>
<!--TOC subsection id="sec243" When I run the program I get an exception.-->
<h3 class="subsection" id="sec243">A.2.3&#X2003;When I run the program I get an exception.</h3><!--SEC END --><p>
<a id="hevea_default1764"></a>
<a id="hevea_default1765"></a></p><p>If something goes wrong during runtime, Python
prints a message that includes the name of the
exception, the line of the program where the problem occurred,
and a traceback.
<a id="hevea_default1766"></a></p><p>The traceback identifies the function that is currently running, and
then the function that called it, and then the function that called
<em>that</em>, and so on. In other words, it traces the sequence of
function calls that got you to where you are, including the line
number in your file where each call occurred.</p><p>The first step is to examine the place in the program where
the error occurred and see if you can figure out what happened.
These are some of the most common runtime errors:</p><dl class="description"><dt class="dt-description"><span class="c010">NameError:</span></dt><dd class="dd-description"> You are trying to use a variable that doesn&#X2019;t
exist in the current environment. Check if the name
is spelled right, or at least consistently.
And remember that local variables are local; you
cannot refer to them from outside the function where they are defined.
<a id="hevea_default1767"></a>
<a id="hevea_default1768"></a></dd><dt class="dt-description"><span class="c010">TypeError:</span></dt><dd class="dd-description"> There are several possible causes:
<a id="hevea_default1769"></a>
<a id="hevea_default1770"></a><ul class="itemize"><li class="li-itemize">You are trying to use a value improperly. Example: indexing
a string, list, or tuple with something other than an integer.
<a id="hevea_default1771"></a></li><li class="li-itemize">There is a mismatch between the items in a format string and
the items passed for conversion. This can happen if either the number
of items does not match or an invalid conversion is called for.
<a id="hevea_default1772"></a>
<a id="hevea_default1773"></a></li><li class="li-itemize">You are passing the wrong number of arguments to a function.
For methods, look at the method definition and
check that the first parameter is <span class="c004">self</span>. Then look at the
method invocation; make sure you are invoking the method on an
object with the right type and providing the other arguments
correctly.</li></ul></dd><dt class="dt-description"><span class="c010">KeyError:</span></dt><dd class="dd-description"> You are trying to access an element of a dictionary
using a key that the dictionary does not contain. If the keys
are strings, remember that capitalization matters.
<a id="hevea_default1774"></a>
<a id="hevea_default1775"></a>
<a id="hevea_default1776"></a></dd><dt class="dt-description"><span class="c010">AttributeError:</span></dt><dd class="dd-description"> You are trying to access an attribute or method
that does not exist. Check the spelling! You can use the built-in
function <span class="c004">vars</span> to list the attributes that do exist.
<a id="hevea_default1777"></a>
<a id="hevea_default1778"></a><p>If an AttributeError indicates that an object has <span class="c004">NoneType</span>,
that means that it is <span class="c004">None</span>. So the problem is not the
attribute name, but the object.</p><p>The reason the object is none might be that you forgot
to return a value from a function; if you get to the end of
a function without hitting a <span class="c004">return</span> statement, it returns
<span class="c004">None</span>. Another common cause is using the result from
a list method, like <span class="c004">sort</span>, that returns <span class="c004">None</span>.
<a id="hevea_default1779"></a>
<a id="hevea_default1780"></a></p></dd><dt class="dt-description"><span class="c010">IndexError:</span></dt><dd class="dd-description"> The index you are using
to access a list, string, or tuple is greater than
its length minus one. Immediately before the site of the error,
add a <span class="c004">print</span> statement to display
the value of the index and the length of the array.
Is the array the right size? Is the index the right value?
<a id="hevea_default1781"></a>
<a id="hevea_default1782"></a></dd></dl><p>The Python debugger (<span class="c004">pdb</span>) is useful for tracking down
exceptions because it allows you to examine the state of the
program immediately before the error. You can read
about <span class="c004">pdb</span> at <a href="https://docs.python.org/3/library/pdb.html"><span class="c004">https://docs.python.org/3/library/pdb.html</span></a>.
<a id="hevea_default1783"></a>
<a id="hevea_default1784"></a></p>
<!--TOC subsection id="sec244" I added so many <span class="c004">print</span> statements I get inundated with
output.-->
<h3 class="subsection" id="sec244">A.2.4&#X2003;I added so many <span class="c004">print</span> statements I get inundated with
output.</h3><!--SEC END --><p>
<a id="hevea_default1785"></a>
<a id="hevea_default1786"></a></p><p>One of the problems with using <span class="c004">print</span> statements for debugging
is that you can end up buried in output. There are two ways
to proceed: simplify the output or simplify the program.</p><p>To simplify the output, you can remove or comment out <span class="c004">print</span>
statements that aren&#X2019;t helping, or combine them, or format
the output so it is easier to understand.</p><p>To simplify the program, there are several things you can do. First,
scale down the problem the program is working on. For example, if you
are searching a list, search a <em>small</em> list. If the program takes
input from the user, give it the simplest input that causes the
problem.
<a id="hevea_default1787"></a></p><p>Second, clean up the program. Remove dead code and reorganize the
program to make it as easy to read as possible. For example, if you
suspect that the problem is in a deeply nested part of the program,
try rewriting that part with simpler structure. If you suspect a
large function, try splitting it into smaller functions and testing them
separately.
<a id="hevea_default1788"></a>
<a id="hevea_default1789"></a></p><p>Often the process of finding the minimal test case leads you to the
bug. If you find that a program works in one situation but not in
another, that gives you a clue about what is going on.</p><p>Similarly, rewriting a piece of code can help you find subtle
bugs. If you make a change that you think shouldn&#X2019;t affect the
program, and it does, that can tip you off.</p>
<!--TOC section id="sec245" Semantic errors-->
<h2 class="section" id="sec245">A.3&#X2003;Semantic errors</h2><!--SEC END --><p>In some ways, semantic errors are the hardest to debug,
because the interpreter provides no information
about what is wrong. Only you know what the program is supposed to
do.
<a id="hevea_default1790"></a>
<a id="hevea_default1791"></a></p><p>The first step is to make a connection between the program
text and the behavior you are seeing. You need a hypothesis
about what the program is actually doing. One of the things
that makes that hard is that computers run so fast.</p><p>You will often wish that you could slow the program down to human
speed, and with some debuggers you can. But the time it takes to
insert a few well-placed <span class="c004">print</span> statements is often short compared to
setting up the debugger, inserting and removing breakpoints, and
&#X201C;stepping&#X201D; the program to where the error is occurring.</p>
<!--TOC subsection id="sec246" My program doesn&#X2019;t work.-->
<h3 class="subsection" id="sec246">A.3.1&#X2003;My program doesn&#X2019;t work.</h3><!--SEC END --><p>You should ask yourself these questions:</p><ul class="itemize"><li class="li-itemize">Is there something the program was supposed to do but
which doesn&#X2019;t seem to be happening? Find the section of the code
that performs that function and make sure it is executing when
you think it should.</li><li class="li-itemize">Is something happening that shouldn&#X2019;t? Find code in
your program that performs that function and see if it is
executing when it shouldn&#X2019;t.</li><li class="li-itemize">Is a section of code producing an effect that is not
what you expected? Make sure that you understand the code in
question, especially if it involves functions or methods in
other Python modules. Read the documentation for the functions you call.
Try them out by writing simple test cases and checking the results.</li></ul><p>In order to program, you need a mental model of how
programs work. If you write a program that doesn&#X2019;t do what you expect,
often the problem is not in the program; it&#X2019;s in your mental
model.
<a id="hevea_default1792"></a>
<a id="hevea_default1793"></a></p><p>The best way to correct your mental model is to break the program
into its components (usually the functions and methods) and test
each component independently. Once you find the discrepancy
between your model and reality, you can solve the problem.</p><p>Of course, you should be building and testing components as you
develop the program. If you encounter a problem,
there should be only a small amount of new code
that is not known to be correct.</p>
<!--TOC subsection id="sec247" I&#X2019;ve got a big hairy expression and it doesn&#X2019;t
do what I expect.-->
<h3 class="subsection" id="sec247">A.3.2&#X2003;I&#X2019;ve got a big hairy expression and it doesn&#X2019;t
do what I expect.</h3><!--SEC END --><p>
<a id="hevea_default1794"></a>
<a id="hevea_default1795"></a></p><p>Writing complex expressions is fine as long as they are readable,
but they can be hard to debug. It is often a good idea to
break a complex expression into a series of assignments to
temporary variables.</p><p>For example:</p><pre class="verbatim">self.hands[i].addCard(self.hands[self.findNeighbor(i)].popCard())
</pre><p>
This can be rewritten as:</p><pre class="verbatim">neighbor = self.findNeighbor(i)
pickedCard = self.hands[neighbor].popCard()
self.hands[i].addCard(pickedCard)
</pre><p>
The explicit version is easier to read because the variable
names provide additional documentation, and it is easier to debug
because you can check the types of the intermediate variables
and display their values.
<a id="hevea_default1796"></a>
<a id="hevea_default1797"></a></p><p>Another problem that can occur with big expressions is
that the order of evaluation may not be what you expect.
For example, if you are translating the expression
<span class="c009">x</span>/2 &#X3C0; into Python, you might write:</p><pre class="verbatim">y = x / 2 * math.pi
</pre><p>
That is not correct because multiplication and division have
the same precedence and are evaluated from left to right.
So this expression computes <span class="c009">x</span> &#X3C0; / 2.
<a id="hevea_default1798"></a>
<a id="hevea_default1799"></a></p><p>A good way to debug expressions is to add parentheses to make
the order of evaluation explicit:</p><pre class="verbatim"> y = x / (2 * math.pi)
</pre><p>
Whenever you are not sure of the order of evaluation, use
parentheses. Not only will the program be correct (in the sense
of doing what you intended), it will also be more readable for
other people who haven&#X2019;t memorized the order of operations.</p>
<!--TOC subsection id="sec248" I&#X2019;ve got a function that doesn&#X2019;t return what I
expect.-->
<h3 class="subsection" id="sec248">A.3.3&#X2003;I&#X2019;ve got a function that doesn&#X2019;t return what I
expect.</h3><!--SEC END --><p>
<a id="hevea_default1800"></a>
<a id="hevea_default1801"></a></p><p>If you have a <span class="c004">return</span> statement with a complex expression,
you don&#X2019;t have a chance to print the result before
returning. Again, you can use a temporary variable. For
example, instead of:</p><pre class="verbatim">return self.hands[i].removeMatches()
</pre><p>
you could write:</p><pre class="verbatim">count = self.hands[i].removeMatches()
return count
</pre><p>
Now you have the opportunity to display the value of
<span class="c004">count</span> before returning.</p>
<!--TOC subsection id="sec249" I&#X2019;m really, really stuck and I need help.-->
<h3 class="subsection" id="sec249">A.3.4&#X2003;I&#X2019;m really, really stuck and I need help.</h3><!--SEC END --><p>First, try getting away from the computer for a few minutes.
Computers emit waves that affect the brain, causing these
symptoms:</p><ul class="itemize"><li class="li-itemize">Frustration and rage.
<a id="hevea_default1802"></a>
<a id="hevea_default1803"></a>
<a id="hevea_default1804"></a>
<a id="hevea_default1805"></a></li><li class="li-itemize">Superstitious beliefs (&#X201C;the computer hates me&#X201D;) and
magical thinking (&#X201C;the program only works when I wear my
hat backward&#X201D;).
<a id="hevea_default1806"></a>
<a id="hevea_default1807"></a></li><li class="li-itemize">Random walk programming (the attempt to program by writing
every possible program and choosing the one that does the right
thing).
<a id="hevea_default1808"></a>
<a id="hevea_default1809"></a></li></ul><p>If you find yourself suffering from any of these symptoms, get
up and go for a walk. When you are calm, think about the program.
What is it doing? What are some possible causes of that
behavior? When was the last time you had a working program,
and what did you do next?</p><p>Sometimes it just takes time to find a bug. I often find bugs
when I am away from the computer and let my mind wander. Some
of the best places to find bugs are trains, showers, and in bed,
just before you fall asleep.</p>
<!--TOC subsection id="sec250" No, I really need help.-->
<h3 class="subsection" id="sec250">A.3.5&#X2003;No, I really need help.</h3><!--SEC END --><p>It happens. Even the best programmers occasionally get stuck.
Sometimes you work on a program so long that you can&#X2019;t see the
error. You need a fresh pair of eyes.</p><p>Before you bring someone else in, make sure you are prepared.
Your program should be as simple
as possible, and you should be working on the smallest input
that causes the error. You should have <span class="c004">print</span> statements in the
appropriate places (and the output they produce should be
comprehensible). You should understand the problem well enough
to describe it concisely.</p><p>When you bring someone in to help, be sure to give
them the information they need:</p><ul class="itemize"><li class="li-itemize">If there is an error message, what is it
and what part of the program does it indicate?</li><li class="li-itemize">What was the last thing you did before this error occurred?
What were the last lines of code that you wrote, or what is
the new test case that fails?</li><li class="li-itemize">What have you tried so far, and what have you learned?</li></ul><p>When you find the bug, take a second to think about what you
could have done to find it faster. Next time you see something
similar, you will be able to find the bug more quickly.</p><p>Remember, the goal is not just to make the program
work. The goal is to learn how to make the program work.</p>
<!--TOC chapter id="sec251" Analysis of Algorithms-->
<h1 class="chapter" id="sec251">Appendix&#XA0;B&#X2003;Analysis of Algorithms</h1><!--SEC END --><p>
<a id="algorithms"></a></p><blockquote class="quote">
This appendix is an edited excerpt from <span class="c009">Think Complexity</span>, by
Allen B. Downey, also published by O&#X2019;Reilly Media (2012). When you
are done with this book, you might want to move on to that one.
</blockquote><p><span class="c010">Analysis of algorithms</span> is a branch of computer science that
studies the performance of algorithms, especially their run time and
space requirements. See
<a href="http://en.wikipedia.org/wiki/Analysis_of_algorithms"><span class="c004">http://en.wikipedia.org/wiki/Analysis_of_algorithms</span></a>.
<a id="hevea_default1810"></a> <a id="hevea_default1811"></a></p><p>The practical goal of algorithm analysis is to predict the performance
of different algorithms in order to guide design decisions.</p><p>During the 2008 United States Presidential Campaign, candidate
Barack Obama was asked to perform an impromptu analysis when
he visited Google. Chief executive Eric Schmidt jokingly asked him
for &#X201C;the most efficient way to sort a million 32-bit integers.&#X201D;
Obama had apparently been tipped off, because he quickly
replied, &#X201C;I think the bubble sort would be the wrong way to go.&#X201D;
See <a href="http://www.youtube.com/watch?v=k4RRi_ntQc8"><span class="c004">http://www.youtube.com/watch?v=k4RRi_ntQc8</span></a>.
<a id="hevea_default1812"></a>
<a id="hevea_default1813"></a>
<a id="hevea_default1814"></a></p><p>This is true: bubble sort is conceptually simple but slow for
large datasets. The answer Schmidt was probably looking for is
&#X201C;radix sort&#X201D; (<a href="http://en.wikipedia.org/wiki/Radix_sort"><span class="c004">http://en.wikipedia.org/wiki/Radix_sort</span></a>)<sup><a id="text2" href="#note2">1</a></sup>.
<a id="hevea_default1815"></a></p><p>The goal of algorithm analysis is to make meaningful
comparisons between algorithms, but there are some problems:
<a id="hevea_default1816"></a></p><ul class="itemize"><li class="li-itemize">The relative performance of the algorithms might
depend on characteristics of the hardware, so one algorithm
might be faster on Machine A, another on Machine B.
The general solution to this problem is to specify a
<span class="c010">machine model</span> and analyze the number of steps, or
operations, an algorithm requires under a given model.
<a id="hevea_default1817"></a></li><li class="li-itemize">Relative performance might depend on the details of
the dataset. For example, some sorting
algorithms run faster if the data are already partially sorted;
other algorithms run slower in this case.
A common way to avoid this problem is to analyze the
<span class="c010">worst case</span> scenario. It is sometimes useful to
analyze average case performance, but that&#X2019;s usually harder,
and it might not be obvious what set of cases to average over.
<a id="hevea_default1818"></a>
<a id="hevea_default1819"></a></li><li class="li-itemize">Relative performance also depends on the size of the
problem. A sorting algorithm that is fast for small lists
might be slow for long lists.
The usual solution to this problem is to express run time
(or number of operations) as a function of problem size,
and group functions into categories depending on how quickly
they grow as problem size increases.</li></ul><p>The good thing about this kind of comparison is that it lends
itself to simple classification of algorithms. For example,
if I know that the run time of Algorithm A tends to be
proportional to the size of the input, <span class="c009">n</span>, and Algorithm B
tends to be proportional to <span class="c009">n</span><sup>2</sup>, then I
expect A to be faster than B, at least for large values of <span class="c009">n</span>.</p><p>This kind of analysis comes with some caveats, but we&#X2019;ll get
to that later.</p>
<!--TOC section id="sec252" Order of growth-->
<h2 class="section" id="sec252">B.1&#X2003;Order of growth</h2><!--SEC END --><p>Suppose you have analyzed two algorithms and expressed
their run times in terms of the size of the input:
Algorithm A takes 100<span class="c009">n</span>+1 steps to solve a problem with
size <span class="c009">n</span>; Algorithm B takes <span class="c009">n</span><sup>2</sup> + <span class="c009">n</span> + 1 steps.
<a id="hevea_default1820"></a></p><p>The following table shows the run time of these algorithms
for different problem sizes:</p><table class="c000 cellpadding1" border=1><tr><td class="c014">Input</td><td class="c014">Run time of</td><td class="c014">Run time of </td></tr>
<tr><td class="c014">size</td><td class="c014">Algorithm A</td><td class="c014">Algorithm B </td></tr>
<tr><td class="c014">10</td><td class="c014">1 001</td><td class="c014">111 </td></tr>
<tr><td class="c014">100</td><td class="c014">10 001</td><td class="c014">10 101 </td></tr>
<tr><td class="c014">1 000</td><td class="c014">100 001</td><td class="c014">1 001 001 </td></tr>
<tr><td class="c014">10 000</td><td class="c014">1 000 001</td><td class="c014">100 010 001 </td></tr>
</table><p>At <span class="c009">n</span>=10, Algorithm A looks pretty bad; it takes almost 10 times
longer than Algorithm B. But for <span class="c009">n</span>=100 they are about the same, and
for larger values A is much better.</p><p>The fundamental reason is that for large values of <span class="c009">n</span>, any function
that contains an <span class="c009">n</span><sup>2</sup> term will grow faster than a function whose
leading term is <span class="c009">n</span>. The <span class="c010">leading term</span> is the term with the
highest exponent.
<a id="hevea_default1821"></a>
<a id="hevea_default1822"></a></p><p>For Algorithm A, the leading term has a large coefficient, 100, which
is why B does better than A for small <span class="c009">n</span>. But regardless of the
coefficients, there will always be some value of <span class="c009">n</span> where
<span class="c009">a n</span><sup>2</sup> &gt; <span class="c009">b n</span>, for any values of <span class="c009">a</span> and <span class="c009">b</span>.
<a id="hevea_default1823"></a></p><p>The same argument applies to the non-leading terms. Even if the run
time of Algorithm A were <span class="c009">n</span>+1000000, it would still be better than
Algorithm B for sufficiently large <span class="c009">n</span>.</p><p>In general, we expect an algorithm with a smaller leading term to be a
better algorithm for large problems, but for smaller problems, there
may be a <span class="c010">crossover point</span> where another algorithm is better. The
location of the crossover point depends on the details of the
algorithms, the inputs, and the hardware, so it is usually ignored for
purposes of algorithmic analysis. But that doesn&#X2019;t mean you can forget
about it.
<a id="hevea_default1824"></a></p><p>If two algorithms have the same leading order term, it is hard to say
which is better; again, the answer depends on the details. So for
algorithmic analysis, functions with the same leading term
are considered equivalent, even if they have different coefficients.</p><p>An <span class="c010">order of growth</span> is a set of functions whose growth
behavior is considered equivalent. For example, 2<span class="c009">n</span>, 100<span class="c009">n</span> and <span class="c009">n</span>+1
belong to the same order of growth, which is written <span class="c009">O</span>(<span class="c009">n</span>) in
<span class="c010">Big-Oh notation</span> and often called <span class="c010">linear</span> because every function
in the set grows linearly with <span class="c009">n</span>.
<a id="hevea_default1825"></a>
<a id="hevea_default1826"></a></p><p>All functions with the leading term <span class="c009">n</span><sup>2</sup> belong to <span class="c009">O</span>(<span class="c009">n</span><sup>2</sup>); they are
called <span class="c010">quadratic</span>.
<a id="hevea_default1827"></a></p><p>The following table shows some of the orders of growth that
appear most commonly in algorithmic analysis,
in increasing order of badness.
<a id="hevea_default1828"></a></p><table class="c000 cellpadding1" border=1><tr><td class="c014">Order of</td><td class="c014">Name </td></tr>
<tr><td class="c014">growth</td><td class="c014">&nbsp;</td></tr>
<tr><td class="c014"><span class="c009">O</span>(1)</td><td class="c014">constant </td></tr>
<tr><td class="c014"><span class="c009">O</span>(log<sub><span class="c009">b</span></sub> <span class="c009">n</span>)</td><td class="c014">logarithmic (for any <span class="c009">b</span>) </td></tr>
<tr><td class="c014"><span class="c009">O</span>(<span class="c009">n</span>)</td><td class="c014">linear </td></tr>
<tr><td class="c014"><span class="c009">O</span>(<span class="c009">n</span> log<sub><span class="c009">b</span></sub> <span class="c009">n</span>)</td><td class="c014">linearithmic </td></tr>
<tr><td class="c014"><span class="c009">O</span>(<span class="c009">n</span><sup>2</sup>)</td><td class="c014">quadratic </td></tr>
<tr><td class="c014"><span class="c009">O</span>(<span class="c009">n</span><sup>3</sup>)</td><td class="c014">cubic </td></tr>
<tr><td class="c014"><span class="c009">O</span>(<span class="c009">c</span><sup><span class="c009">n</span></sup>)</td><td class="c014">exponential (for any <span class="c009">c</span>) </td></tr>
</table><p>For the logarithmic terms, the base of the logarithm doesn&#X2019;t matter;
changing bases is the equivalent of multiplying by a constant, which
doesn&#X2019;t change the order of growth. Similarly, all exponential
functions belong to the same order of growth regardless of the base of
the exponent.
Exponential functions grow very quickly, so exponential algorithms are
only useful for small problems.
<a id="hevea_default1829"></a>
<a id="hevea_default1830"></a></p><div class="theorem"><span class="c010">Exercise&#XA0;1</span>&#X2003;<p><em>Read the Wikipedia page on Big-Oh notation at
</em><a href="http://en.wikipedia.org/wiki/Big_O_notation"><em><span class="c004">http://en.wikipedia.org/wiki/Big_O_notation</span></em></a><em> and
answer the following questions:</em></p><ol class="enumerate" type=1><li class="li-enumerate">
<em>What is the order of growth of </em><span class="c009">n</span><sup>3</sup> + <span class="c009">n</span><sup>2</sup><em>?
What about </em>1000000 <span class="c009">n</span><sup>3</sup> + <span class="c009">n</span><sup>2</sup><em>?
What about </em><span class="c009">n</span><sup>3</sup> + 1000000 <span class="c009">n</span><sup>2</sup><em>?</em></li><li class="li-enumerate"><em>What is the order of growth of </em>(<span class="c009">n</span><sup>2</sup> + <span class="c009">n</span>) &#XB7; (<span class="c009">n</span> + 1)<em>? Before
you start multiplying, remember that you only need the leading term.</em></li><li class="li-enumerate"><em>If </em><span class="c009">f</span><em> is in </em><span class="c009">O</span>(<span class="c009">g</span>)<em>, for some unspecified function </em><span class="c009">g</span><em>, what can
we say about </em><span class="c009">af</span>+<span class="c009">b</span><em>, where </em><span class="c009">a</span><em> and </em><span class="c009">b</span><em> are constants?</em></li><li class="li-enumerate"><em>If </em><span class="c009">f</span><sub>1</sub><em> and </em><span class="c009">f</span><sub>2</sub><em> are in </em><span class="c009">O</span>(<span class="c009">g</span>)<em>, what can we say about </em><span class="c009">f</span><sub>1</sub> + <span class="c009">f</span><sub>2</sub><em>?</em></li><li class="li-enumerate"><em>If </em><span class="c009">f</span><sub>1</sub><em> is in </em><span class="c009">O</span>(<span class="c009">g</span>)<em>
and </em><span class="c009">f</span><sub>2</sub><em> is in </em><span class="c009">O</span>(<span class="c009">h</span>)<em>,
what can we say about </em><span class="c009">f</span><sub>1</sub> + <span class="c009">f</span><sub>2</sub><em>?</em></li><li class="li-enumerate"><em>If </em><span class="c009">f</span><sub>1</sub><em> is in </em><span class="c009">O</span>(<span class="c009">g</span>)<em> and </em><span class="c009">f</span><sub>2</sub><em> is </em><span class="c009">O</span>(<span class="c009">h</span>)<em>,
what can we say about </em><span class="c009">f</span><sub>1</sub> &#XB7; <span class="c009">f</span><sub>2</sub><em>?
</em></li></ol></div><p>Programmers who care about performance often find this kind of
analysis hard to swallow. They have a point: sometimes the
coefficients and the non-leading terms make a real difference.
Sometimes the details of the hardware, the programming language, and
the characteristics of the input make a big difference. And for small
problems, order of growth is irrelevant.</p><p>But if you keep those caveats in mind, algorithmic analysis is a
useful tool. At least for large problems, the &#X201C;better&#X201D; algorithm
is usually better, and sometimes it is <em>much</em> better. The
difference between two algorithms with the same order of growth is
usually a constant factor, but the difference between a good algorithm
and a bad algorithm is unbounded!</p>
<!--TOC section id="sec253" Analysis of basic Python operations-->
<h2 class="section" id="sec253">B.2&#X2003;Analysis of basic Python operations</h2><!--SEC END --><p>In Python, most arithmetic operations are constant time;
multiplication usually takes longer than addition and subtraction, and
division takes even longer, but these run times don&#X2019;t depend on the
magnitude of the operands. Very large integers are an exception; in
that case the run time increases with the number of digits.
<a id="hevea_default1831"></a></p><p>Indexing operations&#X2014;reading or writing elements in a sequence
or dictionary&#X2014;are also constant time, regardless of the size
of the data structure.
<a id="hevea_default1832"></a></p><p>A <span class="c004">for</span> loop that traverses a sequence or dictionary is
usually linear, as long as all of the operations in the body
of the loop are constant time. For example, adding up the
elements of a list is linear:</p><pre class="verbatim">    total = 0
    for x in t:
        total += x
</pre><p>The built-in function <span class="c004">sum</span> is also linear because it does
the same thing, but it tends to be faster because it is a more
efficient implementation; in the language of algorithmic analysis,
it has a smaller leading coefficient.</p><p>As a rule of thumb, if the body of a loop is in <span class="c009">O</span>(<span class="c009">n</span><sup><span class="c009">a</span></sup>) then
the whole loop is in <span class="c009">O</span>(<span class="c009">n</span><sup><span class="c009">a</span>+1</sup>). The exception is if you can
show that the loop exits after a constant number of iterations.
If a loop runs <span class="c009">k</span> times regardless of <span class="c009">n</span>, then
the loop is in <span class="c009">O</span>(<span class="c009">n</span><sup><span class="c009">a</span></sup>), even for large <span class="c009">k</span>.</p><p>Multiplying by <span class="c009">k</span> doesn&#X2019;t change the order of growth, but neither
does dividing. So if the body of a loop is in <span class="c009">O</span>(<span class="c009">n</span><sup><span class="c009">a</span></sup>) and it runs
<span class="c009">n</span>/<span class="c009">k</span> times, the loop is in <span class="c009">O</span>(<span class="c009">n</span><sup><span class="c009">a</span>+1</sup>), even for large <span class="c009">k</span>.</p><p>Most string and tuple operations are linear, except indexing and <span class="c004">len</span>, which are constant time. The built-in functions <span class="c004">min</span> and
<span class="c004">max</span> are linear. The run-time of a slice operation is
proportional to the length of the output, but independent of the size
of the input.
<a id="hevea_default1833"></a>
<a id="hevea_default1834"></a></p><p>String concatenation is linear; the run time depends on the sum
of the lengths of the operands.
<a id="hevea_default1835"></a></p><p>All string methods are linear, but if the lengths of
the strings are bounded by a constant&#X2014;for example, operations on single
characters&#X2014;they are considered constant time.
The string method <span class="c004">join</span> is linear; the run time depends on
the total length of the strings.
<a id="hevea_default1836"></a></p><p>Most list methods are linear, but there are some exceptions:
<a id="hevea_default1837"></a></p><ul class="itemize"><li class="li-itemize">Adding an element to the end of a list is constant time on
average; when it runs out of room it occasionally gets copied
to a bigger location, but the total time for <span class="c009">n</span> operations
is <span class="c009">O</span>(<span class="c009">n</span>), so the average time for each
operation is <span class="c009">O</span>(1).</li><li class="li-itemize">Removing an element from the end of a list is constant time.</li><li class="li-itemize">Sorting is <span class="c009">O</span>(<span class="c009">n</span> log<span class="c009">n</span>).
<a id="hevea_default1838"></a></li></ul><p>Most dictionary operations and methods are constant time, but
there are some exceptions:
<a id="hevea_default1839"></a></p><ul class="itemize"><li class="li-itemize">The run time of <span class="c004">update</span> is
proportional to the size of the dictionary passed as a parameter,
not the dictionary being updated.</li><li class="li-itemize"><span class="c004">keys</span>, <span class="c004">values</span> and <span class="c004">items</span> are constant time because
they return iterators. But
if you loop through the iterators, the loop will be linear.
<a id="hevea_default1840"></a></li></ul><p>The performance of dictionaries is one of the minor miracles of
computer science. We will see how they work in
Section&#XA0;<a href="#hashtable">B.4</a>.</p><div class="theorem"><span class="c010">Exercise&#XA0;2</span>&#X2003;<p><em>Read the Wikipedia page on sorting algorithms at
</em><a href="http://en.wikipedia.org/wiki/Sorting_algorithm"><em><span class="c004">http://en.wikipedia.org/wiki/Sorting_algorithm</span></em></a><em> and answer
the following questions:
</em><a id="hevea_default1841"></a></p><ol class="enumerate" type=1><li class="li-enumerate"><em>What is a &#X201C;comparison sort?&#X201D; What is the best worst-case order
of growth for a comparison sort? What is the best worst-case order
of growth for any sort algorithm?
</em><a id="hevea_default1842"></a></li><li class="li-enumerate"><em>What is the order of growth of bubble sort, and why does Barack
Obama think it is &#X201C;the wrong way to go?&#X201D;</em></li><li class="li-enumerate"><em>What is the order of growth of radix sort? What preconditions
do we need to use it?</em></li><li class="li-enumerate"><em>What is a stable sort and why might it matter in practice?
</em><a id="hevea_default1843"></a></li><li class="li-enumerate"><em>What is the worst sorting algorithm (that has a name)?</em></li><li class="li-enumerate"><em>What sort algorithm does the C library use? What sort algorithm
does Python use? Are these algorithms stable? You might have to
Google around to find these answers.</em></li><li class="li-enumerate"><em>Many of the non-comparison sorts are linear, so why does
Python use an </em><span class="c009">O</span>(<span class="c009">n</span> log<span class="c009">n</span>)<em> comparison sort?</em></li></ol></div>
<!--TOC section id="sec254" Analysis of search algorithms-->
<h2 class="section" id="sec254">B.3&#X2003;Analysis of search algorithms</h2><!--SEC END --><p>A <span class="c010">search</span> is an algorithm that takes a collection and a target
item and determines whether the target is in the collection, often
returning the index of the target.
<a id="hevea_default1844"></a></p><p>The simplest search algorithm is a &#X201C;linear search&#X201D;, which traverses
the items of the collection in order, stopping if it finds the target.
In the worst case it has to traverse the entire collection, so the run
time is linear.
<a id="hevea_default1845"></a></p><p>The <span class="c004">in</span> operator for sequences uses a linear search; so do string
methods like <span class="c004">find</span> and <span class="c004">count</span>.
<a id="hevea_default1846"></a></p><p>If the elements of the sequence are in order, you can use a <span class="c010">bisection search</span>, which is <span class="c009">O</span>(log<span class="c009">n</span>). Bisection search is
similar to the algorithm you might use to look a word up in a
dictionary (a paper dictionary, not the data structure). Instead of
starting at the beginning and checking each item in order, you start
with the item in the middle and check whether the word you are looking
for comes before or after. If it comes before, then you search the
first half of the sequence. Otherwise you search the second half.
Either way, you cut the number of remaining items in half.
<a id="hevea_default1847"></a></p><p>If the sequence has 1,000,000 items, it will take about 20 steps to
find the word or conclude that it&#X2019;s not there. So that&#X2019;s about 50,000
times faster than a linear search.</p><p>Bisection search can be much faster than linear search, but
it requires the sequence to be in order, which might require
extra work.</p><p>There is another data structure, called a <span class="c010">hashtable</span> that
is even faster&#X2014;it can do a search in constant time&#X2014;and it
doesn&#X2019;t require the items to be sorted. Python dictionaries
are implemented using hashtables, which is why most dictionary
operations, including the <span class="c004">in</span> operator, are constant time.</p>
<!--TOC section id="sec255" Hashtables-->
<h2 class="section" id="sec255">B.4&#X2003;Hashtables</h2><!--SEC END --><p>
<a id="hashtable"></a></p><p>To explain how hashtables work and why their performance is so
good, I start with a simple implementation of a map and
gradually improve it until it&#X2019;s a hashtable.
<a id="hevea_default1848"></a></p><p>I use Python to demonstrate these implementations, but in real
life you wouldn&#X2019;t write code like this in Python; you would just use a
dictionary! So for the rest of this chapter, you have to imagine that
dictionaries don&#X2019;t exist and you want to implement a data structure
that maps from keys to values. The operations you have to
implement are:</p><dl class="description"><dt class="dt-description"><span class="c010"><span class="c004">add(k, v)</span>:</span></dt><dd class="dd-description"> Add a new item that maps from key <span class="c004">k</span>
to value <span class="c004">v</span>. With a Python dictionary, <span class="c004">d</span>, this operation
is written <span class="c004">d[k] = v</span>.</dd><dt class="dt-description"><span class="c010"><span class="c004">get(k)</span>:</span></dt><dd class="dd-description"> Look up and return the value that corresponds
to key <span class="c004">k</span>. With a Python dictionary, <span class="c004">d</span>, this operation
is written <span class="c004">d[k]</span> or <span class="c004">d.get(k)</span>.</dd></dl><p>For now, I assume that each key only appears once.
The simplest implementation of this interface uses a list of
tuples, where each tuple is a key-value pair.
<a id="hevea_default1849"></a></p><pre class="verbatim">class LinearMap:

    def __init__(self):
        self.items = []

    def add(self, k, v):
        self.items.append((k, v))

    def get(self, k):
        for key, val in self.items:
            if key == k:
                return val
        raise KeyError
</pre><p><span class="c004">add</span> appends a key-value tuple to the list of items, which
takes constant time.</p><p><span class="c004">get</span> uses a <span class="c004">for</span> loop to search the list:
if it finds the target key it returns the corresponding value;
otherwise it raises a <span class="c004">KeyError</span>.
So <span class="c004">get</span> is linear.
<a id="hevea_default1850"></a></p><p>An alternative is to keep the list sorted by key. Then <span class="c004">get</span>
could use a bisection search, which is <span class="c009">O</span>(log<span class="c009">n</span>). But inserting a
new item in the middle of a list is linear, so this might not be the
best option. There are other data structures that can implement <span class="c004">add</span> and <span class="c004">get</span> in log time, but that&#X2019;s still not as good as
constant time, so let&#X2019;s move on.
<a id="hevea_default1851"></a></p><p>One way to improve <span class="c004">LinearMap</span> is to break the list of key-value
pairs into smaller lists. Here&#X2019;s an implementation called
<span class="c004">BetterMap</span>, which is a list of 100 LinearMaps. As we&#X2019;ll see
in a second, the order of growth for <span class="c004">get</span> is still linear,
but <span class="c004">BetterMap</span> is a step on the path toward hashtables:
<a id="hevea_default1852"></a></p><pre class="verbatim">class BetterMap:

    def __init__(self, n=100):
        self.maps = []
        for i in range(n):
            self.maps.append(LinearMap())

    def find_map(self, k):
        index = hash(k) % len(self.maps)
        return self.maps[index]

    def add(self, k, v):
        m = self.find_map(k)
        m.add(k, v)

    def get(self, k):
        m = self.find_map(k)
        return m.get(k)
</pre><p><code class="verb">__init__</code> makes a list of <span class="c004">n</span> <span class="c004">LinearMap</span>s.</p><p><code class="verb">find_map</code> is used by
<span class="c004">add</span> and <span class="c004">get</span>
to figure out which map to put the
new item in, or which map to search.</p><p><code class="verb">find_map</code> uses the built-in function <span class="c004">hash</span>, which takes
almost any Python object and returns an integer. A limitation of this
implementation is that it only works with hashable keys. Mutable
types like lists and dictionaries are unhashable.
<a id="hevea_default1853"></a></p><p>Hashable objects that are considered equivalent return the same hash
value, but the converse is not necessarily true: two objects with
different values can return the same hash value.</p><p><code class="verb">find_map</code> uses the modulus operator to wrap the hash values
into the range from 0 to <span class="c004">len(self.maps)</span>, so the result is a legal
index into the list. Of course, this means that many different
hash values will wrap onto the same index. But if the hash function
spreads things out pretty evenly (which is what hash functions
are designed to do), then we expect <span class="c009">n</span>/100 items per LinearMap.</p><p>Since the run time of <span class="c004">LinearMap.get</span> is proportional to the
number of items, we expect BetterMap to be about 100 times faster
than LinearMap. The order of growth is still linear, but the
leading coefficient is smaller. That&#X2019;s nice, but still not
as good as a hashtable.</p><p>Here (finally) is the crucial idea that makes hashtables fast: if you
can keep the maximum length of the LinearMaps bounded, <span class="c004">LinearMap.get</span> is constant time. All you have to do is keep track
of the number of items and when the number of
items per LinearMap exceeds a threshold, resize the hashtable by
adding more LinearMaps.
<a id="hevea_default1854"></a></p><p>Here is an implementation of a hashtable:
<a id="hevea_default1855"></a></p><pre class="verbatim">class HashMap:

    def __init__(self):
        self.maps = BetterMap(2)
        self.num = 0

    def get(self, k):
        return self.maps.get(k)

    def add(self, k, v):
        if self.num == len(self.maps.maps):
            self.resize()

        self.maps.add(k, v)
        self.num += 1

    def resize(self):
        new_maps = BetterMap(self.num * 2)

        for m in self.maps.maps:
            for k, v in m.items:
                new_maps.add(k, v)

        self.maps = new_maps
</pre><p><code class="verb">__init__</code> creates a <span class="c004">BetterMap</span> and initializes <span class="c004">num</span>, which keeps track of the number of items.</p><p><span class="c004">get</span> just dispatches to <span class="c004">BetterMap</span>. The real work happens
in <span class="c004">add</span>, which checks the number of items and the size of the
<span class="c004">BetterMap</span>: if they are equal, the average number of items per
LinearMap is 1, so it calls <span class="c004">resize</span>.</p><p><span class="c004">resize</span> makes a new <span class="c004">BetterMap</span>, twice as big as the previous
one, and then &#X201C;rehashes&#X201D; the items from the old map to the new.</p><p>Rehashing is necessary because changing the number of LinearMaps
changes the denominator of the modulus operator in
<code class="verb">find_map</code>. That means that some objects that used
to hash into the same LinearMap will get split up (which is
what we wanted, right?).
<a id="hevea_default1856"></a></p><p>Rehashing is linear, so
<span class="c004">resize</span> is linear, which might seem bad, since I promised
that <span class="c004">add</span> would be constant time. But remember that
we don&#X2019;t have to resize every time, so <span class="c004">add</span> is usually
constant time and only occasionally linear. The total amount
of work to run <span class="c004">add</span> <span class="c009">n</span> times is proportional to <span class="c009">n</span>,
so the average time of each <span class="c004">add</span> is constant time!
<a id="hevea_default1857"></a></p><p>To see how this works, think about starting with an empty
HashTable and adding a sequence of items. We start with 2 LinearMaps,
so the first 2 adds are fast (no resizing required). Let&#X2019;s
say that they take one unit of work each. The next add
requires a resize, so we have to rehash the first two
items (let&#X2019;s call that 2 more units of work) and then
add the third item (one more unit). Adding the next item
costs 1 unit, so the total so far is
6 units of work for 4 items.</p><p>The next <span class="c004">add</span> costs 5 units, but the next three
are only one unit each, so the total is 14 units for the
first 8 adds.</p><p>The next <span class="c004">add</span> costs 9 units, but then we can add 7 more
before the next resize, so the total is 30 units for the
first 16 adds.</p><p>After 32 adds, the total cost is 62 units, and I hope you are starting
to see a pattern. After <span class="c009">n</span> adds, where <span class="c009">n</span> is a power of two, the
total cost is 2<span class="c009">n</span>&#X2212;2 units, so the average work per add is
a little less than 2 units. When <span class="c009">n</span> is a power of two, that&#X2019;s
the best case; for other values of <span class="c009">n</span> the average work is a little
higher, but that&#X2019;s not important. The important thing is that it
is <span class="c009">O</span>(1).
<a id="hevea_default1858"></a></p><p>Figure&#XA0;<a href="#fig.hash">B.1</a> shows how this works graphically. Each
block represents a unit of work. The columns show the total
work for each add in order from left to right: the first two
<span class="c004">adds</span> cost 1 unit each, the third costs 3 units, etc.</p><blockquote class="figure"><div class="center"><hr class="floatrule"></div>
<div class="center"><img src="thinkpython2026.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure B.1: The cost of a hashtable add.<a id="fig.hash"></a></td></tr>
</table></div>
<div class="center"><hr class="floatrule"></div></blockquote><p>The extra work of rehashing appears as a sequence of increasingly
tall towers with increasing space between them. Now if you knock
over the towers, spreading the cost of resizing over all
adds, you can see graphically that the total cost after <span class="c009">n</span>
adds is 2<span class="c009">n</span> &#X2212; 2.</p><p>An important feature of this algorithm is that when we resize the
HashTable it grows geometrically; that is, we multiply the size by a
constant. If you increase the size
arithmetically&#X2014;adding a fixed number each time&#X2014;the average time
per <span class="c004">add</span> is linear.
<a id="hevea_default1859"></a></p><p>You can download my implementation of HashMap from
<a href="https://thinkpython.com/code/Map.py"><span class="c004">https://thinkpython.com/code/Map.py</span></a>, but remember that there
is no reason to use it; if you want a map, just use a Python dictionary.</p>
<!--TOC section id="sec256" Glossary-->
<h2 class="section" id="sec256">B.5&#X2003;Glossary</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c010">analysis of algorithms:</span></dt><dd class="dd-description"> A way to compare algorithms in terms of
their run time and/or space requirements.
<a id="hevea_default1860"></a></dd><dt class="dt-description"><span class="c010">machine model:</span></dt><dd class="dd-description"> A simplified representation of a computer used
to describe algorithms.
<a id="hevea_default1861"></a></dd><dt class="dt-description"><span class="c010">worst case:</span></dt><dd class="dd-description"> The input that makes a given algorithm run slowest (or
require the most space).
<a id="hevea_default1862"></a></dd><dt class="dt-description"><span class="c010">leading term:</span></dt><dd class="dd-description"> In a polynomial, the term with the highest exponent.
<a id="hevea_default1863"></a></dd><dt class="dt-description"><span class="c010">crossover point:</span></dt><dd class="dd-description"> The problem size where two algorithms require
the same run time or space.
<a id="hevea_default1864"></a></dd><dt class="dt-description"><span class="c010">order of growth:</span></dt><dd class="dd-description"> A set of functions that all grow in a way
considered equivalent for purposes of analysis of algorithms.
For example, all functions that grow linearly belong to the same
order of growth.
<a id="hevea_default1865"></a></dd><dt class="dt-description"><span class="c010">Big-Oh notation:</span></dt><dd class="dd-description"> Notation for representing an order of growth;
for example, <span class="c009">O</span>(<span class="c009">n</span>) represents the set of functions that grow
linearly.
<a id="hevea_default1866"></a></dd><dt class="dt-description"><span class="c010">linear:</span></dt><dd class="dd-description"> An algorithm whose run time is proportional to
problem size, at least for large problem sizes.
<a id="hevea_default1867"></a></dd><dt class="dt-description"><span class="c010">quadratic:</span></dt><dd class="dd-description"> An algorithm whose run time is proportional to
<span class="c009">n</span><sup>2</sup>, where <span class="c009">n</span> is a measure of problem size.
<a id="hevea_default1868"></a></dd><dt class="dt-description"><span class="c010">search:</span></dt><dd class="dd-description"> The problem of locating an element of a collection
(like a list or dictionary) or determining that it is not present.
<a id="hevea_default1869"></a></dd><dt class="dt-description"><span class="c010">hashtable:</span></dt><dd class="dd-description"> A data structure that represents a collection of
key-value pairs and performs search in constant time.
<a id="hevea_default1870"></a></dd></dl><p><a id="section@the@hevea@index@default"></a></p><!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes"><a id="note2" href="#text2">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">
But if you get a question like this in an interview, I think
a better answer is, &#X201C;The fastest way to sort a million integers
is to use whatever sort function is provided by the language
I&#X2019;m using. Its performance is good enough for the vast majority
of applications, but if it turned out that my application was too
slow, I would use a profiler to see where the time was being
spent. If it looked like a faster sort algorithm would have
a significant effect on performance, then I would look
around for a good implementation of radix sort.&#X201D;</div></dd></dl>
<!--END NOTES-->
<!--TOC chapter id="sec257" Index-->
<h1 class="chapter" id="sec257">Index</h1><!--SEC END --><div class="theindex"><table class="c001 cellpading0"><tr><td class="c018">
<ul class="indexenv"><li class="li-indexenv">Ackermann function, <a href="#hevea_default488">6.11</a>, <a href="#hevea_default997">11.10</a>
</li><li class="li-indexenv">Archimedian spiral, <a href="#hevea_default311">4.12</a>
</li><li class="li-indexenv">AttributeError, <a href="#hevea_default1388">15.7</a>, <a href="#hevea_default1779">A.2.3</a>
</li><li class="li-indexenv">Austen, Jane, <a href="#hevea_default1162">13.3</a>
</li><li class="li-indexenv">abecedarian, <a href="#hevea_default567">8.3</a>, <a href="#hevea_default662">9.2</a>
</li><li class="li-indexenv">abs function, <a href="#hevea_default427">6.1</a>
</li><li class="li-indexenv">absolute path, <a href="#hevea_default1237">14.4</a>, <a href="#hevea_default1310">14.11</a>
</li><li class="li-indexenv">access, <a href="#hevea_default709">10.2</a>
</li><li class="li-indexenv">accumulator, <a href="#hevea_default846">10.14</a>
<ul class="indexenv"><li class="li-indexenv">histogram, <a href="#hevea_default1163">13.3</a>
</li><li class="li-indexenv">list, <a href="#hevea_default775">10.7</a>
</li><li class="li-indexenv">string, <a href="#hevea_default1592">18.5</a>
</li><li class="li-indexenv">sum, <a href="#hevea_default771">10.7</a>
</li></ul>
</li><li class="li-indexenv">add method, <a href="#hevea_default1500">17.7</a>
</li><li class="li-indexenv">addition with carrying, <a href="#hevea_default523">7.6</a>
</li><li class="li-indexenv">algorithm, <a href="#hevea_default522">7.6</a>, <a href="#hevea_default536">7.8</a>, <a href="#hevea_default1178">13.7</a>, <a href="#hevea_default1810">B</a>
<ul class="indexenv"><li class="li-indexenv">MD5, <a href="#hevea_default1323">14.12</a>
</li><li class="li-indexenv">square root, <a href="#hevea_default537">7.9</a>
</li></ul>
</li><li class="li-indexenv">aliasing, <a href="#hevea_default807">10.10</a>, <a href="#hevea_default816">10.11</a>, <a href="#hevea_default860">10.14</a>, <a href="#hevea_default1352">15.2</a>, <a href="#hevea_default1366">15.6</a>, <a href="#hevea_default1545">17.13</a>
<ul class="indexenv"><li class="li-indexenv">copying to avoid, <a href="#hevea_default839">10.13</a>
</li></ul>
</li><li class="li-indexenv">all, <a href="#hevea_default1691">19.4</a>
</li><li class="li-indexenv">alphabet, <a href="#hevea_default307">4.12</a>
</li><li class="li-indexenv">alternative execution, <a href="#hevea_default350">5.5</a>
</li><li class="li-indexenv">ambiguity, <a href="#hevea_default53">1.6</a>
</li><li class="li-indexenv">anagram, <a href="#hevea_default863">10.15</a>
</li><li class="li-indexenv">anagram set, <a href="#hevea_default1124">12.10</a>, <a href="#hevea_default1318">14.12</a>
</li><li class="li-indexenv">analysis of algorithms, <a href="#hevea_default1811">B</a>, <a href="#hevea_default1860">B.5</a>
</li><li class="li-indexenv">analysis of primitives, <a href="#hevea_default1831">B.2</a>
</li><li class="li-indexenv">and operator, <a href="#hevea_default334">5.3</a>
</li><li class="li-indexenv">any, <a href="#hevea_default1685">19.4</a>
</li><li class="li-indexenv">append method, <a href="#hevea_default757">10.6</a>, <a href="#hevea_default830">10.12</a>, <a href="#hevea_default871">10.15</a>, <a href="#hevea_default1588">18.4</a>, <a href="#hevea_default1599">18.6</a>
</li><li class="li-indexenv">arc function, <a href="#hevea_default271">4.3</a>
</li><li class="li-indexenv">argument, <a href="#hevea_default149">3.1</a>, <a href="#hevea_default181">3.4</a>, <a href="#hevea_default195">3.7</a>, <a href="#hevea_default201">3.7</a>, <a href="#hevea_default239">3.13</a>, <a href="#hevea_default824">10.12</a>
<ul class="indexenv"><li class="li-indexenv">gather, <a href="#hevea_default1053">12.4</a>
</li><li class="li-indexenv">keyword, <a href="#hevea_default277">4.5</a>, <a href="#hevea_default297">4.11</a>, <a href="#hevea_default1722">19.9</a>
</li><li class="li-indexenv">list, <a href="#hevea_default825">10.12</a>
</li><li class="li-indexenv">optional, <a href="#hevea_default604">8.8</a>, <a href="#hevea_default633">8.12</a>, <a href="#hevea_default637">8.13</a>, <a href="#hevea_default798">10.9</a>, <a href="#hevea_default932">11.4</a>, <a href="#hevea_default1667">19.1</a>
</li><li class="li-indexenv">positional, <a href="#hevea_default1482">17.3</a>, <a href="#hevea_default1534">17.12</a>, <a href="#hevea_default1720">19.9</a>
</li><li class="li-indexenv">variable-length tuple, <a href="#hevea_default1050">12.4</a>
</li></ul>
</li><li class="li-indexenv">argument scatter, <a href="#hevea_default1055">12.4</a>
</li><li class="li-indexenv">arithmetic operator, <a href="#hevea_default27">1.4</a>
</li><li class="li-indexenv">assert statement, <a href="#hevea_default1447">16.5</a>, <a href="#hevea_default1455">16.6</a>
</li><li class="li-indexenv">assignment, <a href="#hevea_default127">2.9</a>, <a href="#hevea_default493">7.1</a>, <a href="#hevea_default707">10.1</a>
<ul class="indexenv"><li class="li-indexenv">augmented, <a href="#hevea_default769">10.7</a>, <a href="#hevea_default847">10.14</a>
</li><li class="li-indexenv">item, <a href="#hevea_default585">8.5</a>, <a href="#hevea_default719">10.2</a>, <a href="#hevea_default1026">12.1</a>
</li><li class="li-indexenv">tuple, <a href="#hevea_default1030">12.2</a>, <a href="#hevea_default1044">12.3</a>, <a href="#hevea_default1070">12.5</a>, <a href="#hevea_default1114">12.9</a>
</li></ul>
</li><li class="li-indexenv">assignment statement, <a href="#hevea_default89">2.1</a>
</li><li class="li-indexenv">attribute, <a href="#hevea_default1395">15.7</a>, <a href="#hevea_default1528">17.11</a>
<ul class="indexenv"><li class="li-indexenv">__dict__, <a href="#hevea_default1519">17.10</a>
</li><li class="li-indexenv">class, <a href="#hevea_default1562">18.2</a>, <a href="#hevea_default1643">18.11</a>
</li><li class="li-indexenv">initializing, <a href="#hevea_default1515">17.10</a>
</li><li class="li-indexenv">instance, <a href="#hevea_default1345">15.2</a>, <a href="#hevea_default1405">15.8</a>, <a href="#hevea_default1564">18.2</a>, <a href="#hevea_default1645">18.11</a>
</li></ul>
</li><li class="li-indexenv">augmented assignment, <a href="#hevea_default770">10.7</a>, <a href="#hevea_default848">10.14</a>
</li><li class="li-indexenv">average case, <a href="#hevea_default1819">B</a>
</li><li class="li-indexenv">average cost, <a href="#hevea_default1858">B.4</a>
<br>
</li><li class="li-indexenv"><span class="c004">BetterMap</span>, <a href="#hevea_default1852">B.4</a>
</li><li class="li-indexenv">Big-Oh notation, <a href="#hevea_default1866">B.5</a>
</li><li class="li-indexenv">badness, <a href="#hevea_default1828">B.1</a>
</li><li class="li-indexenv">base case, <a href="#hevea_default371">5.9</a>, <a href="#hevea_default413">5.13</a>
</li><li class="li-indexenv">benchmarking, <a href="#hevea_default1189">13.9</a>, <a href="#hevea_default1201">13.11</a>
</li><li class="li-indexenv">big, hairy expression, <a href="#hevea_default1795">A.3.2</a>
</li><li class="li-indexenv">big-oh notation, <a href="#hevea_default1825">B.1</a>
</li><li class="li-indexenv">binary search, <a href="#hevea_default881">10.15</a>
</li><li class="li-indexenv">bingo, <a href="#hevea_default1127">12.10</a>
</li><li class="li-indexenv">birthday, <a href="#hevea_default1460">16.7</a>
</li><li class="li-indexenv">birthday paradox, <a href="#hevea_default866">10.15</a>
</li><li class="li-indexenv">bisect module, <a href="#hevea_default883">10.15</a>
</li><li class="li-indexenv">bisection search, <a href="#hevea_default878">10.15</a>, <a href="#hevea_default1847">B.3</a>
</li><li class="li-indexenv">bisection, debugging by, <a href="#hevea_default528">7.7</a>
</li><li class="li-indexenv">bitwise operator, <a href="#hevea_default28">1.4</a>
</li><li class="li-indexenv">body, <a href="#hevea_default184">3.4</a>, <a href="#hevea_default236">3.13</a>, <a href="#hevea_default511">7.3</a>
</li><li class="li-indexenv">bool type, <a href="#hevea_default328">5.2</a>
</li><li class="li-indexenv">boolean expression, <a href="#hevea_default320">5.2</a>, <a href="#hevea_default401">5.13</a>
</li><li class="li-indexenv">boolean function, <a href="#hevea_default442">6.4</a>
</li><li class="li-indexenv">boolean operator, <a href="#hevea_default607">8.9</a>
</li><li class="li-indexenv">borrowing, subtraction with, <a href="#hevea_default526">7.6</a>, <a href="#hevea_default1441">16.4</a>
</li><li class="li-indexenv">bounded, <a href="#hevea_default1854">B.4</a>
</li><li class="li-indexenv">bracket<ul class="indexenv"><li class="li-indexenv">squiggly, <a href="#hevea_default897">11.1</a>
</li></ul>
</li><li class="li-indexenv">bracket operator, <a href="#hevea_default546">8.1</a>, <a href="#hevea_default711">10.2</a>, <a href="#hevea_default1017">12.1</a>
</li><li class="li-indexenv">branch, <a href="#hevea_default353">5.5</a>, <a href="#hevea_default407">5.13</a>
</li><li class="li-indexenv">break statement, <a href="#hevea_default515">7.4</a>
</li><li class="li-indexenv">bubble sort, <a href="#hevea_default1814">B</a>
</li><li class="li-indexenv">bug, <a href="#hevea_default60">1.7</a>, <a href="#hevea_default83">1.8</a>, <a href="#hevea_default113">2.8</a>
<ul class="indexenv"><li class="li-indexenv">worst, <a href="#hevea_default1542">17.13</a>
</li></ul>
</li><li class="li-indexenv">built-in function<ul class="indexenv"><li class="li-indexenv">any, <a href="#hevea_default1686">19.4</a>, <a href="#hevea_default1692">19.4</a>
</li></ul>
</li><li class="li-indexenv">bytes object, <a href="#hevea_default1260">14.6</a>, <a href="#hevea_default1313">14.11</a>
<br>
</li><li class="li-indexenv">Car Talk, <a href="#hevea_default688">9.7</a>, <a href="#hevea_default691">9.7</a>, <a href="#hevea_default695">9.7</a>, <a href="#hevea_default1002">11.10</a>, <a href="#hevea_default1129">12.10</a>
</li><li class="li-indexenv">Card class, <a href="#hevea_default1557">18.1</a>
</li><li class="li-indexenv">Collatz conjecture, <a href="#hevea_default514">7.3</a>
</li><li class="li-indexenv">Counter, <a href="#hevea_default1699">19.6</a>
</li><li class="li-indexenv">Creative Commons, <a href="#hevea_default8">0</a>
</li><li class="li-indexenv">calculator, <a href="#hevea_default86">1.9</a>, <a href="#hevea_default144">2.10</a>
</li><li class="li-indexenv">call graph, <a href="#hevea_default947">11.6</a>, <a href="#hevea_default985">11.9</a>
</li><li class="li-indexenv">card, playing, <a href="#hevea_default1549">18</a>
</li><li class="li-indexenv">carrying, addition with, <a href="#hevea_default524">7.6</a>, <a href="#hevea_default1426">16.2</a>, <a href="#hevea_default1437">16.4</a>
</li><li class="li-indexenv">catch, <a href="#hevea_default1311">14.11</a>
</li><li class="li-indexenv">chained conditional, <a href="#hevea_default354">5.6</a>, <a href="#hevea_default408">5.13</a>
</li><li class="li-indexenv">character, <a href="#hevea_default545">8.1</a>
</li><li class="li-indexenv">checksum, <a href="#hevea_default1283">14.8</a>, <a href="#hevea_default1324">14.12</a>
</li><li class="li-indexenv">child class, <a href="#hevea_default1616">18.7</a>, <a href="#hevea_default1649">18.11</a>
</li><li class="li-indexenv">choice function, <a href="#hevea_default1158">13.2</a>
</li><li class="li-indexenv">circle function, <a href="#hevea_default269">4.3</a>
</li><li class="li-indexenv">circular definition, <a href="#hevea_default451">6.5</a>
</li><li class="li-indexenv">class, <a href="#hevea_default35">1.5</a>, <a href="#hevea_default1332">15.1</a>, <a href="#hevea_default1398">15.8</a>
<ul class="indexenv"><li class="li-indexenv">Card, <a href="#hevea_default1558">18.1</a>
</li><li class="li-indexenv">child, <a href="#hevea_default1617">18.7</a>, <a href="#hevea_default1650">18.11</a>
</li><li class="li-indexenv">Deck, <a href="#hevea_default1587">18.4</a>
</li><li class="li-indexenv">Hand, <a href="#hevea_default1614">18.7</a>
</li><li class="li-indexenv">Kangaroo, <a href="#hevea_default1544">17.13</a>
</li><li class="li-indexenv">Point, <a href="#hevea_default1337">15.1</a>, <a href="#hevea_default1492">17.5</a>
</li><li class="li-indexenv">parent, <a href="#hevea_default1612">18.7</a>
</li><li class="li-indexenv">Rectangle, <a href="#hevea_default1355">15.3</a>
</li><li class="li-indexenv">Time, <a href="#hevea_default1416">16.1</a>
</li></ul>
</li><li class="li-indexenv">class attribute, <a href="#hevea_default1561">18.2</a>, <a href="#hevea_default1642">18.11</a>
</li><li class="li-indexenv">class definition, <a href="#hevea_default1334">15.1</a>
</li><li class="li-indexenv">class diagram, <a href="#hevea_default1624">18.8</a>, <a href="#hevea_default1654">18.11</a>
</li><li class="li-indexenv">class object, <a href="#hevea_default1340">15.1</a>, <a href="#hevea_default1401">15.8</a>, <a href="#hevea_default1715">19.8</a>
</li><li class="li-indexenv">close method, <a href="#hevea_default1217">14.2</a>, <a href="#hevea_default1263">14.6</a>, <a href="#hevea_default1280">14.8</a>
</li><li class="li-indexenv">__cmp__ method, <a href="#hevea_default1576">18.3</a>
</li><li class="li-indexenv">collections, <a href="#hevea_default1702">19.6</a>, <a href="#hevea_default1706">19.7</a>, <a href="#hevea_default1713">19.8</a>
</li><li class="li-indexenv">colon, <a href="#hevea_default186">3.4</a>, <a href="#hevea_default1744">A.1</a>
</li><li class="li-indexenv">comment, <a href="#hevea_default111">2.7</a>, <a href="#hevea_default139">2.9</a>
</li><li class="li-indexenv">commutativity, <a href="#hevea_default110">2.6</a>, <a href="#hevea_default1507">17.8</a>
</li><li class="li-indexenv">compare function, <a href="#hevea_default429">6.1</a>
</li><li class="li-indexenv">comparing algorithms, <a href="#hevea_default1816">B</a>
</li><li class="li-indexenv">comparison<ul class="indexenv"><li class="li-indexenv">string, <a href="#hevea_default610">8.10</a>
</li><li class="li-indexenv">tuple, <a href="#hevea_default1027">12.1</a>, <a href="#hevea_default1579">18.3</a>
</li></ul>
</li><li class="li-indexenv">comparison sort, <a href="#hevea_default1842">B.2</a>
</li><li class="li-indexenv">composition, <a href="#hevea_default173">3.3</a>, <a href="#hevea_default198">3.7</a>, <a href="#hevea_default251">3.13</a>, <a href="#hevea_default439">6.3</a>, <a href="#hevea_default1584">18.4</a>
</li><li class="li-indexenv">compound statement, <a href="#hevea_default346">5.4</a>, <a href="#hevea_default406">5.13</a>
</li><li class="li-indexenv">concatenation, <a href="#hevea_default109">2.6</a>, <a href="#hevea_default138">2.9</a>, <a href="#hevea_default205">3.8</a>, <a href="#hevea_default566">8.3</a>, <a href="#hevea_default587">8.5</a>, <a href="#hevea_default802">10.9</a>
<ul class="indexenv"><li class="li-indexenv">list, <a href="#hevea_default740">10.4</a>, <a href="#hevea_default833">10.12</a>, <a href="#hevea_default874">10.15</a>
</li></ul>
</li><li class="li-indexenv">condition, <a href="#hevea_default345">5.4</a>, <a href="#hevea_default405">5.13</a>, <a href="#hevea_default509">7.3</a>, <a href="#hevea_default1759">A.2.2</a>
</li><li class="li-indexenv">conditional, <a href="#hevea_default1748">A.1</a>
<ul class="indexenv"><li class="li-indexenv">chained, <a href="#hevea_default355">5.6</a>, <a href="#hevea_default409">5.13</a>
</li><li class="li-indexenv">nested, <a href="#hevea_default359">5.7</a>, <a href="#hevea_default411">5.13</a>
</li></ul>
</li><li class="li-indexenv">conditional execution, <a href="#hevea_default344">5.4</a>
</li><li class="li-indexenv">conditional expression, <a href="#hevea_default1660">19.1</a>, <a href="#hevea_default1724">19.10</a>
</li><li class="li-indexenv">conditional statement, <a href="#hevea_default340">5.4</a>, <a href="#hevea_default403">5.13</a>, <a href="#hevea_default443">6.4</a>, <a href="#hevea_default1668">19.1</a>
</li><li class="li-indexenv">consistency check, <a href="#hevea_default965">11.8</a>, <a href="#hevea_default1439">16.4</a>
</li><li class="li-indexenv">constant time, <a href="#hevea_default1857">B.4</a>
</li><li class="li-indexenv">contributors, <a href="#hevea_default9">0</a>
</li><li class="li-indexenv">conversion<ul class="indexenv"><li class="li-indexenv">type, <a href="#hevea_default151">3.1</a>
</li></ul>
</li><li class="li-indexenv">copy<ul class="indexenv"><li class="li-indexenv">deep, <a href="#hevea_default1383">15.6</a>
</li><li class="li-indexenv">shallow, <a href="#hevea_default1381">15.6</a>
</li><li class="li-indexenv">slice, <a href="#hevea_default575">8.4</a>, <a href="#hevea_default751">10.5</a>
</li><li class="li-indexenv">to avoid aliasing, <a href="#hevea_default840">10.13</a>
</li></ul>
</li><li class="li-indexenv">copy module, <a href="#hevea_default1369">15.6</a>
</li><li class="li-indexenv">copying objects, <a href="#hevea_default1367">15.6</a>
</li><li class="li-indexenv">count method, <a href="#hevea_default638">8.13</a>
</li><li class="li-indexenv">counter, <a href="#hevea_default593">8.7</a>, <a href="#hevea_default630">8.12</a>, <a href="#hevea_default907">11.2</a>, <a href="#hevea_default961">11.7</a>
</li><li class="li-indexenv">counting and looping, <a href="#hevea_default594">8.7</a>
</li><li class="li-indexenv">crossover point, <a href="#hevea_default1824">B.1</a>, <a href="#hevea_default1864">B.5</a>
</li><li class="li-indexenv">crosswords, <a href="#hevea_default647">9.1</a>
</li><li class="li-indexenv">cumulative sum, <a href="#hevea_default862">10.15</a>
<br>
</li><li class="li-indexenv">Deck class, <a href="#hevea_default1586">18.4</a>
</li><li class="li-indexenv">Dijkstra, Edsger, <a href="#hevea_default682">9.5</a>
</li><li class="li-indexenv">Double Day, <a href="#hevea_default1461">16.7</a>
</li><li class="li-indexenv">Doyle, Arthur Conan, <a href="#hevea_default230">3.12</a>
</li><li class="li-indexenv">data encapsulation, <a href="#hevea_default1639">18.10</a>, <a href="#hevea_default1657">18.11</a>
</li><li class="li-indexenv">data structure, <a href="#hevea_default1107">12.8</a>, <a href="#hevea_default1120">12.9</a>, <a href="#hevea_default1186">13.9</a>
</li><li class="li-indexenv">database, <a href="#hevea_default1252">14.6</a>, <a href="#hevea_default1312">14.11</a>
</li><li class="li-indexenv">database object, <a href="#hevea_default1257">14.6</a>
</li><li class="li-indexenv">datetime module, <a href="#hevea_default1458">16.7</a>
</li><li class="li-indexenv">dbm
module, <a href="#hevea_default1253">14.6</a>
</li><li class="li-indexenv">dead code, <a href="#hevea_default424">6.1</a>, <a href="#hevea_default482">6.10</a>, <a href="#hevea_default1787">A.2.4</a>
</li><li class="li-indexenv">debugger (pdb), <a href="#hevea_default1783">A.2.3</a>
</li><li class="li-indexenv">debugging, <a href="#hevea_default58">1.7</a>, <a href="#hevea_default59">1.7</a>, <a href="#hevea_default84">1.8</a>, <a href="#hevea_default112">2.8</a>, <a href="#hevea_default288">4.10</a>, <a href="#hevea_default388">5.12</a>, <a href="#hevea_default476">6.9</a>, <a href="#hevea_default611">8.11</a>, <a href="#hevea_default677">9.5</a>, <a href="#hevea_default836">10.13</a>, <a href="#hevea_default963">11.8</a>, <a href="#hevea_default1106">12.8</a>, <a href="#hevea_default1192">13.10</a>, <a href="#hevea_default1295">14.10</a>, <a href="#hevea_default1386">15.7</a>, <a href="#hevea_default1443">16.5</a>, <a href="#hevea_default1513">17.10</a>, <a href="#hevea_default1627">18.9</a>, <a href="#hevea_default1676">19.2</a>, <a href="#hevea_default1730">A</a>
<ul class="indexenv"><li class="li-indexenv">by bisection, <a href="#hevea_default527">7.7</a>
</li><li class="li-indexenv">emotional response, <a href="#hevea_default61">1.7</a>, <a href="#hevea_default1804">A.3.4</a>
</li><li class="li-indexenv">experimental, <a href="#hevea_default228">3.12</a>
</li><li class="li-indexenv">rubber duck, <a href="#hevea_default1203">13.11</a>
</li><li class="li-indexenv">superstition, <a href="#hevea_default1806">A.3.4</a>
</li></ul>
</li><li class="li-indexenv">deck, <a href="#hevea_default1548">18</a>
</li><li class="li-indexenv">deck, playing cards, <a href="#hevea_default1581">18.4</a>
</li><li class="li-indexenv">declaration, <a href="#hevea_default956">11.7</a>, <a href="#hevea_default992">11.9</a>
</li><li class="li-indexenv">decrement, <a href="#hevea_default503">7.2</a>, <a href="#hevea_default533">7.8</a>
</li><li class="li-indexenv">deep copy, <a href="#hevea_default1382">15.6</a>, <a href="#hevea_default1410">15.8</a>
</li><li class="li-indexenv">deepcopy function, <a href="#hevea_default1384">15.6</a>
</li><li class="li-indexenv">def keyword, <a href="#hevea_default179">3.4</a>
</li><li class="li-indexenv">default value, <a href="#hevea_default1170">13.5</a>, <a href="#hevea_default1199">13.11</a>, <a href="#hevea_default1489">17.5</a>
<ul class="indexenv"><li class="li-indexenv">avoiding mutable, <a href="#hevea_default1539">17.13</a>
</li></ul>
</li><li class="li-indexenv">defaultdict, <a href="#hevea_default1704">19.7</a>
</li><li class="li-indexenv">definition<ul class="indexenv"><li class="li-indexenv">circular, <a href="#hevea_default452">6.5</a>
</li><li class="li-indexenv">class, <a href="#hevea_default1335">15.1</a>
</li><li class="li-indexenv">function, <a href="#hevea_default178">3.4</a>
</li><li class="li-indexenv">recursive, <a href="#hevea_default1134">12.10</a>
</li></ul>
</li><li class="li-indexenv">del operator, <a href="#hevea_default784">10.8</a>
</li><li class="li-indexenv">deletion, element of list, <a href="#hevea_default781">10.8</a>
</li><li class="li-indexenv">delimiter, <a href="#hevea_default799">10.9</a>, <a href="#hevea_default861">10.14</a>
</li><li class="li-indexenv">designed development, <a href="#hevea_default1450">16.6</a>
</li><li class="li-indexenv">deterministic, <a href="#hevea_default1150">13.2</a>, <a href="#hevea_default1197">13.11</a>
</li><li class="li-indexenv">development plan, <a href="#hevea_default300">4.11</a>
<ul class="indexenv"><li class="li-indexenv">data encapsulation, <a href="#hevea_default1638">18.10</a>, <a href="#hevea_default1658">18.11</a>
</li><li class="li-indexenv">designed, <a href="#hevea_default1435">16.4</a>
</li><li class="li-indexenv">encapsulation and generalization, <a href="#hevea_default281">4.8</a>
</li><li class="li-indexenv">incremental, <a href="#hevea_default431">6.2</a>, <a href="#hevea_default1740">A.1</a>
</li><li class="li-indexenv">prototype and patch, <a href="#hevea_default1422">16.2</a>, <a href="#hevea_default1433">16.4</a>
</li><li class="li-indexenv">random walk programming, <a href="#hevea_default1196">13.10</a>, <a href="#hevea_default1809">A.3.4</a>
</li><li class="li-indexenv">reduction, <a href="#hevea_default671">9.3</a>, <a href="#hevea_default676">9.4</a>, <a href="#hevea_default686">9.6</a>
</li></ul>
</li><li class="li-indexenv">diagram<ul class="indexenv"><li class="li-indexenv">call graph, <a href="#hevea_default986">11.9</a>
</li><li class="li-indexenv">class, <a href="#hevea_default1625">18.8</a>, <a href="#hevea_default1655">18.11</a>
</li><li class="li-indexenv">object, <a href="#hevea_default1350">15.2</a>, <a href="#hevea_default1359">15.3</a>, <a href="#hevea_default1379">15.6</a>, <a href="#hevea_default1412">15.8</a>, <a href="#hevea_default1420">16.1</a>, <a href="#hevea_default1569">18.2</a>
</li><li class="li-indexenv">stack, <a href="#hevea_default213">3.9</a>, <a href="#hevea_default829">10.12</a>
</li><li class="li-indexenv">state, <a href="#hevea_default92">2.1</a>, <a href="#hevea_default497">7.1</a>, <a href="#hevea_default619">8.11</a>, <a href="#hevea_default717">10.2</a>, <a href="#hevea_default811">10.10</a>, <a href="#hevea_default819">10.11</a>, <a href="#hevea_default937">11.5</a>, <a href="#hevea_default1094">12.6</a>, <a href="#hevea_default1348">15.2</a>, <a href="#hevea_default1357">15.3</a>, <a href="#hevea_default1377">15.6</a>, <a href="#hevea_default1418">16.1</a>, <a href="#hevea_default1567">18.2</a>
</li></ul>
</li><li class="li-indexenv">__dict__ attribute, <a href="#hevea_default1518">17.10</a>
</li><li class="li-indexenv">dict function, <a href="#hevea_default894">11.1</a>
</li><li class="li-indexenv">dictionary, <a href="#hevea_default887">11.1</a>, <a href="#hevea_default888">11.1</a>, <a href="#hevea_default971">11.9</a>, <a href="#hevea_default1079">12.6</a>, <a href="#hevea_default1776">A.2.3</a>
<ul class="indexenv"><li class="li-indexenv">initialize, <a href="#hevea_default1084">12.6</a>
</li><li class="li-indexenv">invert, <a href="#hevea_default934">11.5</a>
</li><li class="li-indexenv">lookup, <a href="#hevea_default920">11.4</a>
</li><li class="li-indexenv">looping with, <a href="#hevea_default915">11.3</a>
</li><li class="li-indexenv">reverse lookup, <a href="#hevea_default921">11.4</a>
</li><li class="li-indexenv">subtraction, <a href="#hevea_default1173">13.6</a>
</li><li class="li-indexenv">traversal, <a href="#hevea_default1089">12.6</a>, <a href="#hevea_default1521">17.10</a>
</li></ul>
</li><li class="li-indexenv">dictionary methods, <a href="#hevea_default1839">B.2</a>
<ul class="indexenv"><li class="li-indexenv">dbm module, <a href="#hevea_default1262">14.6</a>
</li></ul>
</li><li class="li-indexenv">dictionary subtraction, <a href="#hevea_default1693">19.5</a>
</li><li class="li-indexenv">diff, <a href="#hevea_default1326">14.12</a>
</li><li class="li-indexenv">dir function, <a href="#hevea_default1777">A.2.3</a>
</li><li class="li-indexenv">directory, <a href="#hevea_default1227">14.4</a>, <a href="#hevea_default1307">14.11</a>
<ul class="indexenv"><li class="li-indexenv">walk, <a href="#hevea_default1242">14.4</a>
</li><li class="li-indexenv">working, <a href="#hevea_default1234">14.4</a>
</li></ul>
</li><li class="li-indexenv">dispatch<ul class="indexenv"><li class="li-indexenv">type-based, <a href="#hevea_default1511">17.9</a>
</li></ul>
</li><li class="li-indexenv">dispatch, type-based, <a href="#hevea_default1506">17.8</a>
</li><li class="li-indexenv">divisibility, <a href="#hevea_default318">5.1</a>
</li><li class="li-indexenv">division<ul class="indexenv"><li class="li-indexenv">floating-point, <a href="#hevea_default315">5.1</a>
</li><li class="li-indexenv">floor, <a href="#hevea_default314">5.1</a>, <a href="#hevea_default396">5.12</a>, <a href="#hevea_default398">5.13</a>
</li></ul>
</li><li class="li-indexenv">divmod, <a href="#hevea_default1042">12.3</a>, <a href="#hevea_default1438">16.4</a>
</li><li class="li-indexenv">docstring, <a href="#hevea_default282">4.9</a>, <a href="#hevea_default301">4.11</a>, <a href="#hevea_default1338">15.1</a>
</li><li class="li-indexenv">dot notation, <a href="#hevea_default163">3.2</a>, <a href="#hevea_default250">3.13</a>, <a href="#hevea_default601">8.8</a>, <a href="#hevea_default1346">15.2</a>, <a href="#hevea_default1472">17.2</a>, <a href="#hevea_default1565">18.2</a>
</li><li class="li-indexenv">double letters, <a href="#hevea_default690">9.7</a>
</li><li class="li-indexenv">duplicate, <a href="#hevea_default864">10.15</a>, <a href="#hevea_default999">11.10</a>, <a href="#hevea_default1321">14.12</a>, <a href="#hevea_default1697">19.5</a>
<br>
</li><li class="li-indexenv">Elkner, Jeff, <a href="#hevea_default2">0</a>, <a href="#hevea_default4">0</a>
</li><li class="li-indexenv">element, <a href="#hevea_default700">10.1</a>, <a href="#hevea_default844">10.14</a>
</li><li class="li-indexenv">element deletion, <a href="#hevea_default780">10.8</a>
</li><li class="li-indexenv">elif keyword, <a href="#hevea_default356">5.6</a>
</li><li class="li-indexenv">ellipses, <a href="#hevea_default187">3.4</a>
</li><li class="li-indexenv">else keyword, <a href="#hevea_default351">5.5</a>
</li><li class="li-indexenv">email address, <a href="#hevea_default1037">12.2</a>
</li><li class="li-indexenv">embedded object, <a href="#hevea_default1360">15.3</a>, <a href="#hevea_default1407">15.8</a>, <a href="#hevea_default1546">17.13</a>
<ul class="indexenv"><li class="li-indexenv">copying, <a href="#hevea_default1375">15.6</a>
</li></ul>
</li><li class="li-indexenv">emotional debugging, <a href="#hevea_default62">1.7</a>, <a href="#hevea_default1805">A.3.4</a>
</li><li class="li-indexenv">empty list, <a href="#hevea_default705">10.1</a>
</li><li class="li-indexenv">empty string, <a href="#hevea_default625">8.12</a>, <a href="#hevea_default803">10.9</a>
</li><li class="li-indexenv">encapsulation, <a href="#hevea_default273">4.4</a>, <a href="#hevea_default294">4.11</a>, <a href="#hevea_default441">6.3</a>, <a href="#hevea_default538">7.9</a>, <a href="#hevea_default597">8.7</a>, <a href="#hevea_default1621">18.7</a>
</li><li class="li-indexenv">encode, <a href="#hevea_default1553">18.1</a>, <a href="#hevea_default1641">18.11</a>
</li><li class="li-indexenv">encrypt, <a href="#hevea_default1554">18.1</a>
</li><li class="li-indexenv">end of line character, <a href="#hevea_default1300">14.10</a>
</li><li class="li-indexenv">enumerate function, <a href="#hevea_default1074">12.5</a>
</li><li class="li-indexenv">enumerate object, <a href="#hevea_default1078">12.5</a>
</li><li class="li-indexenv">epsilon, <a href="#hevea_default521">7.5</a>
</li><li class="li-indexenv">equality and assignment, <a href="#hevea_default498">7.1</a>
</li><li class="li-indexenv">equivalence, <a href="#hevea_default812">10.10</a>, <a href="#hevea_default1374">15.6</a>
</li><li class="li-indexenv">equivalent, <a href="#hevea_default857">10.14</a>
</li><li class="li-indexenv">error<ul class="indexenv"><li class="li-indexenv">runtime, <a href="#hevea_default119">2.8</a>, <a href="#hevea_default376">5.10</a>, <a href="#hevea_default391">5.12</a>, <a href="#hevea_default1734">A</a>
</li><li class="li-indexenv">semantic, <a href="#hevea_default124">2.8</a>, <a href="#hevea_default1737">A</a>, <a href="#hevea_default1791">A.3</a>
</li><li class="li-indexenv">shape, <a href="#hevea_default1109">12.8</a>
</li><li class="li-indexenv">syntax, <a href="#hevea_default115">2.8</a>, <a href="#hevea_default1732">A</a>
</li></ul>
</li><li class="li-indexenv">error checking, <a href="#hevea_default466">6.8</a>
</li><li class="li-indexenv">error message, <a href="#hevea_default85">1.9</a>, <a href="#hevea_default116">2.8</a>, <a href="#hevea_default125">2.8</a>, <a href="#hevea_default1738">A.1</a>
</li><li class="li-indexenv">eval function, <a href="#hevea_default539">7.9</a>
</li><li class="li-indexenv">evaluate, <a href="#hevea_default97">2.3</a>
</li><li class="li-indexenv">exception, <a href="#hevea_default120">2.8</a>, <a href="#hevea_default141">2.9</a>, <a href="#hevea_default1735">A</a>, <a href="#hevea_default1764">A.2.3</a>
<ul class="indexenv"><li class="li-indexenv">AttributeError, <a href="#hevea_default1387">15.7</a>, <a href="#hevea_default1780">A.2.3</a>
</li><li class="li-indexenv">FileNotFoundError, <a href="#hevea_default1245">14.5</a>
</li><li class="li-indexenv">IndexError, <a href="#hevea_default556">8.2</a>, <a href="#hevea_default617">8.11</a>, <a href="#hevea_default721">10.2</a>, <a href="#hevea_default1782">A.2.3</a>
</li><li class="li-indexenv">KeyError, <a href="#hevea_default898">11.1</a>, <a href="#hevea_default1775">A.2.3</a>
</li><li class="li-indexenv">LookupError, <a href="#hevea_default928">11.4</a>
</li><li class="li-indexenv">NameError, <a href="#hevea_default207">3.8</a>, <a href="#hevea_default1768">A.2.3</a>
</li><li class="li-indexenv">OverflowError, <a href="#hevea_default393">5.12</a>
</li><li class="li-indexenv">RuntimeError, <a href="#hevea_default378">5.10</a>
</li><li class="li-indexenv">StopIteration, <a href="#hevea_default1682">19.3</a>
</li><li class="li-indexenv">SyntaxError, <a href="#hevea_default175">3.3</a>
</li><li class="li-indexenv">TypeError, <a href="#hevea_default552">8.1</a>, <a href="#hevea_default581">8.5</a>, <a href="#hevea_default939">11.5</a>, <a href="#hevea_default1023">12.1</a>, <a href="#hevea_default1057">12.4</a>, <a href="#hevea_default1223">14.3</a>, <a href="#hevea_default1479">17.3</a>, <a href="#hevea_default1770">A.2.3</a>
</li><li class="li-indexenv">UnboundLocalError, <a href="#hevea_default960">11.7</a>
</li><li class="li-indexenv">ValueError, <a href="#hevea_default387">5.11</a>, <a href="#hevea_default1033">12.2</a>
</li></ul>
</li><li class="li-indexenv">exception, catching, <a href="#hevea_default1249">14.5</a>
</li><li class="li-indexenv">execute, <a href="#hevea_default99">2.3</a>, <a href="#hevea_default133">2.9</a>
</li><li class="li-indexenv">exists function, <a href="#hevea_default1239">14.4</a>
</li><li class="li-indexenv">experimental debugging, <a href="#hevea_default227">3.12</a>, <a href="#hevea_default1194">13.10</a>
</li><li class="li-indexenv">exponent, <a href="#hevea_default1822">B.1</a>
</li><li class="li-indexenv">exponential growth, <a href="#hevea_default1830">B.1</a>
</li><li class="li-indexenv">expression, <a href="#hevea_default96">2.3</a>, <a href="#hevea_default131">2.9</a>
<ul class="indexenv"><li class="li-indexenv">big and hairy, <a href="#hevea_default1794">A.3.2</a>
</li><li class="li-indexenv">boolean, <a href="#hevea_default321">5.2</a>, <a href="#hevea_default402">5.13</a>
</li><li class="li-indexenv">conditional, <a href="#hevea_default1661">19.1</a>, <a href="#hevea_default1725">19.10</a>
</li><li class="li-indexenv">generator, <a href="#hevea_default1678">19.3</a>, <a href="#hevea_default1688">19.4</a>, <a href="#hevea_default1728">19.10</a>
</li></ul>
</li><li class="li-indexenv">extend method, <a href="#hevea_default759">10.6</a>
<br>
</li><li class="li-indexenv">False special value, <a href="#hevea_default325">5.2</a>
</li><li class="li-indexenv">Fermat&#X2019;s Last Theorem, <a href="#hevea_default415">5.14</a>
</li><li class="li-indexenv">FileNotFoundError, <a href="#hevea_default1246">14.5</a>
</li><li class="li-indexenv">Free Documentation License, GNU, <a href="#hevea_default1">0</a>, <a href="#hevea_default7">0</a>
</li><li class="li-indexenv">factorial, <a href="#hevea_default1664">19.1</a>
</li><li class="li-indexenv">factorial function, <a href="#hevea_default453">6.5</a>, <a href="#hevea_default467">6.8</a>
</li><li class="li-indexenv">factory, <a href="#hevea_default1729">19.10</a>
</li><li class="li-indexenv">factory function, <a href="#hevea_default1708">19.7</a>, <a href="#hevea_default1710">19.7</a>
</li><li class="li-indexenv">fibonacci function, <a href="#hevea_default462">6.7</a>, <a href="#hevea_default943">11.6</a>
</li><li class="li-indexenv">file, <a href="#hevea_default1209">14.1</a>
<ul class="indexenv"><li class="li-indexenv">permission, <a href="#hevea_default1247">14.5</a>
</li><li class="li-indexenv">reading and writing, <a href="#hevea_default1214">14.2</a>
</li></ul>
</li><li class="li-indexenv">file object, <a href="#hevea_default653">9.1</a>, <a href="#hevea_default683">9.6</a>
</li><li class="li-indexenv">filename, <a href="#hevea_default1225">14.4</a>
</li><li class="li-indexenv">filter pattern, <a href="#hevea_default778">10.7</a>, <a href="#hevea_default854">10.14</a>, <a href="#hevea_default1674">19.2</a>
</li><li class="li-indexenv">find function, <a href="#hevea_default588">8.6</a>
</li><li class="li-indexenv">flag, <a href="#hevea_default951">11.7</a>, <a href="#hevea_default991">11.9</a>
</li><li class="li-indexenv">float function, <a href="#hevea_default155">3.1</a>
</li><li class="li-indexenv">float type, <a href="#hevea_default41">1.5</a>
</li><li class="li-indexenv">floating-point, <a href="#hevea_default34">1.5</a>, <a href="#hevea_default76">1.8</a>, <a href="#hevea_default520">7.5</a>, <a href="#hevea_default1663">19.1</a>
</li><li class="li-indexenv">floating-point division, <a href="#hevea_default313">5.1</a>
</li><li class="li-indexenv">floor division, <a href="#hevea_default312">5.1</a>, <a href="#hevea_default395">5.12</a>, <a href="#hevea_default397">5.13</a>
</li><li class="li-indexenv">flow of execution, <a href="#hevea_default192">3.6</a>, <a href="#hevea_default252">3.13</a>, <a href="#hevea_default464">6.7</a>, <a href="#hevea_default479">6.9</a>, <a href="#hevea_default508">7.3</a>, <a href="#hevea_default1629">18.9</a>, <a href="#hevea_default1763">A.2.2</a>
</li><li class="li-indexenv">flower, <a href="#hevea_default305">4.12</a>
</li><li class="li-indexenv">folder, <a href="#hevea_default1228">14.4</a>
</li><li class="li-indexenv">for loop, <a href="#hevea_default263">4.2</a>, <a href="#hevea_default366">5.8</a>, <a href="#hevea_default562">8.3</a>, <a href="#hevea_default730">10.3</a>, <a href="#hevea_default1072">12.5</a>, <a href="#hevea_default1672">19.2</a>
</li><li class="li-indexenv">formal language, <a href="#hevea_default45">1.6</a>, <a href="#hevea_default79">1.8</a>
</li><li class="li-indexenv">format operator, <a href="#hevea_default1219">14.3</a>, <a href="#hevea_default1302">14.11</a>, <a href="#hevea_default1772">A.2.3</a>
</li><li class="li-indexenv">format sequence, <a href="#hevea_default1222">14.3</a>, <a href="#hevea_default1305">14.11</a>
</li><li class="li-indexenv">format string, <a href="#hevea_default1221">14.3</a>, <a href="#hevea_default1304">14.11</a>
</li><li class="li-indexenv">frame, <a href="#hevea_default211">3.9</a>, <a href="#hevea_default255">3.13</a>, <a href="#hevea_default370">5.9</a>, <a href="#hevea_default458">6.5</a>, <a href="#hevea_default946">11.6</a>
</li><li class="li-indexenv">frequency, <a href="#hevea_default910">11.2</a>
<ul class="indexenv"><li class="li-indexenv">letter, <a href="#hevea_default1123">12.10</a>
</li><li class="li-indexenv">word, <a href="#hevea_default1147">13.1</a>, <a href="#hevea_default1205">13.12</a>
</li></ul>
</li><li class="li-indexenv">fruitful function, <a href="#hevea_default216">3.10</a>, <a href="#hevea_default242">3.13</a>
</li><li class="li-indexenv">frustration, <a href="#hevea_default1802">A.3.4</a>
</li><li class="li-indexenv">function, <a href="#hevea_default23">1.3</a>, <a href="#hevea_default146">3</a>, <a href="#hevea_default176">3.4</a>, <a href="#hevea_default232">3.13</a>, <a href="#hevea_default1464">17.1</a>
<ul class="indexenv"><li class="li-indexenv">abs, <a href="#hevea_default428">6.1</a>
</li><li class="li-indexenv">ack, <a href="#hevea_default489">6.11</a>, <a href="#hevea_default998">11.10</a>
</li><li class="li-indexenv">arc, <a href="#hevea_default272">4.3</a>
</li><li class="li-indexenv">choice, <a href="#hevea_default1159">13.2</a>
</li><li class="li-indexenv">circle, <a href="#hevea_default270">4.3</a>
</li><li class="li-indexenv">compare, <a href="#hevea_default430">6.1</a>
</li><li class="li-indexenv">deepcopy, <a href="#hevea_default1385">15.6</a>
</li><li class="li-indexenv">dict, <a href="#hevea_default895">11.1</a>
</li><li class="li-indexenv">dir, <a href="#hevea_default1778">A.2.3</a>
</li><li class="li-indexenv">enumerate, <a href="#hevea_default1075">12.5</a>
</li><li class="li-indexenv">eval, <a href="#hevea_default540">7.9</a>
</li><li class="li-indexenv">exists, <a href="#hevea_default1240">14.4</a>
</li><li class="li-indexenv">factorial, <a href="#hevea_default454">6.5</a>, <a href="#hevea_default1665">19.1</a>
</li><li class="li-indexenv">fibonacci, <a href="#hevea_default463">6.7</a>, <a href="#hevea_default944">11.6</a>
</li><li class="li-indexenv">find, <a href="#hevea_default589">8.6</a>
</li><li class="li-indexenv">float, <a href="#hevea_default156">3.1</a>
</li><li class="li-indexenv">fruitful, <a href="#hevea_default218">3.10</a>
</li><li class="li-indexenv">getattr, <a href="#hevea_default1523">17.10</a>
</li><li class="li-indexenv">getcwd, <a href="#hevea_default1232">14.4</a>
</li><li class="li-indexenv">hasattr, <a href="#hevea_default1394">15.7</a>, <a href="#hevea_default1517">17.10</a>
</li><li class="li-indexenv">input, <a href="#hevea_default383">5.11</a>
</li><li class="li-indexenv">int, <a href="#hevea_default154">3.1</a>
</li><li class="li-indexenv">isinstance, <a href="#hevea_default473">6.8</a>, <a href="#hevea_default1392">15.7</a>, <a href="#hevea_default1504">17.8</a>
</li><li class="li-indexenv">len, <a href="#hevea_default258">3.14</a>, <a href="#hevea_default555">8.2</a>, <a href="#hevea_default901">11.1</a>
</li><li class="li-indexenv">list, <a href="#hevea_default794">10.9</a>
</li><li class="li-indexenv">log, <a href="#hevea_default165">3.2</a>
</li><li class="li-indexenv">math, <a href="#hevea_default160">3.2</a>
</li><li class="li-indexenv">max, <a href="#hevea_default1046">12.3</a>, <a href="#hevea_default1059">12.4</a>
</li><li class="li-indexenv">min, <a href="#hevea_default1048">12.3</a>, <a href="#hevea_default1061">12.4</a>
</li><li class="li-indexenv">open, <a href="#hevea_default649">9.1</a>, <a href="#hevea_default659">9.1</a>, <a href="#hevea_default1216">14.2</a>, <a href="#hevea_default1244">14.5</a>, <a href="#hevea_default1256">14.6</a>
</li><li class="li-indexenv">polygon, <a href="#hevea_default268">4.3</a>
</li><li class="li-indexenv">popen, <a href="#hevea_default1275">14.8</a>
</li><li class="li-indexenv">programmer defined, <a href="#hevea_default200">3.7</a>, <a href="#hevea_default1169">13.5</a>
</li><li class="li-indexenv">randint, <a href="#hevea_default870">10.15</a>, <a href="#hevea_default1157">13.2</a>
</li><li class="li-indexenv">random, <a href="#hevea_default1155">13.2</a>
</li><li class="li-indexenv">reasons for, <a href="#hevea_default226">3.11</a>
</li><li class="li-indexenv">recursive, <a href="#hevea_default363">5.8</a>
</li><li class="li-indexenv">reload, <a href="#hevea_default1294">14.9</a>, <a href="#hevea_default1753">A.1.1</a>
</li><li class="li-indexenv">repr, <a href="#hevea_default1298">14.10</a>
</li><li class="li-indexenv">reversed, <a href="#hevea_default1104">12.7</a>
</li><li class="li-indexenv">shuffle, <a href="#hevea_default1605">18.6</a>
</li><li class="li-indexenv">sorted, <a href="#hevea_default842">10.13</a>, <a href="#hevea_default919">11.3</a>, <a href="#hevea_default1102">12.7</a>
</li><li class="li-indexenv">sqrt, <a href="#hevea_default172">3.2</a>, <a href="#hevea_default436">6.2</a>
</li><li class="li-indexenv">str, <a href="#hevea_default158">3.1</a>
</li><li class="li-indexenv">sum, <a href="#hevea_default1063">12.4</a>, <a href="#hevea_default1684">19.3</a>
</li><li class="li-indexenv">trigonometric, <a href="#hevea_default169">3.2</a>
</li><li class="li-indexenv">tuple, <a href="#hevea_default1016">12.1</a>
</li><li class="li-indexenv">tuple as return value, <a href="#hevea_default1041">12.3</a>
</li><li class="li-indexenv">type, <a href="#hevea_default1390">15.7</a>
</li><li class="li-indexenv">void, <a href="#hevea_default219">3.10</a>
</li><li class="li-indexenv">zip, <a href="#hevea_default1065">12.5</a>
</li></ul>
</li><li class="li-indexenv">function argument, <a href="#hevea_default196">3.7</a>
</li><li class="li-indexenv">function call, <a href="#hevea_default147">3.1</a>, <a href="#hevea_default238">3.13</a>
</li><li class="li-indexenv">function composition, <a href="#hevea_default440">6.3</a>
</li><li class="li-indexenv">function definition, <a href="#hevea_default177">3.4</a>, <a href="#hevea_default190">3.5</a>, <a href="#hevea_default233">3.13</a>, <a href="#hevea_default234">3.13</a>
</li><li class="li-indexenv">function frame, <a href="#hevea_default210">3.9</a>, <a href="#hevea_default254">3.13</a>, <a href="#hevea_default369">5.9</a>, <a href="#hevea_default457">6.5</a>, <a href="#hevea_default945">11.6</a>
</li><li class="li-indexenv">function object, <a href="#hevea_default259">3.14</a>
</li><li class="li-indexenv">function parameter, <a href="#hevea_default194">3.7</a>
</li><li class="li-indexenv">function syntax, <a href="#hevea_default1471">17.2</a>
</li><li class="li-indexenv">function type, <a href="#hevea_default188">3.4</a>
<ul class="indexenv"><li class="li-indexenv">modifier, <a href="#hevea_default1428">16.3</a>
</li><li class="li-indexenv">pure, <a href="#hevea_default1424">16.2</a>
</li></ul>
</li><li class="li-indexenv">functional programming style, <a href="#hevea_default1431">16.3</a>, <a href="#hevea_default1453">16.6</a>
<br>
</li><li class="li-indexenv">GCD (greatest common divisor), <a href="#hevea_default492">6.11</a>
</li><li class="li-indexenv">GNU Free Documentation License, <a href="#hevea_default0">0</a>, <a href="#hevea_default6">0</a>
</li><li class="li-indexenv">gamma function, <a href="#hevea_default471">6.8</a>
</li><li class="li-indexenv">gather, <a href="#hevea_default1051">12.4</a>, <a href="#hevea_default1115">12.9</a>, <a href="#hevea_default1718">19.9</a>
</li><li class="li-indexenv">generalization, <a href="#hevea_default274">4.5</a>, <a href="#hevea_default295">4.11</a>, <a href="#hevea_default668">9.3</a>, <a href="#hevea_default1442">16.4</a>
</li><li class="li-indexenv">generator expression, <a href="#hevea_default1677">19.3</a>, <a href="#hevea_default1687">19.4</a>, <a href="#hevea_default1727">19.10</a>
</li><li class="li-indexenv">generator object, <a href="#hevea_default1679">19.3</a>
</li><li class="li-indexenv">geometric resizing, <a href="#hevea_default1859">B.4</a>
</li><li class="li-indexenv">get method, <a href="#hevea_default913">11.2</a>
</li><li class="li-indexenv">getattr function, <a href="#hevea_default1522">17.10</a>
</li><li class="li-indexenv">getcwd function, <a href="#hevea_default1231">14.4</a>
</li><li class="li-indexenv">global statement, <a href="#hevea_default954">11.7</a>, <a href="#hevea_default989">11.9</a>
</li><li class="li-indexenv">global variable, <a href="#hevea_default949">11.7</a>, <a href="#hevea_default988">11.9</a>
<ul class="indexenv"><li class="li-indexenv">update, <a href="#hevea_default958">11.7</a>
</li></ul>
</li><li class="li-indexenv">greatest common divisor (GCD), <a href="#hevea_default491">6.11</a>
</li><li class="li-indexenv">grid, <a href="#hevea_default261">3.14</a>
</li><li class="li-indexenv">guardian pattern, <a href="#hevea_default474">6.8</a>, <a href="#hevea_default485">6.10</a>, <a href="#hevea_default613">8.11</a>
<br>
</li><li class="li-indexenv">HAS-A relationship, <a href="#hevea_default1623">18.8</a>, <a href="#hevea_default1652">18.11</a>, <a href="#hevea_default1653">18.11</a>
</li><li class="li-indexenv">Hand class, <a href="#hevea_default1613">18.7</a>
</li><li class="li-indexenv">HashMap, <a href="#hevea_default1855">B.4</a>
</li><li class="li-indexenv">Hello, World, <a href="#hevea_default19">1.3</a>
</li><li class="li-indexenv">Holmes, Sherlock, <a href="#hevea_default229">3.12</a>
</li><li class="li-indexenv">hanging, <a href="#hevea_default1756">A.2.2</a>
</li><li class="li-indexenv">hasattr function, <a href="#hevea_default1393">15.7</a>, <a href="#hevea_default1516">17.10</a>
</li><li class="li-indexenv">hash function, <a href="#hevea_default940">11.5</a>, <a href="#hevea_default978">11.9</a>, <a href="#hevea_default1853">B.4</a>
</li><li class="li-indexenv">hashable, <a href="#hevea_default941">11.5</a>, <a href="#hevea_default979">11.9</a>, <a href="#hevea_default1091">12.6</a>
</li><li class="li-indexenv">hashtable, <a href="#hevea_default977">11.9</a>, <a href="#hevea_default1848">B.4</a>, <a href="#hevea_default1870">B.5</a>
</li><li class="li-indexenv">header, <a href="#hevea_default183">3.4</a>, <a href="#hevea_default235">3.13</a>, <a href="#hevea_default1743">A.1</a>
</li><li class="li-indexenv">hexadecimal, <a href="#hevea_default1343">15.1</a>
</li><li class="li-indexenv">high-level language, <a href="#hevea_default64">1.8</a>
</li><li class="li-indexenv">histogram, <a href="#hevea_default909">11.2</a>, <a href="#hevea_default912">11.2</a>
<ul class="indexenv"><li class="li-indexenv">random choice, <a href="#hevea_default1160">13.2</a>, <a href="#hevea_default1177">13.7</a>
</li><li class="li-indexenv">word frequencies, <a href="#hevea_default1161">13.3</a>
</li></ul>
</li><li class="li-indexenv">homophone, <a href="#hevea_default1004">11.10</a>
</li><li class="li-indexenv">hypotenuse, <a href="#hevea_default438">6.2</a>
<br>
</li><li class="li-indexenv">IndexError, <a href="#hevea_default557">8.2</a>, <a href="#hevea_default616">8.11</a>, <a href="#hevea_default722">10.2</a>, <a href="#hevea_default1781">A.2.3</a>
</li><li class="li-indexenv">IS-A relationship, <a href="#hevea_default1622">18.8</a>, <a href="#hevea_default1651">18.11</a>
</li><li class="li-indexenv">identical, <a href="#hevea_default858">10.14</a>
</li><li class="li-indexenv">identity, <a href="#hevea_default813">10.10</a>, <a href="#hevea_default1373">15.6</a>
</li><li class="li-indexenv">if statement, <a href="#hevea_default342">5.4</a>
</li><li class="li-indexenv">immutability, <a href="#hevea_default578">8.5</a>, <a href="#hevea_default586">8.5</a>, <a href="#hevea_default626">8.12</a>, <a href="#hevea_default822">10.11</a>, <a href="#hevea_default942">11.5</a>, <a href="#hevea_default1011">12.1</a>, <a href="#hevea_default1100">12.7</a>
</li><li class="li-indexenv">implementation, <a href="#hevea_default908">11.2</a>, <a href="#hevea_default976">11.9</a>, <a href="#hevea_default1187">13.9</a>, <a href="#hevea_default1525">17.11</a>
</li><li class="li-indexenv">import statement, <a href="#hevea_default247">3.13</a>, <a href="#hevea_default1288">14.9</a>
</li><li class="li-indexenv"><span class="c004">in</span> operator, <a href="#hevea_default1846">B.3</a>
</li><li class="li-indexenv">in operator, <a href="#hevea_default605">8.9</a>, <a href="#hevea_default666">9.3</a>, <a href="#hevea_default726">10.2</a>, <a href="#hevea_default903">11.1</a>
</li><li class="li-indexenv">increment, <a href="#hevea_default502">7.2</a>, <a href="#hevea_default532">7.8</a>, <a href="#hevea_default1429">16.3</a>, <a href="#hevea_default1478">17.3</a>
</li><li class="li-indexenv">incremental development, <a href="#hevea_default483">6.10</a>, <a href="#hevea_default1739">A.1</a>
</li><li class="li-indexenv">indentation, <a href="#hevea_default185">3.4</a>, <a href="#hevea_default1470">17.2</a>, <a href="#hevea_default1749">A.1</a>
</li><li class="li-indexenv">index, <a href="#hevea_default548">8.1</a>, <a href="#hevea_default551">8.1</a>, <a href="#hevea_default615">8.11</a>, <a href="#hevea_default623">8.12</a>, <a href="#hevea_default710">10.2</a>, <a href="#hevea_default892">11.1</a>, <a href="#hevea_default1771">A.2.3</a>
<ul class="indexenv"><li class="li-indexenv">looping with, <a href="#hevea_default673">9.4</a>, <a href="#hevea_default734">10.3</a>
</li><li class="li-indexenv">negative, <a href="#hevea_default558">8.2</a>
</li><li class="li-indexenv">slice, <a href="#hevea_default571">8.4</a>, <a href="#hevea_default746">10.5</a>
</li><li class="li-indexenv">starting at zero, <a href="#hevea_default549">8.1</a>, <a href="#hevea_default714">10.2</a>
</li></ul>
</li><li class="li-indexenv">indexing, <a href="#hevea_default1832">B.2</a>
</li><li class="li-indexenv">infinite loop, <a href="#hevea_default512">7.3</a>, <a href="#hevea_default535">7.8</a>, <a href="#hevea_default1754">A.2.2</a>, <a href="#hevea_default1757">A.2.2</a>
</li><li class="li-indexenv">infinite recursion, <a href="#hevea_default373">5.10</a>, <a href="#hevea_default414">5.13</a>, <a href="#hevea_default469">6.8</a>, <a href="#hevea_default1755">A.2.2</a>, <a href="#hevea_default1761">A.2.2</a>
</li><li class="li-indexenv">inheritance, <a href="#hevea_default1608">18.7</a>, <a href="#hevea_default1628">18.9</a>, <a href="#hevea_default1647">18.11</a>, <a href="#hevea_default1717">19.8</a>
</li><li class="li-indexenv">init method, <a href="#hevea_default1485">17.5</a>, <a href="#hevea_default1514">17.10</a>, <a href="#hevea_default1559">18.1</a>, <a href="#hevea_default1582">18.4</a>, <a href="#hevea_default1619">18.7</a>
</li><li class="li-indexenv">initialization<ul class="indexenv"><li class="li-indexenv">variable, <a href="#hevea_default531">7.8</a>
</li></ul>
</li><li class="li-indexenv">initialization (before update), <a href="#hevea_default501">7.2</a>
</li><li class="li-indexenv">input function, <a href="#hevea_default382">5.11</a>
</li><li class="li-indexenv">instance, <a href="#hevea_default1341">15.1</a>, <a href="#hevea_default1403">15.8</a>
<ul class="indexenv"><li class="li-indexenv">as argument, <a href="#hevea_default1351">15.2</a>
</li><li class="li-indexenv">as return value, <a href="#hevea_default1362">15.4</a>
</li></ul>
</li><li class="li-indexenv">instance attribute, <a href="#hevea_default1344">15.2</a>, <a href="#hevea_default1406">15.8</a>, <a href="#hevea_default1563">18.2</a>, <a href="#hevea_default1644">18.11</a>
</li><li class="li-indexenv">instantiate, <a href="#hevea_default1404">15.8</a>
</li><li class="li-indexenv">instantiation, <a href="#hevea_default1342">15.1</a>
</li><li class="li-indexenv">int function, <a href="#hevea_default153">3.1</a>
</li><li class="li-indexenv">int type, <a href="#hevea_default39">1.5</a>
</li><li class="li-indexenv">integer, <a href="#hevea_default33">1.5</a>, <a href="#hevea_default75">1.8</a>
</li><li class="li-indexenv">interactive mode, <a href="#hevea_default100">2.4</a>, <a href="#hevea_default103">2.4</a>, <a href="#hevea_default134">2.9</a>, <a href="#hevea_default220">3.10</a>
</li><li class="li-indexenv">interface, <a href="#hevea_default278">4.6</a>, <a href="#hevea_default289">4.10</a>, <a href="#hevea_default298">4.11</a>, <a href="#hevea_default1524">17.11</a>, <a href="#hevea_default1634">18.9</a>
</li><li class="li-indexenv">interlocking words, <a href="#hevea_default886">10.15</a>
</li><li class="li-indexenv">interpret, <a href="#hevea_default67">1.8</a>
</li><li class="li-indexenv">interpreter, <a href="#hevea_default17">1.2</a>
</li><li class="li-indexenv">invariant, <a href="#hevea_default1444">16.5</a>, <a href="#hevea_default1454">16.6</a>
</li><li class="li-indexenv">invert dictionary, <a href="#hevea_default933">11.5</a>
</li><li class="li-indexenv">invocation, <a href="#hevea_default602">8.8</a>, <a href="#hevea_default631">8.12</a>
</li><li class="li-indexenv">is operator, <a href="#hevea_default808">10.10</a>, <a href="#hevea_default1371">15.6</a>
</li><li class="li-indexenv">isinstance function, <a href="#hevea_default472">6.8</a>, <a href="#hevea_default1391">15.7</a>, <a href="#hevea_default1503">17.8</a>
</li><li class="li-indexenv">item, <a href="#hevea_default583">8.5</a>, <a href="#hevea_default622">8.12</a>, <a href="#hevea_default702">10.1</a>, <a href="#hevea_default893">11.1</a>
<ul class="indexenv"><li class="li-indexenv">dictionary, <a href="#hevea_default973">11.9</a>
</li></ul>
</li><li class="li-indexenv">item assignment, <a href="#hevea_default584">8.5</a>, <a href="#hevea_default718">10.2</a>, <a href="#hevea_default1025">12.1</a>
</li><li class="li-indexenv">item update, <a href="#hevea_default735">10.3</a>
</li><li class="li-indexenv">items method, <a href="#hevea_default1080">12.6</a>
</li><li class="li-indexenv">iteration, <a href="#hevea_default507">7.3</a>, <a href="#hevea_default534">7.8</a>
</li><li class="li-indexenv">iterator, <a href="#hevea_default1066">12.5</a>, <a href="#hevea_default1076">12.5</a>, <a href="#hevea_default1083">12.6</a>, <a href="#hevea_default1105">12.7</a>, <a href="#hevea_default1119">12.9</a>, <a href="#hevea_default1840">B.2</a>
<br>
</li><li class="li-indexenv"><span class="c004">join</span>, <a href="#hevea_default1836">B.2</a>
</li><li class="li-indexenv">join method, <a href="#hevea_default800">10.9</a>, <a href="#hevea_default1594">18.5</a>
<br>
</li><li class="li-indexenv">Kangaroo class, <a href="#hevea_default1543">17.13</a>
</li><li class="li-indexenv">KeyError, <a href="#hevea_default899">11.1</a>, <a href="#hevea_default1774">A.2.3</a>
</li><li class="li-indexenv"><span class="c004">KeyError</span>, <a href="#hevea_default1850">B.4</a>
</li><li class="li-indexenv">Koch curve, <a href="#hevea_default418">5.14</a>
</li><li class="li-indexenv">key, <a href="#hevea_default890">11.1</a>, <a href="#hevea_default974">11.9</a>
</li><li class="li-indexenv">key-value pair, <a href="#hevea_default891">11.1</a>, <a href="#hevea_default972">11.9</a>, <a href="#hevea_default1082">12.6</a>
</li><li class="li-indexenv">keyboard input, <a href="#hevea_default380">5.11</a>
</li><li class="li-indexenv">keyword, <a href="#hevea_default95">2.2</a>, <a href="#hevea_default129">2.9</a>, <a href="#hevea_default1742">A.1</a>
<ul class="indexenv"><li class="li-indexenv">def, <a href="#hevea_default180">3.4</a>
</li><li class="li-indexenv">elif, <a href="#hevea_default357">5.6</a>
</li><li class="li-indexenv">else, <a href="#hevea_default352">5.5</a>
</li></ul>
</li><li class="li-indexenv">keyword argument, <a href="#hevea_default276">4.5</a>, <a href="#hevea_default296">4.11</a>, <a href="#hevea_default1721">19.9</a>
<br>
</li><li class="li-indexenv"><span class="c004">LinearMap</span>, <a href="#hevea_default1849">B.4</a>
</li><li class="li-indexenv">Linux, <a href="#hevea_default231">3.12</a>
</li><li class="li-indexenv">Liskov substitution principle, <a href="#hevea_default1637">18.9</a>
</li><li class="li-indexenv">LookupError, <a href="#hevea_default929">11.4</a>
</li><li class="li-indexenv">language<ul class="indexenv"><li class="li-indexenv">formal, <a href="#hevea_default47">1.6</a>
</li><li class="li-indexenv">natural, <a href="#hevea_default48">1.6</a>
</li><li class="li-indexenv">safe, <a href="#hevea_default122">2.8</a>
</li><li class="li-indexenv">Turing complete, <a href="#hevea_default447">6.5</a>
</li></ul>
</li><li class="li-indexenv">leading coefficient, <a href="#hevea_default1823">B.1</a>
</li><li class="li-indexenv">leading term, <a href="#hevea_default1821">B.1</a>, <a href="#hevea_default1863">B.5</a>
</li><li class="li-indexenv">leap of faith, <a href="#hevea_default460">6.6</a>
</li><li class="li-indexenv">len function, <a href="#hevea_default257">3.14</a>, <a href="#hevea_default554">8.2</a>, <a href="#hevea_default900">11.1</a>
</li><li class="li-indexenv">letter
frequency, <a href="#hevea_default1122">12.10</a>
</li><li class="li-indexenv">letter rotation, <a href="#hevea_default644">8.13</a>, <a href="#hevea_default1000">11.10</a>
</li><li class="li-indexenv">linear, <a href="#hevea_default1867">B.5</a>
</li><li class="li-indexenv">linear growth, <a href="#hevea_default1826">B.1</a>
</li><li class="li-indexenv">linear search, <a href="#hevea_default1845">B.3</a>
</li><li class="li-indexenv">lipogram, <a href="#hevea_default661">9.2</a>
</li><li class="li-indexenv">list, <a href="#hevea_default698">10.1</a>, <a href="#hevea_default790">10.9</a>, <a href="#hevea_default843">10.14</a>, <a href="#hevea_default1097">12.7</a>, <a href="#hevea_default1671">19.2</a>
<ul class="indexenv"><li class="li-indexenv">as argument, <a href="#hevea_default823">10.12</a>
</li><li class="li-indexenv">concatenation, <a href="#hevea_default741">10.4</a>, <a href="#hevea_default832">10.12</a>, <a href="#hevea_default873">10.15</a>
</li><li class="li-indexenv">copy, <a href="#hevea_default749">10.5</a>
</li><li class="li-indexenv">element, <a href="#hevea_default708">10.2</a>
</li><li class="li-indexenv">empty, <a href="#hevea_default706">10.1</a>
</li><li class="li-indexenv">function, <a href="#hevea_default793">10.9</a>
</li><li class="li-indexenv">index, <a href="#hevea_default723">10.2</a>
</li><li class="li-indexenv">membership, <a href="#hevea_default724">10.2</a>
</li><li class="li-indexenv">method, <a href="#hevea_default755">10.6</a>
</li><li class="li-indexenv">nested, <a href="#hevea_default704">10.1</a>, <a href="#hevea_default738">10.3</a>
</li><li class="li-indexenv">of objects, <a href="#hevea_default1580">18.4</a>
</li><li class="li-indexenv">of tuples, <a href="#hevea_default1067">12.5</a>
</li><li class="li-indexenv">operation, <a href="#hevea_default739">10.4</a>
</li><li class="li-indexenv">repetition, <a href="#hevea_default743">10.4</a>
</li><li class="li-indexenv">slice, <a href="#hevea_default747">10.5</a>
</li><li class="li-indexenv">traversal, <a href="#hevea_default728">10.3</a>
</li></ul>
</li></ul></td><td class="c018"><ul class="indexenv"><li class="li-indexenv">list comprehension, <a href="#hevea_default1670">19.2</a>, <a href="#hevea_default1726">19.10</a>
</li><li class="li-indexenv">list methods, <a href="#hevea_default1837">B.2</a>
</li><li class="li-indexenv">literalness, <a href="#hevea_default55">1.6</a>
</li><li class="li-indexenv">local variable, <a href="#hevea_default202">3.8</a>, <a href="#hevea_default240">3.13</a>
</li><li class="li-indexenv">log function, <a href="#hevea_default164">3.2</a>
</li><li class="li-indexenv">logarithm, <a href="#hevea_default1207">13.12</a>
</li><li class="li-indexenv">logarithmic growth, <a href="#hevea_default1829">B.1</a>
</li><li class="li-indexenv">logical operator, <a href="#hevea_default322">5.2</a>, <a href="#hevea_default332">5.3</a>
</li><li class="li-indexenv">lookup, <a href="#hevea_default980">11.9</a>
</li><li class="li-indexenv">lookup, dictionary, <a href="#hevea_default922">11.4</a>
</li><li class="li-indexenv">loop, <a href="#hevea_default266">4.2</a>, <a href="#hevea_default293">4.11</a>, <a href="#hevea_default510">7.3</a>, <a href="#hevea_default1071">12.5</a>
<ul class="indexenv"><li class="li-indexenv">condition, <a href="#hevea_default1760">A.2.2</a>
</li><li class="li-indexenv">for, <a href="#hevea_default264">4.2</a>, <a href="#hevea_default367">5.8</a>, <a href="#hevea_default563">8.3</a>, <a href="#hevea_default731">10.3</a>
</li><li class="li-indexenv">infinite, <a href="#hevea_default513">7.3</a>, <a href="#hevea_default1758">A.2.2</a>
</li><li class="li-indexenv">nested, <a href="#hevea_default1585">18.4</a>
</li><li class="li-indexenv">traversal, <a href="#hevea_default561">8.3</a>
</li><li class="li-indexenv">while, <a href="#hevea_default506">7.3</a>
</li></ul>
</li><li class="li-indexenv">loop variable, <a href="#hevea_default1673">19.2</a>
</li><li class="li-indexenv">looping<ul class="indexenv"><li class="li-indexenv">with dictionaries, <a href="#hevea_default916">11.3</a>
</li><li class="li-indexenv">with indices, <a href="#hevea_default672">9.4</a>, <a href="#hevea_default733">10.3</a>
</li><li class="li-indexenv">with strings, <a href="#hevea_default596">8.7</a>
</li></ul>
</li><li class="li-indexenv">looping and counting, <a href="#hevea_default595">8.7</a>
</li><li class="li-indexenv">low-level language, <a href="#hevea_default65">1.8</a>
</li><li class="li-indexenv">ls (Unix command), <a href="#hevea_default1272">14.8</a>
<br>
</li><li class="li-indexenv">Markov analysis, <a href="#hevea_default1179">13.8</a>
</li><li class="li-indexenv">McCloskey, Robert, <a href="#hevea_default568">8.3</a>
</li><li class="li-indexenv">MD5 algorithm, <a href="#hevea_default1322">14.12</a>
</li><li class="li-indexenv">Meyers, Chris, <a href="#hevea_default5">0</a>
</li><li class="li-indexenv">Moby Project, <a href="#hevea_default646">9.1</a>
</li><li class="li-indexenv">Monty Python and the Holy Grail, <a href="#hevea_default1425">16.2</a>
</li><li class="li-indexenv">MP3, <a href="#hevea_default1320">14.12</a>
</li><li class="li-indexenv">machine model, <a href="#hevea_default1817">B</a>, <a href="#hevea_default1861">B.5</a>
</li><li class="li-indexenv">main, <a href="#hevea_default214">3.9</a>, <a href="#hevea_default361">5.8</a>, <a href="#hevea_default952">11.7</a>, <a href="#hevea_default1291">14.9</a>
</li><li class="li-indexenv">maintainable, <a href="#hevea_default1526">17.11</a>
</li><li class="li-indexenv">map pattern, <a href="#hevea_default776">10.7</a>, <a href="#hevea_default852">10.14</a>
</li><li class="li-indexenv">map to, <a href="#hevea_default1555">18.1</a>
</li><li class="li-indexenv">mapping, <a href="#hevea_default970">11.9</a>, <a href="#hevea_default1182">13.8</a>
</li><li class="li-indexenv">mash-up, <a href="#hevea_default1185">13.8</a>
</li><li class="li-indexenv">math function, <a href="#hevea_default159">3.2</a>
</li><li class="li-indexenv">matplotlib, <a href="#hevea_default1208">13.12</a>
</li><li class="li-indexenv">max function, <a href="#hevea_default1045">12.3</a>, <a href="#hevea_default1058">12.4</a>
</li><li class="li-indexenv">md5, <a href="#hevea_default1282">14.8</a>
</li><li class="li-indexenv">md5sum, <a href="#hevea_default1325">14.12</a>
</li><li class="li-indexenv">membership<ul class="indexenv"><li class="li-indexenv">binary search, <a href="#hevea_default880">10.15</a>
</li><li class="li-indexenv">bisection search, <a href="#hevea_default877">10.15</a>
</li><li class="li-indexenv">dictionary, <a href="#hevea_default902">11.1</a>
</li><li class="li-indexenv">list, <a href="#hevea_default725">10.2</a>
</li><li class="li-indexenv">set, <a href="#hevea_default994">11.10</a>
</li></ul>
</li><li class="li-indexenv">memo, <a href="#hevea_default948">11.6</a>, <a href="#hevea_default987">11.9</a>
</li><li class="li-indexenv">mental model, <a href="#hevea_default1793">A.3.1</a>
</li><li class="li-indexenv">metaphor, method invocation, <a href="#hevea_default1477">17.2</a>
</li><li class="li-indexenv">metathesis, <a href="#hevea_default1128">12.10</a>
</li><li class="li-indexenv">method, <a href="#hevea_default292">4.11</a>, <a href="#hevea_default598">8.8</a>, <a href="#hevea_default1463">17.1</a>, <a href="#hevea_default1531">17.12</a>
<ul class="indexenv"><li class="li-indexenv">__cmp__, <a href="#hevea_default1577">18.3</a>
</li><li class="li-indexenv">__str__, <a href="#hevea_default1494">17.6</a>, <a href="#hevea_default1591">18.5</a>
</li><li class="li-indexenv">add, <a href="#hevea_default1501">17.7</a>
</li><li class="li-indexenv">append, <a href="#hevea_default758">10.6</a>, <a href="#hevea_default831">10.12</a>, <a href="#hevea_default872">10.15</a>, <a href="#hevea_default1589">18.4</a>, <a href="#hevea_default1600">18.6</a>
</li><li class="li-indexenv">close, <a href="#hevea_default1218">14.2</a>, <a href="#hevea_default1264">14.6</a>, <a href="#hevea_default1281">14.8</a>
</li><li class="li-indexenv">count, <a href="#hevea_default639">8.13</a>
</li><li class="li-indexenv">extend, <a href="#hevea_default760">10.6</a>
</li><li class="li-indexenv">get, <a href="#hevea_default914">11.2</a>
</li><li class="li-indexenv">init, <a href="#hevea_default1486">17.5</a>, <a href="#hevea_default1560">18.1</a>, <a href="#hevea_default1583">18.4</a>, <a href="#hevea_default1620">18.7</a>
</li><li class="li-indexenv">items, <a href="#hevea_default1081">12.6</a>
</li><li class="li-indexenv">join, <a href="#hevea_default801">10.9</a>, <a href="#hevea_default1595">18.5</a>
</li><li class="li-indexenv">mro, <a href="#hevea_default1631">18.9</a>
</li><li class="li-indexenv">pop, <a href="#hevea_default783">10.8</a>, <a href="#hevea_default1598">18.6</a>
</li><li class="li-indexenv">radd, <a href="#hevea_default1509">17.8</a>
</li><li class="li-indexenv">read, <a href="#hevea_default1279">14.8</a>
</li><li class="li-indexenv">readline, <a href="#hevea_default655">9.1</a>, <a href="#hevea_default1277">14.8</a>
</li><li class="li-indexenv">remove, <a href="#hevea_default787">10.8</a>
</li><li class="li-indexenv">replace, <a href="#hevea_default1140">13.1</a>
</li><li class="li-indexenv">setdefault, <a href="#hevea_default996">11.10</a>
</li><li class="li-indexenv">sort, <a href="#hevea_default762">10.6</a>, <a href="#hevea_default838">10.13</a>, <a href="#hevea_default1607">18.6</a>
</li><li class="li-indexenv">split, <a href="#hevea_default796">10.9</a>, <a href="#hevea_default1036">12.2</a>
</li><li class="li-indexenv">string, <a href="#hevea_default635">8.13</a>
</li><li class="li-indexenv">strip, <a href="#hevea_default657">9.1</a>, <a href="#hevea_default1138">13.1</a>
</li><li class="li-indexenv">translate, <a href="#hevea_default1142">13.1</a>
</li><li class="li-indexenv">update, <a href="#hevea_default1087">12.6</a>
</li><li class="li-indexenv">values, <a href="#hevea_default906">11.1</a>
</li><li class="li-indexenv">void, <a href="#hevea_default764">10.6</a>
</li></ul>
</li><li class="li-indexenv">method resolution order, <a href="#hevea_default1632">18.9</a>
</li><li class="li-indexenv">method syntax, <a href="#hevea_default1473">17.2</a>
</li><li class="li-indexenv">method, list, <a href="#hevea_default756">10.6</a>
</li><li class="li-indexenv">min function, <a href="#hevea_default1047">12.3</a>, <a href="#hevea_default1060">12.4</a>
</li><li class="li-indexenv">model, mental, <a href="#hevea_default1792">A.3.1</a>
</li><li class="li-indexenv">modifier, <a href="#hevea_default1427">16.3</a>, <a href="#hevea_default1452">16.6</a>
</li><li class="li-indexenv">module, <a href="#hevea_default161">3.2</a>, <a href="#hevea_default246">3.13</a>, <a href="#hevea_default249">3.13</a>
<ul class="indexenv"><li class="li-indexenv">bisect, <a href="#hevea_default884">10.15</a>
</li><li class="li-indexenv">collections, <a href="#hevea_default1703">19.6</a>, <a href="#hevea_default1707">19.7</a>, <a href="#hevea_default1714">19.8</a>
</li><li class="li-indexenv">copy, <a href="#hevea_default1370">15.6</a>
</li><li class="li-indexenv">datetime, <a href="#hevea_default1459">16.7</a>
</li><li class="li-indexenv">dbm, <a href="#hevea_default1254">14.6</a>
</li><li class="li-indexenv">os, <a href="#hevea_default1230">14.4</a>
</li><li class="li-indexenv">pickle, <a href="#hevea_default1213">14.1</a>, <a href="#hevea_default1267">14.7</a>
</li><li class="li-indexenv">pprint, <a href="#hevea_default968">11.8</a>
</li><li class="li-indexenv">profile, <a href="#hevea_default1191">13.9</a>
</li><li class="li-indexenv">random, <a href="#hevea_default868">10.15</a>, <a href="#hevea_default1153">13.2</a>, <a href="#hevea_default1603">18.6</a>
</li><li class="li-indexenv">reload, <a href="#hevea_default1292">14.9</a>, <a href="#hevea_default1751">A.1.1</a>
</li><li class="li-indexenv">shelve, <a href="#hevea_default1269">14.7</a>
</li><li class="li-indexenv">string, <a href="#hevea_default1136">13.1</a>
</li><li class="li-indexenv">structshape, <a href="#hevea_default1111">12.8</a>
</li><li class="li-indexenv">time, <a href="#hevea_default876">10.15</a>
</li></ul>
</li><li class="li-indexenv">module object, <a href="#hevea_default162">3.2</a>, <a href="#hevea_default1286">14.9</a>
</li><li class="li-indexenv">module, writing, <a href="#hevea_default1284">14.9</a>
</li><li class="li-indexenv">modulus operator, <a href="#hevea_default316">5.1</a>, <a href="#hevea_default399">5.13</a>
</li><li class="li-indexenv">mro method, <a href="#hevea_default1630">18.9</a>
</li><li class="li-indexenv">multiline string, <a href="#hevea_default286">4.9</a>, <a href="#hevea_default1746">A.1</a>
</li><li class="li-indexenv">multiplicity (in class diagram), <a href="#hevea_default1626">18.8</a>, <a href="#hevea_default1656">18.11</a>
</li><li class="li-indexenv">multiset, <a href="#hevea_default1701">19.6</a>
</li><li class="li-indexenv">mutability, <a href="#hevea_default577">8.5</a>, <a href="#hevea_default713">10.2</a>, <a href="#hevea_default752">10.5</a>, <a href="#hevea_default821">10.11</a>, <a href="#hevea_default962">11.7</a>, <a href="#hevea_default1010">12.1</a>, <a href="#hevea_default1099">12.7</a>, <a href="#hevea_default1365">15.5</a>
</li><li class="li-indexenv">mutable object, as default value, <a href="#hevea_default1540">17.13</a>
<br>
</li><li class="li-indexenv">NameError, <a href="#hevea_default206">3.8</a>, <a href="#hevea_default1767">A.2.3</a>
</li><li class="li-indexenv">NaN, <a href="#hevea_default1662">19.1</a>
</li><li class="li-indexenv">Newton&#X2019;s method, <a href="#hevea_default518">7.5</a>
</li><li class="li-indexenv">None special value, <a href="#hevea_default222">3.10</a>, <a href="#hevea_default244">3.13</a>, <a href="#hevea_default425">6.1</a>, <a href="#hevea_default765">10.6</a>, <a href="#hevea_default788">10.8</a>
</li><li class="li-indexenv">NoneType type, <a href="#hevea_default224">3.10</a>
</li><li class="li-indexenv">name built-in variable, <a href="#hevea_default1290">14.9</a>
</li><li class="li-indexenv">namedtuple, <a href="#hevea_default1711">19.8</a>
</li><li class="li-indexenv">natural language, <a href="#hevea_default46">1.6</a>, <a href="#hevea_default78">1.8</a>
</li><li class="li-indexenv">negative index, <a href="#hevea_default559">8.2</a>
</li><li class="li-indexenv">nested conditional, <a href="#hevea_default358">5.7</a>, <a href="#hevea_default410">5.13</a>
</li><li class="li-indexenv">nested list, <a href="#hevea_default703">10.1</a>, <a href="#hevea_default737">10.3</a>, <a href="#hevea_default845">10.14</a>
</li><li class="li-indexenv">newline, <a href="#hevea_default385">5.11</a>, <a href="#hevea_default1596">18.5</a>
</li><li class="li-indexenv">not operator, <a href="#hevea_default336">5.3</a>
</li><li class="li-indexenv">number, random, <a href="#hevea_default1149">13.2</a>
<br>
</li><li class="li-indexenv">Obama, Barack, <a href="#hevea_default1812">B</a>
</li><li class="li-indexenv">Olin College, <a href="#hevea_default3">0</a>
</li><li class="li-indexenv">OverflowError, <a href="#hevea_default394">5.12</a>
</li><li class="li-indexenv">object, <a href="#hevea_default582">8.5</a>, <a href="#hevea_default620">8.12</a>, <a href="#hevea_default805">10.10</a>, <a href="#hevea_default814">10.10</a>, <a href="#hevea_default856">10.14</a>
<ul class="indexenv"><li class="li-indexenv">bytes, <a href="#hevea_default1261">14.6</a>, <a href="#hevea_default1314">14.11</a>
</li><li class="li-indexenv">Counter, <a href="#hevea_default1700">19.6</a>
</li><li class="li-indexenv">class, <a href="#hevea_default1333">15.1</a>, <a href="#hevea_default1339">15.1</a>, <a href="#hevea_default1402">15.8</a>, <a href="#hevea_default1716">19.8</a>
</li><li class="li-indexenv">copying, <a href="#hevea_default1368">15.6</a>
</li><li class="li-indexenv">database, <a href="#hevea_default1258">14.6</a>
</li><li class="li-indexenv">defaultdict, <a href="#hevea_default1705">19.7</a>
</li><li class="li-indexenv">embedded, <a href="#hevea_default1361">15.3</a>, <a href="#hevea_default1408">15.8</a>, <a href="#hevea_default1547">17.13</a>
</li><li class="li-indexenv">enumerate, <a href="#hevea_default1077">12.5</a>
</li><li class="li-indexenv">file, <a href="#hevea_default652">9.1</a>, <a href="#hevea_default684">9.6</a>
</li><li class="li-indexenv">function, <a href="#hevea_default260">3.14</a>
</li><li class="li-indexenv">generator, <a href="#hevea_default1680">19.3</a>
</li><li class="li-indexenv">module, <a href="#hevea_default1287">14.9</a>
</li><li class="li-indexenv">mutable, <a href="#hevea_default1364">15.5</a>
</li><li class="li-indexenv">namedtuple, <a href="#hevea_default1712">19.8</a>
</li><li class="li-indexenv">pipe, <a href="#hevea_default1317">14.11</a>
</li><li class="li-indexenv">printing, <a href="#hevea_default1469">17.2</a>
</li><li class="li-indexenv">set, <a href="#hevea_default1695">19.5</a>
</li><li class="li-indexenv">zip, <a href="#hevea_default1118">12.9</a>
</li></ul>
</li><li class="li-indexenv">object diagram, <a href="#hevea_default1349">15.2</a>, <a href="#hevea_default1358">15.3</a>, <a href="#hevea_default1378">15.6</a>, <a href="#hevea_default1411">15.8</a>, <a href="#hevea_default1419">16.1</a>, <a href="#hevea_default1568">18.2</a>
</li><li class="li-indexenv">object-oriented design, <a href="#hevea_default1527">17.11</a>
</li><li class="li-indexenv">object-oriented language, <a href="#hevea_default1529">17.12</a>
</li><li class="li-indexenv">object-oriented programming, <a href="#hevea_default1327">15</a>, <a href="#hevea_default1462">17.1</a>, <a href="#hevea_default1530">17.12</a>, <a href="#hevea_default1609">18.7</a>
</li><li class="li-indexenv">odometer, <a href="#hevea_default693">9.7</a>
</li><li class="li-indexenv">open function, <a href="#hevea_default648">9.1</a>, <a href="#hevea_default658">9.1</a>, <a href="#hevea_default1215">14.2</a>, <a href="#hevea_default1243">14.5</a>, <a href="#hevea_default1255">14.6</a>
</li><li class="li-indexenv">operand, <a href="#hevea_default130">2.9</a>
</li><li class="li-indexenv">operator, <a href="#hevea_default72">1.8</a>
<ul class="indexenv"><li class="li-indexenv">and, <a href="#hevea_default337">5.3</a>
</li><li class="li-indexenv">arithmetic, <a href="#hevea_default26">1.4</a>
</li><li class="li-indexenv">bitwise, <a href="#hevea_default29">1.4</a>
</li><li class="li-indexenv">boolean, <a href="#hevea_default608">8.9</a>
</li><li class="li-indexenv">bracket, <a href="#hevea_default547">8.1</a>, <a href="#hevea_default712">10.2</a>, <a href="#hevea_default1018">12.1</a>
</li><li class="li-indexenv">del, <a href="#hevea_default785">10.8</a>
</li><li class="li-indexenv">format, <a href="#hevea_default1220">14.3</a>, <a href="#hevea_default1303">14.11</a>, <a href="#hevea_default1773">A.2.3</a>
</li><li class="li-indexenv">in, <a href="#hevea_default606">8.9</a>, <a href="#hevea_default667">9.3</a>, <a href="#hevea_default727">10.2</a>, <a href="#hevea_default904">11.1</a>
</li><li class="li-indexenv">is, <a href="#hevea_default809">10.10</a>, <a href="#hevea_default1372">15.6</a>
</li><li class="li-indexenv">logical, <a href="#hevea_default323">5.2</a>, <a href="#hevea_default333">5.3</a>
</li><li class="li-indexenv">modulus, <a href="#hevea_default317">5.1</a>, <a href="#hevea_default400">5.13</a>
</li><li class="li-indexenv">not, <a href="#hevea_default339">5.3</a>
</li><li class="li-indexenv">or, <a href="#hevea_default338">5.3</a>
</li><li class="li-indexenv">overloading, <a href="#hevea_default1536">17.12</a>
</li><li class="li-indexenv">relational, <a href="#hevea_default331">5.2</a>, <a href="#hevea_default1570">18.3</a>
</li><li class="li-indexenv">slice, <a href="#hevea_default570">8.4</a>, <a href="#hevea_default642">8.13</a>, <a href="#hevea_default745">10.5</a>, <a href="#hevea_default835">10.12</a>, <a href="#hevea_default1020">12.1</a>
</li><li class="li-indexenv">string, <a href="#hevea_default108">2.6</a>
</li><li class="li-indexenv">update, <a href="#hevea_default768">10.7</a>
</li></ul>
</li><li class="li-indexenv">operator overloading, <a href="#hevea_default1502">17.7</a>, <a href="#hevea_default1575">18.3</a>
</li><li class="li-indexenv">optional argument, <a href="#hevea_default603">8.8</a>, <a href="#hevea_default632">8.12</a>, <a href="#hevea_default636">8.13</a>, <a href="#hevea_default797">10.9</a>, <a href="#hevea_default931">11.4</a>, <a href="#hevea_default1666">19.1</a>
</li><li class="li-indexenv">optional parameter, <a href="#hevea_default1166">13.5</a>, <a href="#hevea_default1487">17.5</a>
</li><li class="li-indexenv">or operator, <a href="#hevea_default335">5.3</a>
</li><li class="li-indexenv">order of growth, <a href="#hevea_default1820">B.1</a>, <a href="#hevea_default1865">B.5</a>
</li><li class="li-indexenv">order of operations, <a href="#hevea_default105">2.5</a>, <a href="#hevea_default137">2.9</a>, <a href="#hevea_default1798">A.3.2</a>
</li><li class="li-indexenv">os module, <a href="#hevea_default1229">14.4</a>
</li><li class="li-indexenv">other (parameter name), <a href="#hevea_default1483">17.4</a>
</li><li class="li-indexenv">overloading, <a href="#hevea_default1535">17.12</a>
</li><li class="li-indexenv">override, <a href="#hevea_default1172">13.5</a>, <a href="#hevea_default1200">13.11</a>, <a href="#hevea_default1490">17.5</a>, <a href="#hevea_default1574">18.3</a>, <a href="#hevea_default1618">18.7</a>, <a href="#hevea_default1633">18.9</a>
<br>
</li><li class="li-indexenv">PEMDAS, <a href="#hevea_default106">2.5</a>
</li><li class="li-indexenv">Point class, <a href="#hevea_default1336">15.1</a>, <a href="#hevea_default1491">17.5</a>
</li><li class="li-indexenv">Project Gutenberg, <a href="#hevea_default1143">13.1</a>
</li><li class="li-indexenv">Puzzler, <a href="#hevea_default689">9.7</a>, <a href="#hevea_default692">9.7</a>, <a href="#hevea_default696">9.7</a>, <a href="#hevea_default1003">11.10</a>, <a href="#hevea_default1130">12.10</a>
</li><li class="li-indexenv">Pythagorean theorem, <a href="#hevea_default433">6.2</a>
</li><li class="li-indexenv">Python<ul class="indexenv"><li class="li-indexenv">running, <a href="#hevea_default13">1.2</a>
</li></ul>
</li><li class="li-indexenv">Python 2, <a href="#hevea_default16">1.2</a>, <a href="#hevea_default25">1.3</a>, <a href="#hevea_default275">4.5</a>, <a href="#hevea_default319">5.1</a>, <a href="#hevea_default381">5.11</a>
</li><li class="li-indexenv">Python in a browser, <a href="#hevea_default14">1.2</a>
</li><li class="li-indexenv">PythonAnywhere, <a href="#hevea_default15">1.2</a>
</li><li class="li-indexenv">palindrome, <a href="#hevea_default490">6.11</a>, <a href="#hevea_default643">8.13</a>, <a href="#hevea_default674">9.4</a>, <a href="#hevea_default694">9.7</a>, <a href="#hevea_default697">9.7</a>
</li><li class="li-indexenv">parameter, <a href="#hevea_default193">3.7</a>, <a href="#hevea_default208">3.8</a>, <a href="#hevea_default237">3.13</a>, <a href="#hevea_default827">10.12</a>
<ul class="indexenv"><li class="li-indexenv">gather, <a href="#hevea_default1052">12.4</a>
</li><li class="li-indexenv">optional, <a href="#hevea_default1167">13.5</a>, <a href="#hevea_default1488">17.5</a>
</li><li class="li-indexenv">other, <a href="#hevea_default1484">17.4</a>
</li><li class="li-indexenv">self, <a href="#hevea_default1476">17.2</a>
</li></ul>
</li><li class="li-indexenv">parent class, <a href="#hevea_default1611">18.7</a>, <a href="#hevea_default1615">18.7</a>, <a href="#hevea_default1648">18.11</a>
</li><li class="li-indexenv">parentheses<ul class="indexenv"><li class="li-indexenv">argument in, <a href="#hevea_default148">3.1</a>
</li><li class="li-indexenv">empty, <a href="#hevea_default182">3.4</a>, <a href="#hevea_default600">8.8</a>
</li><li class="li-indexenv">parameters in, <a href="#hevea_default197">3.7</a>, <a href="#hevea_default204">3.8</a>
</li><li class="li-indexenv">parent class in, <a href="#hevea_default1610">18.7</a>
</li><li class="li-indexenv">tuples in, <a href="#hevea_default1012">12.1</a>
</li></ul>
</li><li class="li-indexenv">parse, <a href="#hevea_default52">1.6</a>, <a href="#hevea_default82">1.8</a>
</li><li class="li-indexenv">pass statement, <a href="#hevea_default348">5.4</a>
</li><li class="li-indexenv">path, <a href="#hevea_default1226">14.4</a>, <a href="#hevea_default1308">14.11</a>
<ul class="indexenv"><li class="li-indexenv">absolute, <a href="#hevea_default1238">14.4</a>
</li><li class="li-indexenv">relative, <a href="#hevea_default1236">14.4</a>
</li></ul>
</li><li class="li-indexenv">pattern<ul class="indexenv"><li class="li-indexenv">filter, <a href="#hevea_default779">10.7</a>, <a href="#hevea_default855">10.14</a>, <a href="#hevea_default1675">19.2</a>
</li><li class="li-indexenv">guardian, <a href="#hevea_default475">6.8</a>, <a href="#hevea_default486">6.10</a>, <a href="#hevea_default614">8.11</a>
</li><li class="li-indexenv">map, <a href="#hevea_default777">10.7</a>, <a href="#hevea_default853">10.14</a>
</li><li class="li-indexenv">reduce, <a href="#hevea_default773">10.7</a>, <a href="#hevea_default851">10.14</a>
</li><li class="li-indexenv">search, <a href="#hevea_default592">8.6</a>, <a href="#hevea_default629">8.12</a>, <a href="#hevea_default664">9.3</a>, <a href="#hevea_default925">11.4</a>, <a href="#hevea_default1690">19.4</a>
</li><li class="li-indexenv">swap, <a href="#hevea_default1032">12.2</a>
</li></ul>
</li><li class="li-indexenv">pdb (Python debugger), <a href="#hevea_default1784">A.2.3</a>
</li><li class="li-indexenv">permission, file, <a href="#hevea_default1248">14.5</a>
</li><li class="li-indexenv">persistence, <a href="#hevea_default1211">14.1</a>, <a href="#hevea_default1301">14.11</a>
</li><li class="li-indexenv">pi, <a href="#hevea_default170">3.2</a>, <a href="#hevea_default542">7.9</a>
</li><li class="li-indexenv">pickle module, <a href="#hevea_default1212">14.1</a>, <a href="#hevea_default1266">14.7</a>
</li><li class="li-indexenv">pickling, <a href="#hevea_default1265">14.7</a>
</li><li class="li-indexenv">pie, <a href="#hevea_default306">4.12</a>
</li><li class="li-indexenv">pipe, <a href="#hevea_default1271">14.8</a>
</li><li class="li-indexenv">pipe object, <a href="#hevea_default1316">14.11</a>
</li><li class="li-indexenv">plain text, <a href="#hevea_default650">9.1</a>, <a href="#hevea_default1144">13.1</a>
</li><li class="li-indexenv">planned development, <a href="#hevea_default1434">16.4</a>
</li><li class="li-indexenv">poetry, <a href="#hevea_default56">1.6</a>
</li><li class="li-indexenv">point, mathematical, <a href="#hevea_default1330">15.1</a>
</li><li class="li-indexenv">poker, <a href="#hevea_default1550">18</a>, <a href="#hevea_default1659">18.12</a>
</li><li class="li-indexenv">polygon
function, <a href="#hevea_default267">4.3</a>
</li><li class="li-indexenv">polymorphism, <a href="#hevea_default1512">17.9</a>, <a href="#hevea_default1538">17.12</a>
</li><li class="li-indexenv">pop method, <a href="#hevea_default782">10.8</a>, <a href="#hevea_default1597">18.6</a>
</li><li class="li-indexenv">popen function, <a href="#hevea_default1274">14.8</a>
</li><li class="li-indexenv">portability, <a href="#hevea_default66">1.8</a>
</li><li class="li-indexenv">positional argument, <a href="#hevea_default1481">17.3</a>, <a href="#hevea_default1533">17.12</a>, <a href="#hevea_default1719">19.9</a>
</li><li class="li-indexenv">postcondition, <a href="#hevea_default291">4.10</a>, <a href="#hevea_default478">6.9</a>, <a href="#hevea_default1636">18.9</a>
</li><li class="li-indexenv">pprint module, <a href="#hevea_default967">11.8</a>
</li><li class="li-indexenv">precedence, <a href="#hevea_default1799">A.3.2</a>
</li><li class="li-indexenv">precondition, <a href="#hevea_default290">4.10</a>, <a href="#hevea_default302">4.11</a>, <a href="#hevea_default303">4.11</a>, <a href="#hevea_default477">6.9</a>, <a href="#hevea_default1635">18.9</a>
</li><li class="li-indexenv">prefix, <a href="#hevea_default1180">13.8</a>
</li><li class="li-indexenv">pretty print, <a href="#hevea_default966">11.8</a>
</li><li class="li-indexenv">print function, <a href="#hevea_default24">1.3</a>
</li><li class="li-indexenv">print statement, <a href="#hevea_default21">1.3</a>, <a href="#hevea_default70">1.8</a>, <a href="#hevea_default1496">17.6</a>, <a href="#hevea_default1785">A.2.4</a>
</li><li class="li-indexenv">problem solving, <a href="#hevea_default10">1</a>, <a href="#hevea_default63">1.8</a>
</li><li class="li-indexenv">profile module, <a href="#hevea_default1190">13.9</a>
</li><li class="li-indexenv">program, <a href="#hevea_default11">1.1</a>, <a href="#hevea_default69">1.8</a>
</li><li class="li-indexenv">program testing, <a href="#hevea_default679">9.5</a>
</li><li class="li-indexenv">programmer-defined function, <a href="#hevea_default199">3.7</a>, <a href="#hevea_default1168">13.5</a>
</li><li class="li-indexenv">programmer-defined type, <a href="#hevea_default1328">15.1</a>, <a href="#hevea_default1399">15.8</a>, <a href="#hevea_default1413">16.1</a>, <a href="#hevea_default1467">17.1</a>, <a href="#hevea_default1498">17.7</a>, <a href="#hevea_default1572">18.3</a>
</li><li class="li-indexenv">prompt, <a href="#hevea_default18">1.2</a>, <a href="#hevea_default68">1.8</a>, <a href="#hevea_default384">5.11</a>
</li><li class="li-indexenv">prose, <a href="#hevea_default57">1.6</a>
</li><li class="li-indexenv">prototype and patch, <a href="#hevea_default1421">16.2</a>, <a href="#hevea_default1432">16.4</a>, <a href="#hevea_default1449">16.6</a>
</li><li class="li-indexenv">pseudorandom, <a href="#hevea_default1151">13.2</a>, <a href="#hevea_default1198">13.11</a>
</li><li class="li-indexenv">pure function, <a href="#hevea_default1423">16.2</a>, <a href="#hevea_default1451">16.6</a>
<br>
</li><li class="li-indexenv">quadratic, <a href="#hevea_default1868">B.5</a>
</li><li class="li-indexenv">quadratic growth, <a href="#hevea_default1827">B.1</a>
</li><li class="li-indexenv">quotation mark, <a href="#hevea_default20">1.3</a>, <a href="#hevea_default43">1.5</a>, <a href="#hevea_default283">4.9</a>, <a href="#hevea_default574">8.4</a>, <a href="#hevea_default1745">A.1</a>
<br>
</li><li class="li-indexenv">Ramanujan, Srinivasa, <a href="#hevea_default541">7.9</a>
</li><li class="li-indexenv">Rectangle class, <a href="#hevea_default1354">15.3</a>
</li><li class="li-indexenv">RuntimeError, <a href="#hevea_default379">5.10</a>, <a href="#hevea_default468">6.8</a>
</li><li class="li-indexenv">radd method, <a href="#hevea_default1508">17.8</a>
</li><li class="li-indexenv">radian, <a href="#hevea_default167">3.2</a>
</li><li class="li-indexenv">radix sort, <a href="#hevea_default1815">B</a>
</li><li class="li-indexenv">rage, <a href="#hevea_default1803">A.3.4</a>
</li><li class="li-indexenv">raise statement, <a href="#hevea_default926">11.4</a>, <a href="#hevea_default982">11.9</a>, <a href="#hevea_default1445">16.5</a>
</li><li class="li-indexenv">randint function, <a href="#hevea_default869">10.15</a>, <a href="#hevea_default1156">13.2</a>
</li><li class="li-indexenv">random function, <a href="#hevea_default1154">13.2</a>
</li><li class="li-indexenv">random module, <a href="#hevea_default867">10.15</a>, <a href="#hevea_default1152">13.2</a>, <a href="#hevea_default1602">18.6</a>
</li><li class="li-indexenv">random number, <a href="#hevea_default1148">13.2</a>
</li><li class="li-indexenv">random text, <a href="#hevea_default1183">13.8</a>
</li><li class="li-indexenv">random walk programming, <a href="#hevea_default1195">13.10</a>, <a href="#hevea_default1808">A.3.4</a>
</li><li class="li-indexenv">rank, <a href="#hevea_default1551">18.1</a>
</li><li class="li-indexenv">read method, <a href="#hevea_default1278">14.8</a>
</li><li class="li-indexenv">readline method, <a href="#hevea_default654">9.1</a>, <a href="#hevea_default1276">14.8</a>
</li><li class="li-indexenv">reassignment, <a href="#hevea_default495">7.1</a>, <a href="#hevea_default529">7.8</a>, <a href="#hevea_default720">10.2</a>, <a href="#hevea_default953">11.7</a>
</li><li class="li-indexenv">recursion, <a href="#hevea_default360">5.8</a>, <a href="#hevea_default362">5.8</a>, <a href="#hevea_default412">5.13</a>, <a href="#hevea_default445">6.5</a>, <a href="#hevea_default459">6.6</a>
<ul class="indexenv"><li class="li-indexenv">base case, <a href="#hevea_default372">5.9</a>
</li><li class="li-indexenv">infinite, <a href="#hevea_default374">5.10</a>, <a href="#hevea_default470">6.8</a>, <a href="#hevea_default1762">A.2.2</a>
</li></ul>
</li><li class="li-indexenv">recursive definition, <a href="#hevea_default455">6.5</a>, <a href="#hevea_default1133">12.10</a>
</li><li class="li-indexenv">red-black tree, <a href="#hevea_default1851">B.4</a>
</li><li class="li-indexenv">reduce pattern, <a href="#hevea_default772">10.7</a>, <a href="#hevea_default850">10.14</a>
</li><li class="li-indexenv">reducible word, <a href="#hevea_default1005">11.10</a>, <a href="#hevea_default1131">12.10</a>
</li><li class="li-indexenv">reduction to a
previously solved problem, <a href="#hevea_default670">9.3</a>
</li><li class="li-indexenv">reduction to a previously solved problem, <a href="#hevea_default675">9.4</a>, <a href="#hevea_default685">9.6</a>
</li><li class="li-indexenv">redundancy, <a href="#hevea_default54">1.6</a>
</li><li class="li-indexenv">refactoring, <a href="#hevea_default279">4.7</a>, <a href="#hevea_default280">4.7</a>, <a href="#hevea_default299">4.11</a>, <a href="#hevea_default1640">18.10</a>
</li><li class="li-indexenv">reference, <a href="#hevea_default820">10.11</a>, <a href="#hevea_default826">10.12</a>, <a href="#hevea_default859">10.14</a>
<ul class="indexenv"><li class="li-indexenv">aliasing, <a href="#hevea_default817">10.11</a>
</li></ul>
</li><li class="li-indexenv">rehashing, <a href="#hevea_default1856">B.4</a>
</li><li class="li-indexenv">relational operator, <a href="#hevea_default330">5.2</a>, <a href="#hevea_default1571">18.3</a>
</li><li class="li-indexenv">relative path, <a href="#hevea_default1235">14.4</a>, <a href="#hevea_default1309">14.11</a>
</li><li class="li-indexenv">reload function, <a href="#hevea_default1293">14.9</a>, <a href="#hevea_default1752">A.1.1</a>
</li><li class="li-indexenv">remove method, <a href="#hevea_default786">10.8</a>
</li><li class="li-indexenv">repetition, <a href="#hevea_default262">4.2</a>
<ul class="indexenv"><li class="li-indexenv">list, <a href="#hevea_default742">10.4</a>
</li></ul>
</li><li class="li-indexenv">replace method, <a href="#hevea_default1139">13.1</a>
</li><li class="li-indexenv">repr function, <a href="#hevea_default1297">14.10</a>
</li><li class="li-indexenv">representation, <a href="#hevea_default1331">15.1</a>, <a href="#hevea_default1353">15.3</a>, <a href="#hevea_default1556">18.1</a>
</li><li class="li-indexenv">return statement, <a href="#hevea_default364">5.8</a>, <a href="#hevea_default420">6.1</a>, <a href="#hevea_default1800">A.3.3</a>
</li><li class="li-indexenv">return value, <a href="#hevea_default150">3.1</a>, <a href="#hevea_default241">3.13</a>, <a href="#hevea_default419">6.1</a>, <a href="#hevea_default1363">15.4</a>
<ul class="indexenv"><li class="li-indexenv">tuple, <a href="#hevea_default1040">12.3</a>
</li></ul>
</li><li class="li-indexenv">reverse lookup, <a href="#hevea_default981">11.9</a>
</li><li class="li-indexenv">reverse lookup, dictionary, <a href="#hevea_default923">11.4</a>
</li><li class="li-indexenv">reverse word pair, <a href="#hevea_default885">10.15</a>
</li><li class="li-indexenv">reversed function, <a href="#hevea_default1103">12.7</a>
</li><li class="li-indexenv">rotation<ul class="indexenv"><li class="li-indexenv">letters, <a href="#hevea_default1001">11.10</a>
</li></ul>
</li><li class="li-indexenv">rotation, letter, <a href="#hevea_default645">8.13</a>
</li><li class="li-indexenv">rubber duck debugging, <a href="#hevea_default1202">13.11</a>
</li><li class="li-indexenv">running Python, <a href="#hevea_default12">1.2</a>
</li><li class="li-indexenv">running pace, <a href="#hevea_default87">1.9</a>, <a href="#hevea_default145">2.10</a>, <a href="#hevea_default1457">16.7</a>
</li><li class="li-indexenv">runtime error, <a href="#hevea_default118">2.8</a>, <a href="#hevea_default375">5.10</a>, <a href="#hevea_default392">5.12</a>, <a href="#hevea_default1733">A</a>, <a href="#hevea_default1765">A.2.3</a>
<br>
</li><li class="li-indexenv">Schmidt, Eric, <a href="#hevea_default1813">B</a>
</li><li class="li-indexenv">Scrabble, <a href="#hevea_default1126">12.10</a>
</li><li class="li-indexenv">StopIteration, <a href="#hevea_default1681">19.3</a>
</li><li class="li-indexenv">SyntaxError, <a href="#hevea_default174">3.3</a>
</li><li class="li-indexenv">safe language, <a href="#hevea_default121">2.8</a>
</li><li class="li-indexenv">sanity check, <a href="#hevea_default964">11.8</a>
</li><li class="li-indexenv">scaffolding, <a href="#hevea_default437">6.2</a>, <a href="#hevea_default484">6.10</a>, <a href="#hevea_default969">11.8</a>
</li><li class="li-indexenv">scatter, <a href="#hevea_default1054">12.4</a>, <a href="#hevea_default1116">12.9</a>, <a href="#hevea_default1723">19.9</a>
</li><li class="li-indexenv">script, <a href="#hevea_default101">2.4</a>, <a href="#hevea_default136">2.9</a>
</li><li class="li-indexenv">script mode, <a href="#hevea_default102">2.4</a>, <a href="#hevea_default104">2.4</a>, <a href="#hevea_default135">2.9</a>, <a href="#hevea_default221">3.10</a>
</li><li class="li-indexenv">search, <a href="#hevea_default924">11.4</a>, <a href="#hevea_default1844">B.3</a>, <a href="#hevea_default1869">B.5</a>
</li><li class="li-indexenv">search pattern, <a href="#hevea_default591">8.6</a>, <a href="#hevea_default628">8.12</a>, <a href="#hevea_default663">9.3</a>, <a href="#hevea_default1689">19.4</a>
</li><li class="li-indexenv">search, binary, <a href="#hevea_default882">10.15</a>
</li><li class="li-indexenv">search, bisection, <a href="#hevea_default879">10.15</a>
</li><li class="li-indexenv">self (parameter name), <a href="#hevea_default1475">17.2</a>
</li><li class="li-indexenv">semantic error, <a href="#hevea_default123">2.8</a>, <a href="#hevea_default143">2.9</a>, <a href="#hevea_default1736">A</a>, <a href="#hevea_default1790">A.3</a>
</li><li class="li-indexenv">semantics, <a href="#hevea_default142">2.9</a>, <a href="#hevea_default1466">17.1</a>
</li><li class="li-indexenv">sequence, <a href="#hevea_default44">1.5</a>, <a href="#hevea_default543">8</a>, <a href="#hevea_default544">8.1</a>, <a href="#hevea_default621">8.12</a>, <a href="#hevea_default701">10.1</a>, <a href="#hevea_default792">10.9</a>, <a href="#hevea_default1009">12.1</a>, <a href="#hevea_default1095">12.7</a>
</li><li class="li-indexenv">set, <a href="#hevea_default1175">13.6</a>, <a href="#hevea_default1694">19.5</a>
<ul class="indexenv"><li class="li-indexenv">anagram, <a href="#hevea_default1125">12.10</a>, <a href="#hevea_default1319">14.12</a>
</li></ul>
</li><li class="li-indexenv">set membership, <a href="#hevea_default993">11.10</a>
</li><li class="li-indexenv">set subtraction, <a href="#hevea_default1696">19.5</a>
</li><li class="li-indexenv">setdefault, <a href="#hevea_default1709">19.7</a>
</li><li class="li-indexenv">setdefault method, <a href="#hevea_default995">11.10</a>
</li><li class="li-indexenv">sexagesimal, <a href="#hevea_default1436">16.4</a>
</li><li class="li-indexenv">shallow copy, <a href="#hevea_default1380">15.6</a>, <a href="#hevea_default1409">15.8</a>
</li><li class="li-indexenv">shape, <a href="#hevea_default1121">12.9</a>
</li><li class="li-indexenv">shape error, <a href="#hevea_default1108">12.8</a>
</li><li class="li-indexenv">shell, <a href="#hevea_default1270">14.8</a>, <a href="#hevea_default1315">14.11</a>
</li><li class="li-indexenv">shelve module, <a href="#hevea_default1268">14.7</a>
</li><li class="li-indexenv">shuffle function, <a href="#hevea_default1604">18.6</a>
</li><li class="li-indexenv">sine function, <a href="#hevea_default166">3.2</a>
</li><li class="li-indexenv">singleton, <a href="#hevea_default935">11.5</a>, <a href="#hevea_default984">11.9</a>, <a href="#hevea_default1013">12.1</a>
</li><li class="li-indexenv">slice, <a href="#hevea_default624">8.12</a>
<ul class="indexenv"><li class="li-indexenv">copy, <a href="#hevea_default576">8.4</a>, <a href="#hevea_default750">10.5</a>
</li><li class="li-indexenv">list, <a href="#hevea_default748">10.5</a>
</li><li class="li-indexenv">string, <a href="#hevea_default573">8.4</a>
</li><li class="li-indexenv">tuple, <a href="#hevea_default1022">12.1</a>
</li><li class="li-indexenv">update, <a href="#hevea_default753">10.5</a>
</li></ul>
</li><li class="li-indexenv">slice operator, <a href="#hevea_default569">8.4</a>, <a href="#hevea_default641">8.13</a>, <a href="#hevea_default744">10.5</a>, <a href="#hevea_default834">10.12</a>, <a href="#hevea_default1019">12.1</a>
</li><li class="li-indexenv">sort method, <a href="#hevea_default761">10.6</a>, <a href="#hevea_default837">10.13</a>, <a href="#hevea_default1606">18.6</a>
</li><li class="li-indexenv">sorted<ul class="indexenv"><li class="li-indexenv">function, <a href="#hevea_default841">10.13</a>, <a href="#hevea_default918">11.3</a>
</li></ul>
</li><li class="li-indexenv">sorted function, <a href="#hevea_default1101">12.7</a>
</li><li class="li-indexenv">sorting, <a href="#hevea_default1838">B.2</a>, <a href="#hevea_default1841">B.2</a>
</li><li class="li-indexenv">special case, <a href="#hevea_default680">9.5</a>, <a href="#hevea_default687">9.6</a>, <a href="#hevea_default1430">16.3</a>
</li><li class="li-indexenv">special value<ul class="indexenv"><li class="li-indexenv">False, <a href="#hevea_default327">5.2</a>
</li><li class="li-indexenv">None, <a href="#hevea_default223">3.10</a>, <a href="#hevea_default245">3.13</a>, <a href="#hevea_default426">6.1</a>, <a href="#hevea_default766">10.6</a>, <a href="#hevea_default789">10.8</a>
</li><li class="li-indexenv">True, <a href="#hevea_default326">5.2</a>
</li></ul>
</li><li class="li-indexenv">spiral, <a href="#hevea_default310">4.12</a>
</li><li class="li-indexenv">split method, <a href="#hevea_default795">10.9</a>, <a href="#hevea_default1035">12.2</a>
</li><li class="li-indexenv">sqrt, <a href="#hevea_default435">6.2</a>
</li><li class="li-indexenv">sqrt function, <a href="#hevea_default171">3.2</a>
</li><li class="li-indexenv">square root, <a href="#hevea_default517">7.5</a>
</li><li class="li-indexenv">squiggly bracket, <a href="#hevea_default896">11.1</a>
</li><li class="li-indexenv">stable sort, <a href="#hevea_default1843">B.2</a>
</li><li class="li-indexenv">stack diagram, <a href="#hevea_default209">3.9</a>, <a href="#hevea_default212">3.9</a>, <a href="#hevea_default253">3.13</a>, <a href="#hevea_default304">4.12</a>, <a href="#hevea_default368">5.9</a>, <a href="#hevea_default456">6.5</a>, <a href="#hevea_default487">6.11</a>, <a href="#hevea_default828">10.12</a>
</li><li class="li-indexenv">state diagram, <a href="#hevea_default91">2.1</a>, <a href="#hevea_default128">2.9</a>, <a href="#hevea_default496">7.1</a>, <a href="#hevea_default618">8.11</a>, <a href="#hevea_default716">10.2</a>, <a href="#hevea_default810">10.10</a>, <a href="#hevea_default818">10.11</a>, <a href="#hevea_default936">11.5</a>, <a href="#hevea_default1093">12.6</a>, <a href="#hevea_default1347">15.2</a>, <a href="#hevea_default1356">15.3</a>, <a href="#hevea_default1376">15.6</a>, <a href="#hevea_default1417">16.1</a>, <a href="#hevea_default1566">18.2</a>
</li><li class="li-indexenv">statement, <a href="#hevea_default98">2.3</a>, <a href="#hevea_default132">2.9</a>
<ul class="indexenv"><li class="li-indexenv">assert, <a href="#hevea_default1448">16.5</a>, <a href="#hevea_default1456">16.6</a>
</li><li class="li-indexenv">assignment, <a href="#hevea_default90">2.1</a>, <a href="#hevea_default494">7.1</a>
</li><li class="li-indexenv">break, <a href="#hevea_default516">7.4</a>
</li><li class="li-indexenv">compound, <a href="#hevea_default347">5.4</a>
</li><li class="li-indexenv">conditional, <a href="#hevea_default341">5.4</a>, <a href="#hevea_default404">5.13</a>, <a href="#hevea_default444">6.4</a>, <a href="#hevea_default1669">19.1</a>
</li><li class="li-indexenv">for, <a href="#hevea_default265">4.2</a>, <a href="#hevea_default564">8.3</a>, <a href="#hevea_default732">10.3</a>
</li><li class="li-indexenv">global, <a href="#hevea_default955">11.7</a>, <a href="#hevea_default990">11.9</a>
</li><li class="li-indexenv">if, <a href="#hevea_default343">5.4</a>
</li><li class="li-indexenv">import, <a href="#hevea_default248">3.13</a>, <a href="#hevea_default1289">14.9</a>
</li><li class="li-indexenv">pass, <a href="#hevea_default349">5.4</a>
</li><li class="li-indexenv">print, <a href="#hevea_default22">1.3</a>, <a href="#hevea_default71">1.8</a>, <a href="#hevea_default1497">17.6</a>, <a href="#hevea_default1786">A.2.4</a>
</li><li class="li-indexenv">raise, <a href="#hevea_default927">11.4</a>, <a href="#hevea_default983">11.9</a>, <a href="#hevea_default1446">16.5</a>
</li><li class="li-indexenv">return, <a href="#hevea_default365">5.8</a>, <a href="#hevea_default421">6.1</a>, <a href="#hevea_default1801">A.3.3</a>
</li><li class="li-indexenv">try, <a href="#hevea_default1251">14.5</a>, <a href="#hevea_default1397">15.7</a>
</li><li class="li-indexenv">while, <a href="#hevea_default504">7.3</a>
</li></ul>
</li><li class="li-indexenv">step size, <a href="#hevea_default640">8.13</a>
</li><li class="li-indexenv">str function, <a href="#hevea_default157">3.1</a>
</li><li class="li-indexenv">__str__ method, <a href="#hevea_default1493">17.6</a>, <a href="#hevea_default1590">18.5</a>
</li><li class="li-indexenv">string, <a href="#hevea_default32">1.5</a>, <a href="#hevea_default77">1.8</a>, <a href="#hevea_default791">10.9</a>, <a href="#hevea_default1096">12.7</a>
<ul class="indexenv"><li class="li-indexenv">accumulator, <a href="#hevea_default1593">18.5</a>
</li><li class="li-indexenv">comparison, <a href="#hevea_default609">8.10</a>
</li><li class="li-indexenv">empty, <a href="#hevea_default804">10.9</a>
</li><li class="li-indexenv">immutable, <a href="#hevea_default579">8.5</a>
</li><li class="li-indexenv">method, <a href="#hevea_default599">8.8</a>
</li><li class="li-indexenv">multiline, <a href="#hevea_default287">4.9</a>, <a href="#hevea_default1747">A.1</a>
</li><li class="li-indexenv">operation, <a href="#hevea_default107">2.6</a>
</li><li class="li-indexenv">slice, <a href="#hevea_default572">8.4</a>
</li><li class="li-indexenv">triple-quoted, <a href="#hevea_default285">4.9</a>
</li></ul>
</li><li class="li-indexenv">string concatenation, <a href="#hevea_default1835">B.2</a>
</li><li class="li-indexenv">string method, <a href="#hevea_default634">8.13</a>
</li><li class="li-indexenv">string methods, <a href="#hevea_default1833">B.2</a>
</li><li class="li-indexenv">string module, <a href="#hevea_default1135">13.1</a>
</li><li class="li-indexenv">string representation, <a href="#hevea_default1299">14.10</a>, <a href="#hevea_default1495">17.6</a>
</li><li class="li-indexenv">string type, <a href="#hevea_default37">1.5</a>
</li><li class="li-indexenv">strip method, <a href="#hevea_default656">9.1</a>, <a href="#hevea_default1137">13.1</a>
</li><li class="li-indexenv">structshape module, <a href="#hevea_default1110">12.8</a>
</li><li class="li-indexenv">structure, <a href="#hevea_default51">1.6</a>
</li><li class="li-indexenv">subject, <a href="#hevea_default1474">17.2</a>, <a href="#hevea_default1532">17.12</a>
</li><li class="li-indexenv">subset, <a href="#hevea_default1698">19.5</a>
</li><li class="li-indexenv">subtraction<ul class="indexenv"><li class="li-indexenv">dictionary, <a href="#hevea_default1174">13.6</a>
</li><li class="li-indexenv">with borrowing, <a href="#hevea_default525">7.6</a>
</li></ul>
</li><li class="li-indexenv">subtraction with borrowing, <a href="#hevea_default1440">16.4</a>
</li><li class="li-indexenv">suffix, <a href="#hevea_default1181">13.8</a>
</li><li class="li-indexenv">suit, <a href="#hevea_default1552">18.1</a>
</li><li class="li-indexenv">sum, <a href="#hevea_default1683">19.3</a>
</li><li class="li-indexenv">sum function, <a href="#hevea_default1062">12.4</a>
</li><li class="li-indexenv">superstitious debugging, <a href="#hevea_default1807">A.3.4</a>
</li><li class="li-indexenv">swap pattern, <a href="#hevea_default1031">12.2</a>
</li><li class="li-indexenv">syntax, <a href="#hevea_default49">1.6</a>, <a href="#hevea_default81">1.8</a>, <a href="#hevea_default117">2.8</a>, <a href="#hevea_default1465">17.1</a>, <a href="#hevea_default1741">A.1</a>
</li><li class="li-indexenv">syntax error, <a href="#hevea_default114">2.8</a>, <a href="#hevea_default140">2.9</a>, <a href="#hevea_default1731">A</a>
<br>
</li><li class="li-indexenv">Time class, <a href="#hevea_default1415">16.1</a>
</li><li class="li-indexenv">True special value, <a href="#hevea_default324">5.2</a>
</li><li class="li-indexenv">Turing complete language, <a href="#hevea_default446">6.5</a>
</li><li class="li-indexenv">Turing Thesis, <a href="#hevea_default449">6.5</a>
</li><li class="li-indexenv">Turing, Alan, <a href="#hevea_default448">6.5</a>
</li><li class="li-indexenv">TypeError, <a href="#hevea_default553">8.1</a>, <a href="#hevea_default580">8.5</a>, <a href="#hevea_default938">11.5</a>, <a href="#hevea_default1024">12.1</a>, <a href="#hevea_default1056">12.4</a>, <a href="#hevea_default1224">14.3</a>, <a href="#hevea_default1480">17.3</a>, <a href="#hevea_default1769">A.2.3</a>
</li><li class="li-indexenv">temporary variable, <a href="#hevea_default422">6.1</a>, <a href="#hevea_default480">6.10</a>, <a href="#hevea_default1796">A.3.2</a>
</li><li class="li-indexenv">test case, minimal, <a href="#hevea_default1789">A.2.4</a>
</li><li class="li-indexenv">testing<ul class="indexenv"><li class="li-indexenv">and absence of bugs, <a href="#hevea_default681">9.5</a>
</li><li class="li-indexenv">incremental development, <a href="#hevea_default432">6.2</a>
</li><li class="li-indexenv">is hard, <a href="#hevea_default678">9.5</a>
</li><li class="li-indexenv">knowing the answer, <a href="#hevea_default434">6.2</a>
</li><li class="li-indexenv">leap of faith, <a href="#hevea_default461">6.6</a>
</li><li class="li-indexenv">minimal test case, <a href="#hevea_default1788">A.2.4</a>
</li></ul>
</li><li class="li-indexenv">text<ul class="indexenv"><li class="li-indexenv">plain, <a href="#hevea_default651">9.1</a>, <a href="#hevea_default1145">13.1</a>
</li><li class="li-indexenv">random, <a href="#hevea_default1184">13.8</a>
</li></ul>
</li><li class="li-indexenv">text file, <a href="#hevea_default1306">14.11</a>
</li><li class="li-indexenv">time module, <a href="#hevea_default875">10.15</a>
</li><li class="li-indexenv">token, <a href="#hevea_default50">1.6</a>, <a href="#hevea_default80">1.8</a>
</li><li class="li-indexenv">traceback, <a href="#hevea_default215">3.9</a>, <a href="#hevea_default256">3.13</a>, <a href="#hevea_default377">5.10</a>, <a href="#hevea_default389">5.12</a>, <a href="#hevea_default930">11.4</a>, <a href="#hevea_default1766">A.2.3</a>
</li><li class="li-indexenv">translate method, <a href="#hevea_default1141">13.1</a>
</li><li class="li-indexenv">traversal, <a href="#hevea_default560">8.3</a>, <a href="#hevea_default565">8.3</a>, <a href="#hevea_default590">8.6</a>, <a href="#hevea_default612">8.11</a>, <a href="#hevea_default627">8.12</a>, <a href="#hevea_default665">9.3</a>, <a href="#hevea_default669">9.3</a>, <a href="#hevea_default774">10.7</a>, <a href="#hevea_default849">10.14</a>, <a href="#hevea_default911">11.2</a>, <a href="#hevea_default917">11.3</a>, <a href="#hevea_default1068">12.5</a>, <a href="#hevea_default1073">12.5</a>, <a href="#hevea_default1164">13.3</a>
<ul class="indexenv"><li class="li-indexenv">dictionary, <a href="#hevea_default1520">17.10</a>
</li><li class="li-indexenv">list, <a href="#hevea_default729">10.3</a>
</li></ul>
</li><li class="li-indexenv">traverse<ul class="indexenv"><li class="li-indexenv">dictionary, <a href="#hevea_default1088">12.6</a>
</li></ul>
</li><li class="li-indexenv">triangle, <a href="#hevea_default416">5.14</a>
</li><li class="li-indexenv">trigonometric function, <a href="#hevea_default168">3.2</a>
</li><li class="li-indexenv">triple-quoted string, <a href="#hevea_default284">4.9</a>
</li><li class="li-indexenv">try statement, <a href="#hevea_default1250">14.5</a>, <a href="#hevea_default1396">15.7</a>
</li><li class="li-indexenv">tuple, <a href="#hevea_default1007">12.1</a>, <a href="#hevea_default1038">12.3</a>, <a href="#hevea_default1098">12.7</a>, <a href="#hevea_default1112">12.9</a>
<ul class="indexenv"><li class="li-indexenv">as key in dictionary, <a href="#hevea_default1090">12.6</a>, <a href="#hevea_default1188">13.9</a>
</li><li class="li-indexenv">assignment, <a href="#hevea_default1029">12.2</a>
</li><li class="li-indexenv">comparison, <a href="#hevea_default1028">12.1</a>, <a href="#hevea_default1578">18.3</a>
</li><li class="li-indexenv">in brackets, <a href="#hevea_default1092">12.6</a>
</li><li class="li-indexenv">singleton, <a href="#hevea_default1014">12.1</a>
</li><li class="li-indexenv">slice, <a href="#hevea_default1021">12.1</a>
</li></ul>
</li><li class="li-indexenv">tuple assignment, <a href="#hevea_default1043">12.3</a>, <a href="#hevea_default1069">12.5</a>, <a href="#hevea_default1113">12.9</a>
</li><li class="li-indexenv">tuple function, <a href="#hevea_default1015">12.1</a>
</li><li class="li-indexenv">tuple methods, <a href="#hevea_default1834">B.2</a>
</li><li class="li-indexenv">turtle module, <a href="#hevea_default417">5.14</a>
</li><li class="li-indexenv">turtle typewriter, <a href="#hevea_default308">4.12</a>
</li><li class="li-indexenv">type, <a href="#hevea_default31">1.5</a>, <a href="#hevea_default36">1.5</a>, <a href="#hevea_default74">1.8</a>
<ul class="indexenv"><li class="li-indexenv">bool, <a href="#hevea_default329">5.2</a>
</li><li class="li-indexenv">dict, <a href="#hevea_default889">11.1</a>
</li><li class="li-indexenv">file, <a href="#hevea_default1210">14.1</a>
</li><li class="li-indexenv">float, <a href="#hevea_default42">1.5</a>
</li><li class="li-indexenv">function, <a href="#hevea_default189">3.4</a>
</li><li class="li-indexenv">int, <a href="#hevea_default40">1.5</a>
</li><li class="li-indexenv">list, <a href="#hevea_default699">10.1</a>
</li><li class="li-indexenv">NoneType, <a href="#hevea_default225">3.10</a>
</li><li class="li-indexenv">programmer-defined, <a href="#hevea_default1329">15.1</a>, <a href="#hevea_default1400">15.8</a>, <a href="#hevea_default1414">16.1</a>, <a href="#hevea_default1468">17.1</a>, <a href="#hevea_default1499">17.7</a>, <a href="#hevea_default1573">18.3</a>
</li><li class="li-indexenv">set, <a href="#hevea_default1176">13.6</a>
</li><li class="li-indexenv">str, <a href="#hevea_default38">1.5</a>
</li><li class="li-indexenv">tuple, <a href="#hevea_default1008">12.1</a>
</li></ul>
</li><li class="li-indexenv">type checking, <a href="#hevea_default465">6.8</a>
</li><li class="li-indexenv">type conversion, <a href="#hevea_default152">3.1</a>
</li><li class="li-indexenv">type function, <a href="#hevea_default1389">15.7</a>
</li><li class="li-indexenv">type-based dispatch, <a href="#hevea_default1505">17.8</a>, <a href="#hevea_default1510">17.9</a>, <a href="#hevea_default1537">17.12</a>
</li><li class="li-indexenv">typewriter, turtle, <a href="#hevea_default309">4.12</a>
</li><li class="li-indexenv">typographical error, <a href="#hevea_default1193">13.10</a>
<br>
</li><li class="li-indexenv">UnboundLocalError, <a href="#hevea_default959">11.7</a>
</li><li class="li-indexenv">Unix command<ul class="indexenv"><li class="li-indexenv">ls, <a href="#hevea_default1273">14.8</a>
</li></ul>
</li><li class="li-indexenv">underscore character, <a href="#hevea_default94">2.2</a>
</li><li class="li-indexenv">uniqueness, <a href="#hevea_default865">10.15</a>
</li><li class="li-indexenv">update, <a href="#hevea_default499">7.2</a>, <a href="#hevea_default519">7.5</a>, <a href="#hevea_default530">7.8</a>
<ul class="indexenv"><li class="li-indexenv">database, <a href="#hevea_default1259">14.6</a>
</li><li class="li-indexenv">global variable, <a href="#hevea_default957">11.7</a>
</li><li class="li-indexenv">histogram, <a href="#hevea_default1165">13.3</a>
</li><li class="li-indexenv">item, <a href="#hevea_default736">10.3</a>
</li><li class="li-indexenv">slice, <a href="#hevea_default754">10.5</a>
</li></ul>
</li><li class="li-indexenv">update method, <a href="#hevea_default1086">12.6</a>
</li><li class="li-indexenv">update operator, <a href="#hevea_default767">10.7</a>
</li><li class="li-indexenv">use before def, <a href="#hevea_default191">3.5</a>
<br>
</li><li class="li-indexenv">ValueError, <a href="#hevea_default386">5.11</a>, <a href="#hevea_default1034">12.2</a>
</li><li class="li-indexenv">value, <a href="#hevea_default30">1.5</a>, <a href="#hevea_default73">1.8</a>, <a href="#hevea_default806">10.10</a>, <a href="#hevea_default815">10.10</a>, <a href="#hevea_default975">11.9</a>
<ul class="indexenv"><li class="li-indexenv">default, <a href="#hevea_default1171">13.5</a>
</li><li class="li-indexenv">tuple, <a href="#hevea_default1039">12.3</a>
</li></ul>
</li><li class="li-indexenv">values method, <a href="#hevea_default905">11.1</a>
</li><li class="li-indexenv">variable, <a href="#hevea_default88">2</a>, <a href="#hevea_default93">2.2</a>, <a href="#hevea_default126">2.9</a>
<ul class="indexenv"><li class="li-indexenv">global, <a href="#hevea_default950">11.7</a>
</li><li class="li-indexenv">local, <a href="#hevea_default203">3.8</a>
</li><li class="li-indexenv">temporary, <a href="#hevea_default423">6.1</a>, <a href="#hevea_default481">6.10</a>, <a href="#hevea_default1797">A.3.2</a>
</li><li class="li-indexenv">updating, <a href="#hevea_default500">7.2</a>
</li></ul>
</li><li class="li-indexenv">variable-length argument tuple, <a href="#hevea_default1049">12.4</a>
</li><li class="li-indexenv">veneer, <a href="#hevea_default1601">18.6</a>, <a href="#hevea_default1646">18.11</a>
</li><li class="li-indexenv">void function, <a href="#hevea_default217">3.10</a>, <a href="#hevea_default243">3.13</a>
</li><li class="li-indexenv">void method, <a href="#hevea_default763">10.6</a>
</li><li class="li-indexenv">vorpal, <a href="#hevea_default450">6.5</a>
<br>
</li><li class="li-indexenv">walk, directory, <a href="#hevea_default1241">14.4</a>
</li><li class="li-indexenv">while loop, <a href="#hevea_default505">7.3</a>
</li><li class="li-indexenv">whitespace, <a href="#hevea_default390">5.12</a>, <a href="#hevea_default660">9.2</a>, <a href="#hevea_default1296">14.10</a>, <a href="#hevea_default1750">A.1</a>
</li><li class="li-indexenv">word count, <a href="#hevea_default1285">14.9</a>
</li><li class="li-indexenv">word frequency, <a href="#hevea_default1146">13.1</a>, <a href="#hevea_default1204">13.12</a>
</li><li class="li-indexenv">word, reducible, <a href="#hevea_default1006">11.10</a>, <a href="#hevea_default1132">12.10</a>
</li><li class="li-indexenv">working directory, <a href="#hevea_default1233">14.4</a>
</li><li class="li-indexenv">worst bug, <a href="#hevea_default1541">17.13</a>
</li><li class="li-indexenv">worst case, <a href="#hevea_default1818">B</a>, <a href="#hevea_default1862">B.5</a>
<br>
</li><li class="li-indexenv">Zipf&#X2019;s law, <a href="#hevea_default1206">13.12</a>
</li><li class="li-indexenv">zero, index
starting at, <a href="#hevea_default550">8.1</a>
</li><li class="li-indexenv">zero, index starting at, <a href="#hevea_default715">10.2</a>
</li><li class="li-indexenv">zip function, <a href="#hevea_default1064">12.5</a>
<ul class="indexenv"><li class="li-indexenv">use with dict, <a href="#hevea_default1085">12.6</a>
</li></ul>
</li><li class="li-indexenv">zip object, <a href="#hevea_default1117">12.9</a>
</li></ul></td></tr>
</table>
</div><!--CUT END -->
<!--HTMLFOOT-->
<p>
<a href="http://amzn.to/1VUYQUU">Buy this book at Amazon.com</a>

</td>

<td width=130 valign="top">

<h4>Contribute</h4>
If you would like to make a contribution to support my books,
you can use the button below and pay with PayPal.  Thank you!

<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="hosted_button_id" value="RAAYAZ7Y48S2A">
<table>
<tr><td><input type="hidden" name="on0" value="Pay what you want!">Pay what you want:</td></tr><tr><td><select name="os0">
	<option value="Small">Small $1.00 USD</option>
	<option value="Medium">Medium $5.00 USD</option>
	<option value="Large">Large $10.00 USD</option>
	<option value="X-Large">X-Large $20.00 USD</option>
	<option value="XX-Large">XX-Large $50.00 USD</option>
</select> </td></tr>
</table>
<input type="hidden" name="currency_code" value="USD">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_paynow_LG.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
<img alt="" border="0" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form>

  
<p>
<h4>Are you using one of our books in a class?</h4>  We'd like to know
about it.  Please consider filling out <a href="http://spreadsheets.google.com/viewform?formkey=dC0tNUZkMjBEdXVoRGljNm9FRmlTMHc6MA" onClick="javascript: pageTracker._trackPageview('/outbound/survey');">this short survey</a>.

<p>
<br>

<p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491938455/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491938455&linkCode=as2&tag=greenteapre01-20&linkId=2JJH4SWCAVVYSQHO">Think DSP</a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491938455" width="1" height="1" border="0" alt="">

<p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491938455/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491938455&linkCode=as2&tag=greenteapre01-20&linkId=CTV7PDT7E5EGGJUM"><img border="0" src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=1491938455&Format=_SL160_&ID=AsinImage&MarketPlace=US&ServiceVersion=20070822&WS=1&tag=greenteapre01-20"></a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491938455" width="1" height="1" border="0" alt="">

<p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491929561/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491929561&linkCode=as2&tag=greenteapre01-20&linkId=ZY6MAYM33ZTNSCNZ">Think Java</a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491929561" width="1" height="1" border="0" alt="">

<p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491929561/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491929561&linkCode=as2&tag=greenteapre01-20&linkId=PT77ANWARUNNU3UK"><img border="0" src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=1491929561&Format=_SL160_&ID=AsinImage&MarketPlace=US&ServiceVersion=20070822&WS=1&tag=greenteapre01-20"></a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491929561" width="1" height="1" border="0" alt="">

<p>
<a href="http://www.amazon.com/gp/product/1449370780/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1449370780&linkCode=as2&tag=greenteapre01-20">Think Bayes</a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1449370780" width="1" height="1" border="0" alt="">

<p>
<a href="http://www.amazon.com/gp/product/1449370780/ref=as_li_qf_sp_asin_il?ie=UTF8&camp=1789&creative=9325&creativeASIN=1449370780&linkCode=as2&tag=greenteapre01-20"><img border="0" src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=1449370780&amp;Format=_SL160_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=greenteapre01-20"></a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1449370780" width="1" height="1" border="0" alt="">

<p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491939362/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491939362&linkCode=as2&tag=greenteapre01-20&linkId=FJKSQ3IHEMY2F2VA">Think Python 2e</a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491939362" width="1" height="1" border="0" alt="">


<p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491939362/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491939362&linkCode=as2&tag=greenteapre01-20&linkId=ZZ454DLQ3IXDHNHX"><img border="0" src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=1491939362&Format=_SL160_&ID=AsinImage&MarketPlace=US&ServiceVersion=20070822&WS=1&tag=greenteapre01-20"></a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491939362" width="1" height="1" border="0" alt="">

<p>
<a href="http://www.amazon.com/gp/product/1491907339/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491907339&linkCode=as2&tag=greenteapre01-20&linkId=O7WYM6H6YBYUFNWU">Think Stats 2e</a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491907339" width="1" height="1" border="0" alt="">

<p>
<a href="http://www.amazon.com/gp/product/1491907339/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491907339&linkCode=as2&tag=greenteapre01-20&linkId=JVSYKQHYSUIEYRHL"><img border="0" src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=1491907339&amp;Format=_SL160_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=greenteapre01-20"></a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491907339" width="1" height="1" border="0" alt="">

<p>
<a href="http://www.amazon.com/gp/product/1449314635/ref=as_li_tf_tl?ie=UTF8&tag=greenteapre01-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1449314635">Think Complexity</a><img class="c003" src="http://www.assoc-amazon.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1449314635" width="1" height="1" border="0" alt="">

<p>
<a href="http://www.amazon.com/gp/product/1449314635/ref=as_li_tf_il?ie=UTF8&camp=1789&creative=9325&creativeASIN=1449314635&linkCode=as2&tag=greenteapre01-20"><img border="0" src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=1449314635&amp;Format=_SL160_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=greenteapre01-20"></a><img class="c003" src="http://www.assoc-amazon.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1449314635" width="1" height="1" border="0" alt="">


</td>
</tr>
</table>
<!--ENDHTML-->
<!--FOOTER-->
<hr class="horizontal-rule" style="height:2px"><blockquote class="quote"><em>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</em><a href="http://hevea.inria.fr/index.html"><em>H<span class="c007"><sup>E</sup></span>V<span class="c007"><sup>E</sup></span>A</em></a><em>.</em></blockquote></body>
</html>
